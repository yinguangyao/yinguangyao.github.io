---
title: 50行代码实现模板引擎
date: 2018-04-24 10:35:40
tags:
- underscore
- 前端
- 模板引擎
---
不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，这里是传送门：[只有20行的Javascript模板引擎][1]
这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。
但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。
恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。
这个是我自己写demo的时候实现的一个模板引擎，依然还存在上面那些问题。
```
(function () {
    const root = this;
    let match, index = 0, code = "const arr = [];"
    let evaluate = /<%([\s\S]+?)%>/g, reJs = /^( )?(for|if|switch|case|else|break|{|})(.*)/g
    const escapes = {
        "'": "'",
        '"': '"',
        '\\': '\\',
        '\r': 'r',  
        '\n': 'n',
        '\u2028': 'u2028', 
        '\u2029': 'u2029' 
      };
    const escapeChar = (escape) => {
        return '\\' + escapes[escape];
    }
    const escaper = /\\|'|"|\r|\n|\u2028|\u2029/g;
    const add = (str, bool) => {
        code += bool? str.match(reJs) ? str : 'arr.push(' + str + ');' : 'arr.push("' + str.replace(escaper, escapeChar) + '");\n'
        return add;
    }
    const templateX = function (tpl, obj, newEvaluate) {
        if(newEvaluate)  evaluate = newEvaluate
        while (match = evaluate.exec(tpl)) {
            add(tpl.slice(index, match.index))(match[1], true)
            index = match[0].length + match.index
        }
        add(tpl.slice(index, tpl.length))
        code = "with(obj) {\n" + code + 'return arr.join(\"\")' + "\n}";
        return new Function("obj", code)(obj);
    }
    root.templateX = templateX
}.call(this))
```
  [1]: https://segmentfault.com/a/1190000005705169