{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ETH.png","path":"images/ETH.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/xiong.jpg","path":"images/xiong.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/zhihu.svg","path":"images/zhihu.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/touxiang.png","path":"images/touxiang.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/me.jpg","path":"images/me.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"c9e531ba4730789adf382049ec17de18a3756492","modified":1527252336034},{"_id":"source/.DS_Store","hash":"12b3a9b11f9181bbacb6bab8b8268a03464181d2","modified":1533390192922},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1527252336039},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1527252336040},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1527252336040},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1527252336042},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1527252336041},{"_id":"themes/hexo-theme-next/.DS_Store","hash":"77cc9d08cbede66902b99d7dea66a4099c0fe904","modified":1554617897771},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1527252336042},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1527252336043},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1527252336043},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1527252336043},{"_id":"themes/hexo-theme-next/README.md","hash":"85696981852ac088cb711444b4b2446824060a74","modified":1527252336044},{"_id":"themes/hexo-theme-next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1527252336044},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1527252336044},{"_id":"themes/hexo-theme-next/_config.yml","hash":"04983889d37f394883afa87e818219ee8f3abfaa","modified":1554617830168},{"_id":"themes/hexo-theme-next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1527252336080},{"_id":"source/_posts/2019展望.md","hash":"3b3bb29f979bb619675c9a8a3f3d3fc3e2ff8d36","modified":1554616392952},{"_id":"source/_posts/60行代码实现模板引擎.md","hash":"6b4e5d0e6969e4d0c2066e9a0ac1cef55086d3ae","modified":1554616392953},{"_id":"source/_posts/JS函数柯里化.md","hash":"f15da56a87cc824b63c0007ccbc2095979e90b67","modified":1554616392953},{"_id":"source/_posts/TypeScript踩坑（持续更新）.md","hash":"c52f6e954e1802cdec7a46e6ddbe141b3da848f7","modified":1554616392954},{"_id":"source/_posts/react状态管理.md","hash":"182283a97ac7c852f6d5111233b2da20d3d7d069","modified":1554616392955},{"_id":"source/_posts/redux源码分析.md","hash":"553ba82f6cc67c3354ffae3dd10d9deeb9ef58d1","modified":1554616392958},{"_id":"source/_posts/underscore debounce防抖动函数分析.md","hash":"29aca10257e1ea8d8fa66e923c1d27af279d435d","modified":1554616392959},{"_id":"source/_posts/underscore throttle节流函数分析.md","hash":"ec5a24349877e08495a1b5c986e7466cedce074a","modified":1554616392961},{"_id":"source/_posts/underscore查找索引函数分析.md","hash":"6a7901586c12afb70b016fac622f58b4ec148bc2","modified":1554616392962},{"_id":"source/_posts/underscore源码剖析之基础方法.md","hash":"8caaf1d3a4f9d175e1133c3ba535168c56ca4e76","modified":1554616392964},{"_id":"source/_posts/underscore源码剖析之数组遍历函数分析（一）.md","hash":"13767e37b598468ae7931a2b77870e2eceb12ce2","modified":1554616392965},{"_id":"source/_posts/underscore源码剖析之数组遍历函数分析（二）.md","hash":"835e4853964e6f8a62d4c7e19af1bf0d19d738c1","modified":1554616392966},{"_id":"source/_posts/《守望者》观后感.md","hash":"15d3f11ca8450cedbf35688e2aad19d22a43f82e","modified":1554616540887},{"_id":"source/_posts/underscore源码剖析之整体架构.md","hash":"2916a20400dff1ca75f1cb0e9eb4120444a8bc94","modified":1554616392967},{"_id":"source/_posts/《编写可维护的JS》笔记.md","hash":"4211c531f764731a27f4217a29c1a25495175f84","modified":1554616392970},{"_id":"source/_posts/世界变了样.md","hash":"30733a2eeddd944e2b2049cea0156663a1fd3acb","modified":1554616392971},{"_id":"source/_posts/为什么活着.md","hash":"2e22aab2109c0b3cb8374b66d83d88f033f04516","modified":1554616392974},{"_id":"source/_posts/优化代码中的条件判断.md","hash":"a1526cf3c3578b5da69a0dc956633c258c48338c","modified":1554616573865},{"_id":"source/_posts/再见，携程.md","hash":"957cb7cc3b8e34efe22a2e9a0e686539e965b74a","modified":1554616392980},{"_id":"source/_posts/周报（2018-12-07）.md","hash":"0e73a61743ee54c1a8b9e6273625d38ed4202d19","modified":1554616644431},{"_id":"source/_posts/周报（2018-12-14）.md","hash":"2387247cfcca4519d5c6c1404d1f90c15bf95212","modified":1554616392983},{"_id":"source/_posts/塞尔达传说.md","hash":"a466b99d28a0a2c3edc9618130673925a3026f3d","modified":1554616392985},{"_id":"source/_posts/周报（2018-12-21）.md","hash":"61806733c972232b373b9b3a49aaf6403795626d","modified":1554616653195},{"_id":"source/_posts/如何写好前端业务代码？.md","hash":"bc88724e3e9a38c1fef4d0d8a76fc4ada52847b4","modified":1554616392989},{"_id":"source/_posts/实现一个bind函数.md","hash":"e67b2e581e4efd08a5106c1e8dabd43da15788f8","modified":1554616392994},{"_id":"source/_posts/富爸爸穷爸爸.md","hash":"22beb947acbc8b47a0a60789996fc701c381e040","modified":1554616392994},{"_id":"source/_posts/就算世界无童话.md","hash":"b5107e31aa84a9a4ada4df8ec92f37a4d89335af","modified":1554616393001},{"_id":"source/_posts/校招的一些感受.md","hash":"80e35c9c592c33d7a8d781def163efae2a38afe7","modified":1554616393006},{"_id":"source/_posts/梦境小说.md","hash":"f25fd5158403571f10803efe15e614ed3e19ff7e","modified":1554616393007},{"_id":"source/_posts/毕业二三事.md","hash":"3cf0baebd775df8d1210399587884dc9a7623e2e","modified":1554616393011},{"_id":"source/_posts/流光飞舞.md","hash":"3ebf637919c2750888a65e404980d1ac71c0205c","modified":1554616393016},{"_id":"source/_posts/深入理解react.md","hash":"72724db020469622d014de8cc1d488f1a51a7bba","modified":1554616393022},{"_id":"source/_posts/深夜思考.md","hash":"1e7f4466fa30727f7397b0ed12f9c906c30138a9","modified":1554616393024},{"_id":"source/_posts/牡丹亭外.md","hash":"c4a403273df72db7943c9983aaa9cd44995d39ac","modified":1527252336038},{"_id":"source/_posts/管理自己.md","hash":"9eb229eaa1e58d1c32eb24bbd4aef337afab07fd","modified":1554616393028},{"_id":"source/_posts/蔡康永的说话之道.md","hash":"3e88218b6a69fe8b722a55d5c51e72fc624de390","modified":1554616393030},{"_id":"source/_posts/记一次社招面试.md","hash":"fff695bdcf0422ae236c9904d210b3fb93daeca2","modified":1554616393031},{"_id":"source/_posts/记一次社招面试（二）.md","hash":"cf45f36bc4210d160fd273af9570fecb89ca3e67","modified":1554616393033},{"_id":"source/about/index.md","hash":"a0be1727664b549a44fc1d2b2273a818947480b1","modified":1553700186415},{"_id":"source/categories/index.md","hash":"9c91e1f2691983972809aee61d8c885f57b0f59d","modified":1527252336039},{"_id":"source/tags/index.md","hash":"f8c454c224e54f009dd469e924776f826a73a2d2","modified":1527252336039},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1527252336057},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1527252336079},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1527252336079},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1527252336079},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1527252336079},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1527252336080},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1527252336080},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1527252336045},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1527252336045},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1527252336046},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1527252336048},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1527252336048},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1527252336049},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"e3e9c6963f9f7eb6b20102a5c3c99939282dc4b9","modified":1527252336079},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1527252336049},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1527252336050},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1527252336051},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1527252336051},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1527252336053},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1527252336054},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1527252336054},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1554617616323},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1527252336055},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1527252336080},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1527252336055},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1527252336081},{"_id":"themes/hexo-theme-next/source/.DS_Store","hash":"367bad95189c47365ee700105926aedc3776ce13","modified":1554617897770},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1527252336182},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1527252336182},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1527252336182},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336106},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1546439587086},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1527252336055},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1527252336059},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1527252336056},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1527252336060},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1527252336060},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1527252336059},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1527252336061},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1527252336061},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1527252336066},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1527252336065},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1527252336068},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1527252336075},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1527252336075},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1527252336076},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1527252336076},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1527252336076},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1527252336077},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1527252336077},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1527252336057},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1527252336058},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"6935fde92937a2f9ffcca91aea23c32e04d47b4f","modified":1554617555135},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1527252336058},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1527252336058},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1527252336058},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1527252336081},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1527252336081},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1527252336081},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1527252336082},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1527252336082},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1527252336082},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1527252336082},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1527252336082},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1527252336083},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1527252336106},{"_id":"themes/hexo-theme-next/source/images/.DS_Store","hash":"4ab55eff165e516fcc174a028038ba225577e6e5","modified":1554617902864},{"_id":"themes/hexo-theme-next/source/images/ETH.png","hash":"a7c437c9c0037cd178025f638e51f72ca7e0abe9","modified":1527252336107},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1527252336107},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1527252336110},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1527252336111},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1527252336111},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1527252336113},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1527252336112},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1527252336111},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1527252336112},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1527252336114},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1527252336113},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1527252336114},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1527252336114},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1527252336115},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1527252336115},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1527252336115},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1527252336115},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1527252336116},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1527252336116},{"_id":"themes/hexo-theme-next/source/images/xiong.jpg","hash":"9c3b2868bb9ec01e05ea334ec8f55cb377ea1027","modified":1527252336117},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","hash":"7d901488caf7480a49f24de97e8a18ec607b94db","modified":1527252336117},{"_id":"themes/hexo-theme-next/source/images/zhihu.svg","hash":"101faa76d8f77456663522b2a2585b853f7b76c1","modified":1554617352124},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336067},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336067},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336098},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","hash":"5eb0ecf461d58f9aa862b7d42a9106ec9ea771f4","modified":1527252336110},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1527252336059},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1527252336060},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1527252336061},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1527252336062},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1527252336062},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1527252336063},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1527252336062},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1527252336063},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1527252336064},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1527252336066},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1527252336067},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1527252336073},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1527252336068},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1527252336073},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1527252336073},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1527252336074},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1527252336073},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1527252336074},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1527252336074},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1527252336075},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1527252336075},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1527252336068},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1527252336069},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1527252336069},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1527252336069},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1527252336070},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1527252336070},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1527252336069},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1527252336071},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1527252336071},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1527252336072},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1527252336072},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1527252336070},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1527252336071},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1527252336078},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1527252336078},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1527252336078},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1527252336079},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1527252336098},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1527252336105},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1527252336118},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1527252336118},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1527252336118},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1527252336118},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1527252336119},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1527252336120},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1527252336120},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1527252336121},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1527252336121},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1527252336127},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1527252336131},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1527252336119},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1527252336132},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1527252336132},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1527252336132},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1527252336137},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1527252336138},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1527252336138},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1527252336138},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1527252336140},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1527252336140},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1527252336140},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1527252336140},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1527252336141},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1527252336163},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1527252336161},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1527252336163},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1527252336164},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1527252336163},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1527252336164},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1527252336164},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1527252336166},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1527252336166},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1527252336166},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1527252336167},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1527252336167},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1527252336167},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1527252336167},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1527252336168},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1527252336168},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1527252336168},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1527252336168},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1527252336169},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1527252336169},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1527252336169},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1527252336170},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1527252336170},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1527252336170},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1527252336177},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1527252336178},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1527252336181},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1527252336181},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1527252336165},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1527252336181},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1527252336165},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1527252336166},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1527252336119},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1527252336162},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1527252336078},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1527252336078},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1527252336083},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1527252336083},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1527252336083},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1527252336090},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1527252336095},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"19dccf83801b12885b2cac684f4917bb72730f4f","modified":1527252336095},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1527252336095},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1527252336096},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1527252336096},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1527252336096},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1527252336097},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1527252336098},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1527252336099},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1527252336100},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1527252336101},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1527252336101},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1527252336101},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1527252336102},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1527252336102},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1527252336103},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1527252336102},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1527252336103},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1527252336104},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1527252336104},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1527252336104},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1527252336120},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1527252336124},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1527252336126},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1527252336126},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1527252336133},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1527252336133},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1527252336133},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1527252336134},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1527252336134},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1527252336134},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1527252336136},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1527252336137},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1527252336136},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1527252336139},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"ec0f0f7b0cbf892e973aeafee87e6ba1e6a7c86b","modified":1554617226325},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"24402d749b152b9a65cf13c92b0a0eaa2c4d6021","modified":1554617417976},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1527252336141},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1527252336176},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1527252336177},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1527252336125},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1527252336139},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1527252336161},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1527252336180},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1527252336084},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1527252336085},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1527252336086},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1527252336087},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1527252336088},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1527252336090},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1527252336090},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1527252336090},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1527252336089},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1527252336090},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1527252336091},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1527252336092},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1527252336092},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1527252336092},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1527252336093},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1527252336093},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1527252336093},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1527252336093},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1527252336094},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1527252336094},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1527252336094},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1527252336094},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1527252336100},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1527252336100},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1527252336102},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1527252336122},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1527252336122},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1527252336123},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1527252336123},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1527252336124},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1527252336135},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1527252336135},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1527252336135},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1527252336135},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1527252336136},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1527252336136},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1527252336144},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1527252336159},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1527252336147},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1527252336157},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1527252336131},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1527252336175},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1527252336152},{"_id":"themes/hexo-theme-next/source/images/touxiang.png","hash":"770a14f49e21642e06d6f032e10870159ecada5b","modified":1530104976109},{"_id":"themes/hexo-theme-next/source/images/me.jpg","hash":"322bdc7ddde1e8cc9345df7a6395be1d6faad52b","modified":1554617761937},{"_id":"public/categories/index.html","hash":"d30691c98d6b884e216621ee45f6dcb47e0a2ebe","modified":1554618137880},{"_id":"public/tags/index.html","hash":"6671d4b564a9bc88c938fe2536c6a87ab7ee39d3","modified":1554618137880},{"_id":"public/categories/生活/index.html","hash":"594b0f307455a30568327392d3024daa62e32809","modified":1554618137881},{"_id":"public/categories/生活/page/2/index.html","hash":"7bd6174c29384913bb4ce3d9e0ec32c7b9bc901e","modified":1554618137881},{"_id":"public/categories/生活/page/3/index.html","hash":"89e5968f65eff03c758daac53bac4a0d93b8e504","modified":1554618137881},{"_id":"public/categories/前端/index.html","hash":"3a184f9389b01fae98ab4ebf5b0f1242f94b11c7","modified":1554618137881},{"_id":"public/categories/前端/page/4/index.html","hash":"543a450e6f9e902dcda9163884962aacb0a8721d","modified":1554618137881},{"_id":"public/categories/前端/underscore/index.html","hash":"acc450da59f9958fafe89aadec7ada12e9e3652a","modified":1554618137881},{"_id":"public/categories/前端/underscore/page/2/index.html","hash":"504a99ecdec2e006f945a9eb049029ed0a00eac5","modified":1554618137881},{"_id":"public/categories/电影/index.html","hash":"ecbb0a1348bab4465d684dc3b2a538403e224b0b","modified":1554618137881},{"_id":"public/categories/前端/TypeScript/index.html","hash":"f822e48023c8aa6a2a9eaa35b47ecc93a69f58b7","modified":1554618137882},{"_id":"public/categories/前端/react/index.html","hash":"a46ad223768dc1aca147e5596ce8675b2ea5dd7a","modified":1554618137882},{"_id":"public/categories/周报/index.html","hash":"dee105d2b1bb4c6450f228469166cae66f8133d9","modified":1554618137882},{"_id":"public/categories/小说/index.html","hash":"4b6e3d81e823db6d236373c60eb0f7f95f137be3","modified":1554618137882},{"_id":"public/categories/理财/index.html","hash":"d0d0219e7ef3ebba88f7519fa30a26893e5f67f8","modified":1554618137882},{"_id":"public/categories/音乐/index.html","hash":"43319d494fc235374305788b787ead9b457a808a","modified":1554618137882},{"_id":"public/categories/函数式编程/index.html","hash":"9cc191bc195e447ee1013d881f3252d2c67089f4","modified":1554618137882},{"_id":"public/archives/page/8/index.html","hash":"13e17dfaf00b9e97128213ddcf505a69b7ede778","modified":1554618137882},{"_id":"public/archives/2015/index.html","hash":"845596044e5d734199116cdfe54c84da94f797ea","modified":1554618137882},{"_id":"public/archives/2015/02/index.html","hash":"4283223035b51b3a9b379d72902fd1db8fd43dcd","modified":1554618137882},{"_id":"public/archives/2015/04/index.html","hash":"ac17d682557249c2dc8cc7813d83e48c9ed066b9","modified":1554618137882},{"_id":"public/archives/2017/index.html","hash":"c1fc6feacd528c2397b518a4540e8c669c36316c","modified":1554618137882},{"_id":"public/archives/2017/07/index.html","hash":"bc64137942141ce550b490edc8d2628142745788","modified":1554618137882},{"_id":"public/archives/2017/09/index.html","hash":"e55b06d66c5df6ad3f58a04677982da2b0489c70","modified":1554618137882},{"_id":"public/archives/2017/10/index.html","hash":"f2cdf60ec921a7b894dde12372744bdb08debea4","modified":1554618137882},{"_id":"public/archives/2018/page/6/index.html","hash":"3ca6fa18e8952c75b07001eb413e5926acd92d48","modified":1554618137882},{"_id":"public/archives/2018/02/index.html","hash":"e386d044c9f4a644fbfa7c4253976c9eb9380f91","modified":1554618137882},{"_id":"public/archives/2018/03/page/2/index.html","hash":"883d653b070b3858c03c175109f391d4dc21cb8d","modified":1554618137882},{"_id":"public/archives/2018/04/index.html","hash":"f6304a80dfcf826662d5ccf5e2ce5645e4e4775b","modified":1554618137883},{"_id":"public/archives/2018/05/index.html","hash":"6eb23fc5c8562264bacfd9b8403a510688635665","modified":1554618137883},{"_id":"public/archives/2018/07/index.html","hash":"d2f661557785de8675e09c5ff82ad353b62e9448","modified":1554618137883},{"_id":"public/archives/2018/10/index.html","hash":"8aea03fb2f3163f37a6917930bd8945ef955cbad","modified":1554618137883},{"_id":"public/archives/2018/11/index.html","hash":"e962b9f495fedb362fc59dd6eecc0e226629d5bc","modified":1554618137883},{"_id":"public/archives/2018/12/index.html","hash":"e09f8abf10e646e86008987f20c2cc0e4c99f18d","modified":1554618137883},{"_id":"public/archives/2019/page/2/index.html","hash":"a8813640e1aec379023c08fb665264838d335c9f","modified":1554618137883},{"_id":"public/archives/2019/01/index.html","hash":"ce9ea0b479c797e5d35f6e696d75a5baa629a1ab","modified":1554618137883},{"_id":"public/archives/2019/03/index.html","hash":"08405c36609e1b675527c18aed45a32c1f904e2b","modified":1554618137883},{"_id":"public/tags/生活/index.html","hash":"8377a5ab17c046298ca5129c599c0b00fba0b882","modified":1554618137883},{"_id":"public/tags/生活/page/2/index.html","hash":"22ce1d9d49067dd2c4e8e1cac79002d78228f692","modified":1554618137883},{"_id":"public/tags/生活/page/3/index.html","hash":"830ade5a1656128f29aa86da8ec4238c76217ed3","modified":1554618137883},{"_id":"public/tags/未来/index.html","hash":"7813f50bc237ef26131dd7768e6166675ad2d277","modified":1554618137883},{"_id":"public/tags/underscore/index.html","hash":"8196a94f01064868ceb23fdc0487e7a8f7659e61","modified":1554618137883},{"_id":"public/tags/underscore/page/2/index.html","hash":"488ae8126b61786283979636cb6283836fb0e6f2","modified":1554618137883},{"_id":"public/tags/前端/index.html","hash":"1bb52ea7c452418c30a2f711f196e1e7d7314768","modified":1554618137883},{"_id":"public/tags/前端/page/2/index.html","hash":"dd0dab742d26de40e47b369dcd32d1fd12b27823","modified":1554618137883},{"_id":"public/tags/前端/page/4/index.html","hash":"8fd6ac81c21ec829833947cf6f76e1507b6b76fc","modified":1554618137884},{"_id":"public/tags/模板引擎/index.html","hash":"9fb2c86c3c8b6a9e728f10fab514a660cb1ee14c","modified":1554618137884},{"_id":"public/tags/TypeScript/index.html","hash":"cf8cc6e99a2880d9bd5e7c1e03110a99e483545f","modified":1554618137884},{"_id":"public/tags/redux/index.html","hash":"ccfaba963e0eddca66a7af0c716c36f13daac8a6","modified":1554618137884},{"_id":"public/tags/react/index.html","hash":"acfe1e28c24dfb03fcbf3c453e4b7af2ef0c1c0b","modified":1554618137884},{"_id":"public/tags/编程/index.html","hash":"3f8bf0a7ee8695e7a8c378c91e550e8820f813f5","modified":1554618137884},{"_id":"public/tags/编程/page/2/index.html","hash":"7358a37e5eab8670bf3d486c19cdea81f22bb37d","modified":1554618137884},{"_id":"public/tags/影评/index.html","hash":"88eda113de76720093049d193ce932b4239b635d","modified":1554618137884},{"_id":"public/tags/观后感/index.html","hash":"69c733a63bd0c407668c6b51274534fc2f9d7d3e","modified":1554618137884},{"_id":"public/tags/个人笔记/index.html","hash":"dba4af2bcc3ed9b7b25f8d8b0cb1158067ade676","modified":1554618137884},{"_id":"public/tags/读书笔记/index.html","hash":"c0e1e9c5bb35871e89947e8c34113374ffdd5f98","modified":1554618137884},{"_id":"public/tags/思考/index.html","hash":"d72988ca109d98fef16062bc61f7fb838e82e1cb","modified":1554618137884},{"_id":"public/tags/思考/page/2/index.html","hash":"50929f7ae2cf0719fbff47994966671843441f20","modified":1554618137884},{"_id":"public/tags/随笔/index.html","hash":"7b86ad2771002fe4fb6c1d3fb5f8422c0596dbb4","modified":1554618137884},{"_id":"public/tags/随笔/page/2/index.html","hash":"209efe38c699dc9995db35b372640b1b193dd653","modified":1554618137885},{"_id":"public/tags/工作/index.html","hash":"f86cf6a357efcce218e78b4bf72630c0c077d827","modified":1554618137885},{"_id":"public/tags/周报/index.html","hash":"39e2a75da1d914562b8c65023f2390bd629b7f4b","modified":1554618137885},{"_id":"public/tags/polyfill/index.html","hash":"e2a419b18359f57db873be9c1baf9b2a7fd32259","modified":1554618137885},{"_id":"public/tags/理财/index.html","hash":"78fd5ce12ce80a82772c345412162e54f524c0ed","modified":1554618137885},{"_id":"public/tags/理想/index.html","hash":"8a5b4c6aff4558e27c6a70ed102e41a4784e6286","modified":1554618137885},{"_id":"public/tags/歌曲/index.html","hash":"e1d4557e2b2a9b6bf11a09f6afced9e056fa9901","modified":1554618137885},{"_id":"public/tags/电影/index.html","hash":"13240d2e66311dcdfb4eeb629e3b8bcca8f4b0e6","modified":1554618137885},{"_id":"public/tags/陈升/index.html","hash":"baff7800f0245913ae3521c100af8fda3d5f1061","modified":1554618137885},{"_id":"public/tags/说话技巧/index.html","hash":"3afc5e75478597bccfa1b0d921936123746db5a0","modified":1554618137885},{"_id":"public/tags/函数式编程/index.html","hash":"e042adb7082e8a48f7e027f99e8bea44bfbf0e05","modified":1554618137885},{"_id":"public/tags/javascript/index.html","hash":"240d79bde35805903ff86932fa2b22d9eff058a0","modified":1554618137885},{"_id":"public/tags/毕业/index.html","hash":"3faadf93979911ea2178b5a28495cda724490e6f","modified":1554618137885},{"_id":"public/about/index.html","hash":"bf52ac41fd03e095e68c50a935057dac8ec25e11","modified":1554618137885},{"_id":"public/2019/03/27/如何写好前端业务代码？/index.html","hash":"a7cc85aa34680d42a70183184bb4027908b30926","modified":1554618137885},{"_id":"public/2019/03/15/记一次社招面试（二）/index.html","hash":"21eca5fe9014a8c0ab13f5b4749f7bab1e044699","modified":1554618137886},{"_id":"public/2019/03/14/再见，携程/index.html","hash":"548ba19cf0c753e288eb93a32156e4c51b5c44e9","modified":1554618137886},{"_id":"public/2019/03/13/记一次社招面试/index.html","hash":"cb85dff19b3cd7f76013de7d3a89a12cfeda44b5","modified":1554618137886},{"_id":"public/2019/01/20/优化代码中的条件判断/index.html","hash":"07a61845eb5e9d9ce17b96d25b0cbcb02d2b0a1a","modified":1554618137886},{"_id":"public/2019/01/01/2019展望/index.html","hash":"d15e398271338c9697b962d56861b2a04ef769e6","modified":1554618137886},{"_id":"public/2018/12/21/周报（2018-12-21）/index.html","hash":"a5b380859e37b556382cf5aebf40dff5ff5ac372","modified":1554618137886},{"_id":"public/2018/12/15/周报（2018-12-14）/index.html","hash":"b5150efc9b3b47a30efd8395b0c584e7f2378d57","modified":1554618137886},{"_id":"public/2018/12/09/就算世界无童话/index.html","hash":"14a09e1d94da5e5441e8ee5a032180eb5f5141fa","modified":1554618137886},{"_id":"public/2018/12/07/周报（2018-12-07）/index.html","hash":"bad9ec7f752c94057a806ec4de96a3173bd007ee","modified":1554618137886},{"_id":"public/2018/11/25/深入理解react/index.html","hash":"97162cbd02fe54ee038059b69845dd9cab23397d","modified":1554618137886},{"_id":"public/2018/11/22/TypeScript踩坑（持续更新）/index.html","hash":"f925037540757e3b9e5c2ff4beeffab2d284857b","modified":1554618137886},{"_id":"public/2018/10/14/塞尔达传说/index.html","hash":"9c080e3cc75d5ffc9a517ca6e2a6a31684b8ff22","modified":1554618137886},{"_id":"public/2018/10/05/react状态管理/index.html","hash":"1814f867b8333ddcb129b9787cfb55bce4b57e45","modified":1554618137886},{"_id":"public/2018/07/25/redux源码分析/index.html","hash":"e58206988960d78422a22854181172025df98ca6","modified":1554618137887},{"_id":"public/2018/07/15/管理自己/index.html","hash":"5745aa31b3f7a62ec0803f06a5b434b0a000cd2d","modified":1554618137887},{"_id":"public/2018/07/07/《编写可维护的JS》笔记/index.html","hash":"f02a2091f869f65cdb155cfd0a1f97c5cf3e53de","modified":1554618137887},{"_id":"public/2018/05/30/实现一个bind函数/index.html","hash":"7e91d68acc71df17d2ee3b75512167ade3429b55","modified":1554618137887},{"_id":"public/2018/05/09/JS函数柯里化/index.html","hash":"e620f5769c7ac7ff298d6a1d6c59253773563890","modified":1554618137887},{"_id":"public/2018/04/27/世界变了样/index.html","hash":"c6a54e79a8152e4726727ed244c3cae666e915b0","modified":1554618137887},{"_id":"public/2018/04/24/60行代码实现模板引擎/index.html","hash":"23e6f46ac6edb09c4b2f43c3633a442031452148","modified":1554618137887},{"_id":"public/2018/04/19/富爸爸穷爸爸/index.html","hash":"5e50c720c24ad62caa7826b45f0e9ede71ad9df0","modified":1554618137887},{"_id":"public/2018/04/18/牡丹亭外/index.html","hash":"a352e43ecb63d96e4cf08cad41863f603b194ad2","modified":1554618137887},{"_id":"public/2018/03/25/underscore查找索引函数分析/index.html","hash":"6c98f70c13b92d9be2b6ea7f9b20a15cfd6e6675","modified":1554618137887},{"_id":"public/2018/03/23/underscore debounce防抖动函数分析/index.html","hash":"cc2fd3e7fd2b810544c1ac567d06ba74ad4a6c74","modified":1554618137888},{"_id":"public/2018/03/22/underscore throttle节流函数分析/index.html","hash":"fadeac02592a618beb5395c7a401adb907062c44","modified":1554618137888},{"_id":"public/2018/03/20/underscore源码剖析之数组遍历函数分析（二）/index.html","hash":"f26a96b0c24ad297814e1d4514a220973d6fd5ce","modified":1554618137888},{"_id":"public/2018/03/19/深夜思考/index.html","hash":"da9a28f2e990b20a6cdb7ec17d5e1a1c68d5aef4","modified":1554618137888},{"_id":"public/2018/03/19/underscore源码剖析之数组遍历函数分析（一）/index.html","hash":"f2c66240764dde23e48669003b1ee8b127079453","modified":1554618137888},{"_id":"public/2018/03/17/underscore源码剖析之基础方法/index.html","hash":"3f24c8ad162b87de16c5a6f09553041ed6697efa","modified":1554618137888},{"_id":"public/2018/03/16/underscore源码剖析之整体架构/index.html","hash":"ee306231c5ed15cf8eb20ccbc7f6eb02de307121","modified":1554618137888},{"_id":"public/2018/03/10/流光飞舞/index.html","hash":"ca3549c0eb7d43ddecc33e3e4c2952b302ccfc75","modified":1554618137888},{"_id":"public/2018/02/21/《守望者》观后感/index.html","hash":"9bc340d9762232029093b6db17c228c4305c92d4","modified":1554618137888},{"_id":"public/2017/10/04/蔡康永的说话之道/index.html","hash":"f9776e2098d51fafff40e2a5d2dd5e677586c240","modified":1554618137888},{"_id":"public/2017/09/21/校招的一些感受/index.html","hash":"b00b78e3c4dfe7d4d7123f1aaa3baae9eb8c0f2d","modified":1554618137888},{"_id":"public/2017/07/01/毕业二三事/index.html","hash":"ddddffff9e8fce1303eb95009a00b04c0a31f01f","modified":1554618137888},{"_id":"public/2015/04/19/梦境小说/index.html","hash":"ed3654c9fb4cc7b4e9469e0242532105e0a824eb","modified":1554618137889},{"_id":"public/2015/02/25/为什么活着/index.html","hash":"f31e93ff59369157c392de5af4659dd85ba00c23","modified":1554618137889},{"_id":"public/categories/前端/page/2/index.html","hash":"3895f068edffc82237ce345d56a837b2700dd2e0","modified":1554618137889},{"_id":"public/categories/前端/page/3/index.html","hash":"ff60f2e9fb59fdeaa8e6b3dbc5ac12fdddea106e","modified":1554618137889},{"_id":"public/archives/index.html","hash":"dddca3ca7c5b20a6cee7442c68022e24e3a104bf","modified":1554618137889},{"_id":"public/archives/page/2/index.html","hash":"c8278f8c3ade30f0d8e82aa66220ce690d3387eb","modified":1554618137889},{"_id":"public/archives/page/3/index.html","hash":"21b711588a0271ee747f3bf17ec74d455c6530fb","modified":1554618137890},{"_id":"public/archives/page/4/index.html","hash":"b6679042accce7ffd91abdd982a6f6fc5cdd28d8","modified":1554618137890},{"_id":"public/archives/page/5/index.html","hash":"ad4042136d819ae97706b7e7f410e85179bc8e81","modified":1554618137890},{"_id":"public/archives/page/6/index.html","hash":"25b7b9fcd13fc284c24c072d4a0d5f7731bd866b","modified":1554618137890},{"_id":"public/archives/page/7/index.html","hash":"e82c691de9493e9ac244ec25a30072f650bf7963","modified":1554618137890},{"_id":"public/archives/2018/index.html","hash":"4d37141948255c6b2020e87cd00b2dd3ea58f115","modified":1554618137891},{"_id":"public/archives/2018/page/3/index.html","hash":"95844ce32801c1e7c1b7893f93c41cb7454c6944","modified":1554618137891},{"_id":"public/archives/2018/page/2/index.html","hash":"520be7b34fc23f69cf714737e83fca01bdef32dc","modified":1554618137891},{"_id":"public/archives/2018/page/4/index.html","hash":"213ee3d78738388ffc97e1a64586f622c2483fa5","modified":1554618137891},{"_id":"public/archives/2018/page/5/index.html","hash":"6c60a914a1ebb4215d8c2e53c95c2b95142e441d","modified":1554618137891},{"_id":"public/archives/2018/03/index.html","hash":"55214fe6f273e01f3a461d0e10264ef51bd06d35","modified":1554618137891},{"_id":"public/archives/2019/index.html","hash":"9f0d2e5387b9242c8760812cc0c0a164178cdab3","modified":1554618137891},{"_id":"public/index.html","hash":"5fe0bbe692a023f3d69e111d363c34aeff66314c","modified":1554618137891},{"_id":"public/page/2/index.html","hash":"33650a93a639fe7a633231fd2fb86e0c44d9f4b5","modified":1554618137891},{"_id":"public/page/3/index.html","hash":"7dc9c342d33de2ce33184648870e214c42430b7c","modified":1554618137891},{"_id":"public/page/4/index.html","hash":"b7df152f6091099fa933db7caaaa7101068284d8","modified":1554618137891},{"_id":"public/page/5/index.html","hash":"b1a783480ce71831217acae888e8a7499977723e","modified":1554618137891},{"_id":"public/page/6/index.html","hash":"5439b17634f5b80dffbbbd8310dbd58a969f2374","modified":1554618137891},{"_id":"public/page/7/index.html","hash":"95964b1058f95b1a9bb500bb1908c044f895eeba","modified":1554618137891},{"_id":"public/page/8/index.html","hash":"98e84776e8dacfaa6e43852434a2376201684706","modified":1554618137892},{"_id":"public/tags/前端/page/3/index.html","hash":"a86bf829d77c1f69a914c40d8cf1e7e7491429ca","modified":1554618137892},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1554618137903},{"_id":"public/CNAME","hash":"c9e531ba4730789adf382049ec17de18a3756492","modified":1554618137903},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1554618137904},{"_id":"public/images/ETH.png","hash":"a7c437c9c0037cd178025f638e51f72ca7e0abe9","modified":1554618137904},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1554618137904},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1554618137904},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1554618137904},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1554618137904},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1554618137904},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1554618137904},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1554618137904},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1554618137904},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554618137904},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1554618137904},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1554618137904},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1554618137904},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1554618137904},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1554618137904},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554618137904},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1554618137904},{"_id":"public/images/xiong.jpg","hash":"9c3b2868bb9ec01e05ea334ec8f55cb377ea1027","modified":1554618137904},{"_id":"public/images/zhihu.svg","hash":"101faa76d8f77456663522b2a2585b853f7b76c1","modified":1554618137904},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1554618137904},{"_id":"public/images/wechatpay.png","hash":"7d901488caf7480a49f24de97e8a18ec607b94db","modified":1554618137904},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1554618137905},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1554618137905},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1554618137905},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1554618137905},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1554618137905},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1554618137905},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1554618137905},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1554618137905},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1554618137905},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1554618137905},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1554618137905},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1554618137905},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1554618137906},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1554618137906},{"_id":"public/images/alipay.jpg","hash":"5eb0ecf461d58f9aa862b7d42a9106ec9ea771f4","modified":1554618138831},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1554618138836},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1554618138852},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1554618138852},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1554618138857},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1554618138857},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1554618138857},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1554618138857},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1554618138857},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1554618138857},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1554618138857},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1554618138858},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1554618138858},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1554618138858},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1554618138858},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1554618138858},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1554618138858},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1554618138858},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1554618138858},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1554618138859},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1554618138859},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1554618138860},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1554618138862},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1554618138862},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1554618138862},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1554618138863},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1554618138863},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1554618138863},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1554618138863},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1554618138863},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1554618138863},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1554618138863},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1554618138864},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1554618138864},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1554618138864},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1554618138865},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1554618138865},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1554618138865},{"_id":"public/css/main.css","hash":"ab827cad09befcc279e75902efd6f2a5cbb8dd80","modified":1554618138866},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1554618138866},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1554618138866},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1554618138866},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1554618138866},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1554618139003},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1554618139003},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1554618139004},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1554618139004},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1554618139004},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1554618139005},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1554618139005},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1554618139005},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1554618139035},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1554618139035},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"24402d749b152b9a65cf13c92b0a0eaa2c4d6021","modified":1554618139112},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1554618139113},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1554618139195},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1554618139195},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1554618139200},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1554618139203},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1554618139203},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"ec0f0f7b0cbf892e973aeafee87e6ba1e6a7c86b","modified":1554618139204},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1554618139204},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1554618139270},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1554618139270},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1554618139272},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1554618139309},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1554618139329},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1554618139336},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1554618139375},{"_id":"public/images/touxiang.png","hash":"770a14f49e21642e06d6f032e10870159ecada5b","modified":1554618139386},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1554618139404},{"_id":"public/images/me.jpg","hash":"322bdc7ddde1e8cc9345df7a6395be1d6faad52b","modified":1554618139404},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1554618139472},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1554618139483}],"Category":[{"name":"生活","_id":"cju6jhrsg0004drfdq0st1ktn"},{"name":"前端","_id":"cju6jhrso000adrfdkpqw9tql"},{"name":"underscore","parent":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrt8000vdrfd10d5mjrq"},{"name":"电影","_id":"cju6jhrti001edrfdm66taoaw"},{"name":"TypeScript","parent":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrtm001mdrfdjrp33tds"},{"name":"react","parent":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrtr001udrfdiippxrj5"},{"name":"周报","_id":"cju6jhrtw0022drfdhyw6tals"},{"name":"小说","_id":"cju6jhru2002idrfdi04putpj"},{"name":"理财","_id":"cju6jhru6002tdrfdcswwyti5"},{"name":"音乐","_id":"cju6jhrub0034drfdat3bn129"},{"name":"函数式编程","_id":"cju6jhs5o005xdrfdsza47hiq"}],"Data":[],"Page":[{"title":"关于我","date":"2018-04-18T11:21:24.000Z","_content":"## 学生生涯 ##\n2013年9月，我进入武汉大学就读。\n在大学期间，我经历了很多起起伏伏，对人生有了重新的思考，对未来也有了明确的规划。\n2017年7月，我从武汉大学毕业。\n整整17年的学生生涯结束了，学生时代我学到了很多宝贵的知识，从基本的常识，到晦涩的专业知识。我也从一个懵懂的孩子变成了一个独立的成年人。\n## 工作 ##\n大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员。我是标准宅男，16年入前端坑，热爱技术，热爱写博客，现在还处于初级前端级别。\n2017年毕业后，我加入了携程度假研发部，在无线预订组做自由行相关的业务。在这段时间里，我认识了很多小伙伴，并且从他们身上学到了很多技术、工作和生活方面的东西。\n## 生活 ##\n我对于生活的认知就是吃吃吃，吃比一切都要重要，我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，保持一颗热爱生活的心。\n一个人生活了太久，有点内向，有时候不太合群，但还是希望能多接触到不同的人和外面的世界，希望未来能当一个作家和前端架构师，现在为了这个目标正努力奋斗。\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-04-18 19:21:24\n---\n## 学生生涯 ##\n2013年9月，我进入武汉大学就读。\n在大学期间，我经历了很多起起伏伏，对人生有了重新的思考，对未来也有了明确的规划。\n2017年7月，我从武汉大学毕业。\n整整17年的学生生涯结束了，学生时代我学到了很多宝贵的知识，从基本的常识，到晦涩的专业知识。我也从一个懵懂的孩子变成了一个独立的成年人。\n## 工作 ##\n大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员。我是标准宅男，16年入前端坑，热爱技术，热爱写博客，现在还处于初级前端级别。\n2017年毕业后，我加入了携程度假研发部，在无线预订组做自由行相关的业务。在这段时间里，我认识了很多小伙伴，并且从他们身上学到了很多技术、工作和生活方面的东西。\n## 生活 ##\n我对于生活的认知就是吃吃吃，吃比一切都要重要，我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，保持一颗热爱生活的心。\n一个人生活了太久，有点内向，有时候不太合群，但还是希望能多接触到不同的人和外面的世界，希望未来能当一个作家和前端架构师，现在为了这个目标正努力奋斗。\n\n","updated":"2019-03-27T15:23:06.415Z","path":"about/index.html","comments":1,"layout":"page","_id":"cju6jhrsb0001drfd499cxyui","content":"<h2 id=\"学生生涯\"><a href=\"#学生生涯\" class=\"headerlink\" title=\"学生生涯\"></a>学生生涯</h2><p>2013年9月，我进入武汉大学就读。<br>在大学期间，我经历了很多起起伏伏，对人生有了重新的思考，对未来也有了明确的规划。<br>2017年7月，我从武汉大学毕业。<br>整整17年的学生生涯结束了，学生时代我学到了很多宝贵的知识，从基本的常识，到晦涩的专业知识。我也从一个懵懂的孩子变成了一个独立的成年人。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员。我是标准宅男，16年入前端坑，热爱技术，热爱写博客，现在还处于初级前端级别。<br>2017年毕业后，我加入了携程度假研发部，在无线预订组做自由行相关的业务。在这段时间里，我认识了很多小伙伴，并且从他们身上学到了很多技术、工作和生活方面的东西。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>我对于生活的认知就是吃吃吃，吃比一切都要重要，我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，保持一颗热爱生活的心。<br>一个人生活了太久，有点内向，有时候不太合群，但还是希望能多接触到不同的人和外面的世界，希望未来能当一个作家和前端架构师，现在为了这个目标正努力奋斗。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学生生涯\"><a href=\"#学生生涯\" class=\"headerlink\" title=\"学生生涯\"></a>学生生涯</h2><p>2013年9月，我进入武汉大学就读。<br>在大学期间，我经历了很多起起伏伏，对人生有了重新的思考，对未来也有了明确的规划。<br>2017年7月，我从武汉大学毕业。<br>整整17年的学生生涯结束了，学生时代我学到了很多宝贵的知识，从基本的常识，到晦涩的专业知识。我也从一个懵懂的孩子变成了一个独立的成年人。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员。我是标准宅男，16年入前端坑，热爱技术，热爱写博客，现在还处于初级前端级别。<br>2017年毕业后，我加入了携程度假研发部，在无线预订组做自由行相关的业务。在这段时间里，我认识了很多小伙伴，并且从他们身上学到了很多技术、工作和生活方面的东西。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>我对于生活的认知就是吃吃吃，吃比一切都要重要，我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，保持一颗热爱生活的心。<br>一个人生活了太久，有点内向，有时候不太合群，但还是希望能多接触到不同的人和外面的世界，希望未来能当一个作家和前端架构师，现在为了这个目标正努力奋斗。</p>\n"},{"title":"categories","date":"2018-04-18T11:21:33.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-18 19:21:33\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-05-25T12:45:36.039Z","path":"categories/index.html","layout":"page","_id":"cju6jhrsf0003drfdq7g7jqda","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-04-18T11:21:16.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-18 19:21:16\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-05-25T12:45:36.039Z","path":"tags/index.html","layout":"page","_id":"cju6jhrsk0007drfd9f8t40wp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2019展望","date":"2019-01-01T07:43:18.000Z","_content":"2018年过得浑浑噩噩，在舒适区呆了一整年，没什么值得总结的，还是希望在新的一年能够做得更好吧。\n## 技术\n对我来说，工作也是提高技术的一部分，所以这两个放到一块说。\n技术上，在2018年进步不小，但技术栈依然局限在react上，对服务端和http懂得依然很少。所以在2018年，我的主要精力会放到nodejs和webpack、http上面，技术栈慢慢往全栈上面转。\n学习之余，希望自己能够参与一些开源项目，或者自己搞一个开源项目，不管是UI组件库还是工具库都可以。\n\n工作上自然没啥好说的啦~希望能够保持对工作的热情，做自己喜欢做的事情，希望能够升职加薪，毕竟现在已经被一起毕业的同学甩在身后了。\n<!--more-->\n## 生活\n### 厨艺\n还记得去年年底回家的时候，我信心满满地要给大家做个大盘鸡，结果最后失败的非常尴尬哈哈哈。\n18年在厨艺上面有了很显著的进步，对鸡精、盐、糖、五香粉等调味剂有了进一步的认识，但是味道和卖相还是达不到餐馆里面的水平，希望今年在厨艺上面有进一步的突破。\n### 健康\n临近年末，天气越来越冷，胃痛也越来越多，希望明年能多注意一下饮食，保持好的健康，不想再被病痛折磨了。\n关于健身，不做强制要求了，只希望自己能够自觉的保持锻炼的习惯，稍微把体重减下去一些，不想当个小胖子了。\n### 写作\n最近一个月天天加班，身心俱惫，也让我不得不中断学习和阅读。\n在19年要继续看一些写作方面的书，多看一些散文和小说，争取能写出几篇短篇小说来。培养写作的爱好，为以后的人生增加更多地选择。\n## 理财\n17年看过《富爸爸穷爸爸》后就没有看过关于理财方面的书了。18年炒虚拟货币损失惨重，亏了3w左右吧，我也一直不敢和父母说这个，毕竟这也是我交的学费。\n这个社会是非常真实的，没有钱什么都做不成。所以19年除了学习，最重要的就是赚钱赚钱赚钱，一方面希望我能和艾老师、叶佳他们取取经，学习一下流量变现，另一方面就是控制支出，多攒一些前期的资本。\n## 书籍\n虽说不应该给自己立flag，但还是要有个小目标。\n### 技术\n\n 1. 图解http\n 2. 计算机网络：自顶向下方法\n 3. 大话数据结构\n 4. 剑指offer\n 5. js设计模式与实践\n 6. 代码大全2\n\n### 散文和小说\n \n 1. 给青年的二十七堂文学课\n 2. 文心\n 3. 文章自在\n 4. 文章例话\n 5. 完全写作指南\n 6. 朱自清散文集\n 7. 梁实秋散文集\n 8. 沈从文散文\n 9. 月亮与六便士\n\n### 理财\n \n 1. 富爸爸财务自由之路\n 2. 财务自由之路\n 3. 门口的野蛮人\n 4. 区块链：从数字货币到信用社会","source":"_posts/2019展望.md","raw":"---\ntitle: 2019展望\ndate: 2019-01-01 15:43:18\ntags:\n    - 生活\n    - 未来\ncategories:\n    - 生活\n---\n2018年过得浑浑噩噩，在舒适区呆了一整年，没什么值得总结的，还是希望在新的一年能够做得更好吧。\n## 技术\n对我来说，工作也是提高技术的一部分，所以这两个放到一块说。\n技术上，在2018年进步不小，但技术栈依然局限在react上，对服务端和http懂得依然很少。所以在2018年，我的主要精力会放到nodejs和webpack、http上面，技术栈慢慢往全栈上面转。\n学习之余，希望自己能够参与一些开源项目，或者自己搞一个开源项目，不管是UI组件库还是工具库都可以。\n\n工作上自然没啥好说的啦~希望能够保持对工作的热情，做自己喜欢做的事情，希望能够升职加薪，毕竟现在已经被一起毕业的同学甩在身后了。\n<!--more-->\n## 生活\n### 厨艺\n还记得去年年底回家的时候，我信心满满地要给大家做个大盘鸡，结果最后失败的非常尴尬哈哈哈。\n18年在厨艺上面有了很显著的进步，对鸡精、盐、糖、五香粉等调味剂有了进一步的认识，但是味道和卖相还是达不到餐馆里面的水平，希望今年在厨艺上面有进一步的突破。\n### 健康\n临近年末，天气越来越冷，胃痛也越来越多，希望明年能多注意一下饮食，保持好的健康，不想再被病痛折磨了。\n关于健身，不做强制要求了，只希望自己能够自觉的保持锻炼的习惯，稍微把体重减下去一些，不想当个小胖子了。\n### 写作\n最近一个月天天加班，身心俱惫，也让我不得不中断学习和阅读。\n在19年要继续看一些写作方面的书，多看一些散文和小说，争取能写出几篇短篇小说来。培养写作的爱好，为以后的人生增加更多地选择。\n## 理财\n17年看过《富爸爸穷爸爸》后就没有看过关于理财方面的书了。18年炒虚拟货币损失惨重，亏了3w左右吧，我也一直不敢和父母说这个，毕竟这也是我交的学费。\n这个社会是非常真实的，没有钱什么都做不成。所以19年除了学习，最重要的就是赚钱赚钱赚钱，一方面希望我能和艾老师、叶佳他们取取经，学习一下流量变现，另一方面就是控制支出，多攒一些前期的资本。\n## 书籍\n虽说不应该给自己立flag，但还是要有个小目标。\n### 技术\n\n 1. 图解http\n 2. 计算机网络：自顶向下方法\n 3. 大话数据结构\n 4. 剑指offer\n 5. js设计模式与实践\n 6. 代码大全2\n\n### 散文和小说\n \n 1. 给青年的二十七堂文学课\n 2. 文心\n 3. 文章自在\n 4. 文章例话\n 5. 完全写作指南\n 6. 朱自清散文集\n 7. 梁实秋散文集\n 8. 沈从文散文\n 9. 月亮与六便士\n\n### 理财\n \n 1. 富爸爸财务自由之路\n 2. 财务自由之路\n 3. 门口的野蛮人\n 4. 区块链：从数字货币到信用社会","slug":"2019展望","published":1,"updated":"2019-04-07T05:53:12.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrs30000drfdtje771y1","content":"<p>2018年过得浑浑噩噩，在舒适区呆了一整年，没什么值得总结的，还是希望在新的一年能够做得更好吧。</p>\n<h2 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h2><p>对我来说，工作也是提高技术的一部分，所以这两个放到一块说。<br>技术上，在2018年进步不小，但技术栈依然局限在react上，对服务端和http懂得依然很少。所以在2018年，我的主要精力会放到nodejs和webpack、http上面，技术栈慢慢往全栈上面转。<br>学习之余，希望自己能够参与一些开源项目，或者自己搞一个开源项目，不管是UI组件库还是工具库都可以。</p>\n<p>工作上自然没啥好说的啦~希望能够保持对工作的热情，做自己喜欢做的事情，希望能够升职加薪，毕竟现在已经被一起毕业的同学甩在身后了。<br><a id=\"more\"></a></p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><h3 id=\"厨艺\"><a href=\"#厨艺\" class=\"headerlink\" title=\"厨艺\"></a>厨艺</h3><p>还记得去年年底回家的时候，我信心满满地要给大家做个大盘鸡，结果最后失败的非常尴尬哈哈哈。<br>18年在厨艺上面有了很显著的进步，对鸡精、盐、糖、五香粉等调味剂有了进一步的认识，但是味道和卖相还是达不到餐馆里面的水平，希望今年在厨艺上面有进一步的突破。</p>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><p>临近年末，天气越来越冷，胃痛也越来越多，希望明年能多注意一下饮食，保持好的健康，不想再被病痛折磨了。<br>关于健身，不做强制要求了，只希望自己能够自觉的保持锻炼的习惯，稍微把体重减下去一些，不想当个小胖子了。</p>\n<h3 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h3><p>最近一个月天天加班，身心俱惫，也让我不得不中断学习和阅读。<br>在19年要继续看一些写作方面的书，多看一些散文和小说，争取能写出几篇短篇小说来。培养写作的爱好，为以后的人生增加更多地选择。</p>\n<h2 id=\"理财\"><a href=\"#理财\" class=\"headerlink\" title=\"理财\"></a>理财</h2><p>17年看过《富爸爸穷爸爸》后就没有看过关于理财方面的书了。18年炒虚拟货币损失惨重，亏了3w左右吧，我也一直不敢和父母说这个，毕竟这也是我交的学费。<br>这个社会是非常真实的，没有钱什么都做不成。所以19年除了学习，最重要的就是赚钱赚钱赚钱，一方面希望我能和艾老师、叶佳他们取取经，学习一下流量变现，另一方面就是控制支出，多攒一些前期的资本。</p>\n<h2 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h2><p>虽说不应该给自己立flag，但还是要有个小目标。</p>\n<h3 id=\"技术-1\"><a href=\"#技术-1\" class=\"headerlink\" title=\"技术\"></a>技术</h3><ol>\n<li>图解http</li>\n<li>计算机网络：自顶向下方法</li>\n<li>大话数据结构</li>\n<li>剑指offer</li>\n<li>js设计模式与实践</li>\n<li>代码大全2</li>\n</ol>\n<h3 id=\"散文和小说\"><a href=\"#散文和小说\" class=\"headerlink\" title=\"散文和小说\"></a>散文和小说</h3><ol>\n<li>给青年的二十七堂文学课</li>\n<li>文心</li>\n<li>文章自在</li>\n<li>文章例话</li>\n<li>完全写作指南</li>\n<li>朱自清散文集</li>\n<li>梁实秋散文集</li>\n<li>沈从文散文</li>\n<li>月亮与六便士</li>\n</ol>\n<h3 id=\"理财-1\"><a href=\"#理财-1\" class=\"headerlink\" title=\"理财\"></a>理财</h3><ol>\n<li>富爸爸财务自由之路</li>\n<li>财务自由之路</li>\n<li>门口的野蛮人</li>\n<li>区块链：从数字货币到信用社会</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>2018年过得浑浑噩噩，在舒适区呆了一整年，没什么值得总结的，还是希望在新的一年能够做得更好吧。</p>\n<h2 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h2><p>对我来说，工作也是提高技术的一部分，所以这两个放到一块说。<br>技术上，在2018年进步不小，但技术栈依然局限在react上，对服务端和http懂得依然很少。所以在2018年，我的主要精力会放到nodejs和webpack、http上面，技术栈慢慢往全栈上面转。<br>学习之余，希望自己能够参与一些开源项目，或者自己搞一个开源项目，不管是UI组件库还是工具库都可以。</p>\n<p>工作上自然没啥好说的啦~希望能够保持对工作的热情，做自己喜欢做的事情，希望能够升职加薪，毕竟现在已经被一起毕业的同学甩在身后了。<br>","more":"</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><h3 id=\"厨艺\"><a href=\"#厨艺\" class=\"headerlink\" title=\"厨艺\"></a>厨艺</h3><p>还记得去年年底回家的时候，我信心满满地要给大家做个大盘鸡，结果最后失败的非常尴尬哈哈哈。<br>18年在厨艺上面有了很显著的进步，对鸡精、盐、糖、五香粉等调味剂有了进一步的认识，但是味道和卖相还是达不到餐馆里面的水平，希望今年在厨艺上面有进一步的突破。</p>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><p>临近年末，天气越来越冷，胃痛也越来越多，希望明年能多注意一下饮食，保持好的健康，不想再被病痛折磨了。<br>关于健身，不做强制要求了，只希望自己能够自觉的保持锻炼的习惯，稍微把体重减下去一些，不想当个小胖子了。</p>\n<h3 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h3><p>最近一个月天天加班，身心俱惫，也让我不得不中断学习和阅读。<br>在19年要继续看一些写作方面的书，多看一些散文和小说，争取能写出几篇短篇小说来。培养写作的爱好，为以后的人生增加更多地选择。</p>\n<h2 id=\"理财\"><a href=\"#理财\" class=\"headerlink\" title=\"理财\"></a>理财</h2><p>17年看过《富爸爸穷爸爸》后就没有看过关于理财方面的书了。18年炒虚拟货币损失惨重，亏了3w左右吧，我也一直不敢和父母说这个，毕竟这也是我交的学费。<br>这个社会是非常真实的，没有钱什么都做不成。所以19年除了学习，最重要的就是赚钱赚钱赚钱，一方面希望我能和艾老师、叶佳他们取取经，学习一下流量变现，另一方面就是控制支出，多攒一些前期的资本。</p>\n<h2 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h2><p>虽说不应该给自己立flag，但还是要有个小目标。</p>\n<h3 id=\"技术-1\"><a href=\"#技术-1\" class=\"headerlink\" title=\"技术\"></a>技术</h3><ol>\n<li>图解http</li>\n<li>计算机网络：自顶向下方法</li>\n<li>大话数据结构</li>\n<li>剑指offer</li>\n<li>js设计模式与实践</li>\n<li>代码大全2</li>\n</ol>\n<h3 id=\"散文和小说\"><a href=\"#散文和小说\" class=\"headerlink\" title=\"散文和小说\"></a>散文和小说</h3><ol>\n<li>给青年的二十七堂文学课</li>\n<li>文心</li>\n<li>文章自在</li>\n<li>文章例话</li>\n<li>完全写作指南</li>\n<li>朱自清散文集</li>\n<li>梁实秋散文集</li>\n<li>沈从文散文</li>\n<li>月亮与六便士</li>\n</ol>\n<h3 id=\"理财-1\"><a href=\"#理财-1\" class=\"headerlink\" title=\"理财\"></a>理财</h3><ol>\n<li>富爸爸财务自由之路</li>\n<li>财务自由之路</li>\n<li>门口的野蛮人</li>\n<li>区块链：从数字货币到信用社会</li>\n</ol>"},{"title":"60行代码实现模板引擎","date":"2018-04-24T02:35:40.000Z","_content":"不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：[只有20行的Javascript模板引擎][1]\n这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。\n但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。\n恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。\n这个是我参考template后实现的模板，一共只有60行代码。\n<!-- more -->\n```\n(function () {\n    var root = this;\n    // 将字符串中的HTML实体字符转义，可以有效减少xss风险\n    var html2Entity = (function () {\n        var escapeMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '`': '&#x60;'\n        };\n        var escaper = function (match) {\n            return escapeMap[match];\n        };\n        return function (string) {\n            var source = \"(\" + Object.keys(escapeMap).join(\"|\") + \")\";\n            var regexp = RegExp(source), regexpAll = RegExp(source, \"g\");\n            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;\n        }\n    }())\n    // 字符串中的转义字符\n    var escapes = {\n        '\"': '\"',\n        \"'\": \"'\",\n        \"\\\\\": \"\\\\\",\n        '\\n': 'n',\n        '\\r': 'r',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    }\n    var escaper = /\\\\|'|\"|\\r|\\n|\\u2028|\\u2029/g;\n    var convertEscapes = function (match) {\n        return \"\\\\\" + escapes[match];\n    }\n    var template = function (tpl, settings) {\n        // 可以在外部修改template.templateSettings来自定义语法\n        // 一定要保证evaluate在最后，不然会匹配到<%=%>和<%-%>\n        var templateSettings = Object.assign({}, {\n            interpolate: /<%=([\\s\\S]+?)%>/g,\n            escape: /<%-([\\s\\S]+?)%>/g,\n            evaluate: /<%([\\s\\S]+?)%>/g,\n        }, template.templateSettings);\n        settings = Object.assign({}, settings);\n        // /<%=([\\s\\S]+?)%>|<%-([\\s\\S]+?)%>|<%([\\s\\S]+?)%>|$/g\n        // 其中$是为了匹配字符串的最后一个字符\n        var matcher = RegExp(Object.keys(templateSettings).map(function (key) {\n            return templateSettings[key].source\n        }).join(\"|\") + \"|$\", \"g\")\n        var source = \"\", index = 0;\n        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串\n        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) {\n            source += \"__p += '\" + tpl.slice(index, offset).replace(escaper, convertEscapes) + \"'\\n\";\n            index = offset + match.length;\n            if (evaluate) {\n                source += evaluate + \"\\n\"\n            } else if (interpolate) {\n                source += \"__p += (\" + interpolate + \") == null ? '' : \" + interpolate + \";\\n\"\n            } else if (escape) {\n                source += \"__p += (\" + escape + \") == null ? '' : \" + html2Entity(escape) + \";\\n\"\n            }\n            return match;\n        })\n        source = \"var __p = '';\" + source + 'return __p;'\n        // 使用with可以修改作用域\n        if (!settings.variable) source = \"with(obj||{}) {\\n\" + source + \"\\n}\"\n        var render = new Function(settings.variable || \"obj\", source);\n        return render\n    }\n    // 将templateY导出到全局\n    root.templateY = template\n}.call(this))\n```\n## 转义 ##\n我们知道，在字符串中有一些特殊字符是需要转义的，比如\"'\", '\"'，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。\n但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？\n这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：\n```\nvar log = new Function(\"var a = '1\\n23';console.log(a)\");\nlog() // Uncaught SyntaxError: Invalid or unexpected token\n```\n这是因为Function函数在执行的时候，里面的内容被解析成了这样。\n```\nvar a = '1\n23';console.log(a)\n```\n在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。\n## 正则表达式 ##\nunderscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（<%=%>和<%%>）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似\\{\\#\\#\\}的语法了。\n这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/<%=([\\s\\S]+?)%>/g是不会匹配到类似<%=name<%=age%>%>这种语法的，只会匹配到<%=name%>语法。\n## replace ##\n这里我们用到了replace第二个参数是函数的情况。\n```\nvar pattern = /([a-z]+)\\s([a-z]+)/;\nvar str = \"hello world\";\nstr.replace(pattern, function(match, p1, p2, offset) {\n    // p1 is \"hello\"\n    // p2 is \"world\"\n    return match;\n})\n```\n在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是\"hello world\"。\np1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。\n\n## 字符串拼接 ##\nunderscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。\n我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。\n```\nvar arr = [], str = \"\";\nvar i = 0, j = 0\nconsole.time();\nfor(;i<100000;i++) {\n  arr.push(i);\n}\narr.join(\"\");\nconsole.timeEnd()\n\nconsole.time();\nfor(;j<100000;j++) {\n  str+= j\n}\nconsole.timeEnd()\n```\n## setting.variable ##\nunderscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: [Javascript中的with关键字][6]\n你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。\n```\n_.template(\"Using 'with': <%= data.answer %>\", {variable: 'data'})({answer: 'no'});\n```\n\n**参考链接：**\n 1. [js正则进阶][2]\n 2. [JavaScript函数replace揭秘][3]\n 3. [JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾][4]\n 4. [underscore 系列之字符实体与 _.escape][5]\n 5. [Javascript中的with关键字][6]\n 6. [高性能JavaScript模板引擎原理解析][7]\n \n  [1]: https://segmentfault.com/a/1190000005705169\n  [2]: https://segmentfault.com/a/1190000003497780\n  [3]: http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\n  [4]: https://blog.csdn.net/lihefei_coder/article/details/53022253\n  [5]: https://github.com/mqyqingfeng/Blog/issues/77\n  [6]: http://luopq.com/2016/02/14/js-with-keyword/\n  [7]: https://blog.csdn.net/wangjinyu501/article/details/7675599","source":"_posts/60行代码实现模板引擎.md","raw":"---\ntitle: 60行代码实现模板引擎\ndate: 2018-04-24 10:35:40\ntags:\n- underscore\n- 前端\n- 模板引擎\ncategories: [前端, underscore]\n---\n不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：[只有20行的Javascript模板引擎][1]\n这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。\n但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。\n恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。\n这个是我参考template后实现的模板，一共只有60行代码。\n<!-- more -->\n```\n(function () {\n    var root = this;\n    // 将字符串中的HTML实体字符转义，可以有效减少xss风险\n    var html2Entity = (function () {\n        var escapeMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '`': '&#x60;'\n        };\n        var escaper = function (match) {\n            return escapeMap[match];\n        };\n        return function (string) {\n            var source = \"(\" + Object.keys(escapeMap).join(\"|\") + \")\";\n            var regexp = RegExp(source), regexpAll = RegExp(source, \"g\");\n            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;\n        }\n    }())\n    // 字符串中的转义字符\n    var escapes = {\n        '\"': '\"',\n        \"'\": \"'\",\n        \"\\\\\": \"\\\\\",\n        '\\n': 'n',\n        '\\r': 'r',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    }\n    var escaper = /\\\\|'|\"|\\r|\\n|\\u2028|\\u2029/g;\n    var convertEscapes = function (match) {\n        return \"\\\\\" + escapes[match];\n    }\n    var template = function (tpl, settings) {\n        // 可以在外部修改template.templateSettings来自定义语法\n        // 一定要保证evaluate在最后，不然会匹配到<%=%>和<%-%>\n        var templateSettings = Object.assign({}, {\n            interpolate: /<%=([\\s\\S]+?)%>/g,\n            escape: /<%-([\\s\\S]+?)%>/g,\n            evaluate: /<%([\\s\\S]+?)%>/g,\n        }, template.templateSettings);\n        settings = Object.assign({}, settings);\n        // /<%=([\\s\\S]+?)%>|<%-([\\s\\S]+?)%>|<%([\\s\\S]+?)%>|$/g\n        // 其中$是为了匹配字符串的最后一个字符\n        var matcher = RegExp(Object.keys(templateSettings).map(function (key) {\n            return templateSettings[key].source\n        }).join(\"|\") + \"|$\", \"g\")\n        var source = \"\", index = 0;\n        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串\n        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) {\n            source += \"__p += '\" + tpl.slice(index, offset).replace(escaper, convertEscapes) + \"'\\n\";\n            index = offset + match.length;\n            if (evaluate) {\n                source += evaluate + \"\\n\"\n            } else if (interpolate) {\n                source += \"__p += (\" + interpolate + \") == null ? '' : \" + interpolate + \";\\n\"\n            } else if (escape) {\n                source += \"__p += (\" + escape + \") == null ? '' : \" + html2Entity(escape) + \";\\n\"\n            }\n            return match;\n        })\n        source = \"var __p = '';\" + source + 'return __p;'\n        // 使用with可以修改作用域\n        if (!settings.variable) source = \"with(obj||{}) {\\n\" + source + \"\\n}\"\n        var render = new Function(settings.variable || \"obj\", source);\n        return render\n    }\n    // 将templateY导出到全局\n    root.templateY = template\n}.call(this))\n```\n## 转义 ##\n我们知道，在字符串中有一些特殊字符是需要转义的，比如\"'\", '\"'，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。\n但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？\n这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：\n```\nvar log = new Function(\"var a = '1\\n23';console.log(a)\");\nlog() // Uncaught SyntaxError: Invalid or unexpected token\n```\n这是因为Function函数在执行的时候，里面的内容被解析成了这样。\n```\nvar a = '1\n23';console.log(a)\n```\n在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。\n## 正则表达式 ##\nunderscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（<%=%>和<%%>）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似\\{\\#\\#\\}的语法了。\n这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/<%=([\\s\\S]+?)%>/g是不会匹配到类似<%=name<%=age%>%>这种语法的，只会匹配到<%=name%>语法。\n## replace ##\n这里我们用到了replace第二个参数是函数的情况。\n```\nvar pattern = /([a-z]+)\\s([a-z]+)/;\nvar str = \"hello world\";\nstr.replace(pattern, function(match, p1, p2, offset) {\n    // p1 is \"hello\"\n    // p2 is \"world\"\n    return match;\n})\n```\n在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是\"hello world\"。\np1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。\n\n## 字符串拼接 ##\nunderscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。\n我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。\n```\nvar arr = [], str = \"\";\nvar i = 0, j = 0\nconsole.time();\nfor(;i<100000;i++) {\n  arr.push(i);\n}\narr.join(\"\");\nconsole.timeEnd()\n\nconsole.time();\nfor(;j<100000;j++) {\n  str+= j\n}\nconsole.timeEnd()\n```\n## setting.variable ##\nunderscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: [Javascript中的with关键字][6]\n你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。\n```\n_.template(\"Using 'with': <%= data.answer %>\", {variable: 'data'})({answer: 'no'});\n```\n\n**参考链接：**\n 1. [js正则进阶][2]\n 2. [JavaScript函数replace揭秘][3]\n 3. [JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾][4]\n 4. [underscore 系列之字符实体与 _.escape][5]\n 5. [Javascript中的with关键字][6]\n 6. [高性能JavaScript模板引擎原理解析][7]\n \n  [1]: https://segmentfault.com/a/1190000005705169\n  [2]: https://segmentfault.com/a/1190000003497780\n  [3]: http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\n  [4]: https://blog.csdn.net/lihefei_coder/article/details/53022253\n  [5]: https://github.com/mqyqingfeng/Blog/issues/77\n  [6]: http://luopq.com/2016/02/14/js-with-keyword/\n  [7]: https://blog.csdn.net/wangjinyu501/article/details/7675599","slug":"60行代码实现模板引擎","published":1,"updated":"2019-04-07T05:53:12.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsc0002drfd4fq5wlnw","content":"<p>不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：<a href=\"https://segmentfault.com/a/1190000005705169\" target=\"_blank\" rel=\"noopener\">只有20行的Javascript模板引擎</a><br>这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。<br>但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。<br>恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。<br>这个是我参考template后实现的模板，一共只有60行代码。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var root = this;</span><br><span class=\"line\">    // 将字符串中的HTML实体字符转义，可以有效减少xss风险</span><br><span class=\"line\">    var html2Entity = (function () &#123;</span><br><span class=\"line\">        var escapeMap = &#123;</span><br><span class=\"line\">            &apos;&amp;&apos;: &apos;&amp;amp;&apos;,</span><br><span class=\"line\">            &apos;&lt;&apos;: &apos;&amp;lt;&apos;,</span><br><span class=\"line\">            &apos;&gt;&apos;: &apos;&amp;gt;&apos;,</span><br><span class=\"line\">            &apos;&quot;&apos;: &apos;&amp;quot;&apos;,</span><br><span class=\"line\">            &quot;&apos;&quot;: &apos;&amp;#x27;&apos;,</span><br><span class=\"line\">            &apos;`&apos;: &apos;&amp;#x60;&apos;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var escaper = function (match) &#123;</span><br><span class=\"line\">            return escapeMap[match];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return function (string) &#123;</span><br><span class=\"line\">            var source = &quot;(&quot; + Object.keys(escapeMap).join(&quot;|&quot;) + &quot;)&quot;;</span><br><span class=\"line\">            var regexp = RegExp(source), regexpAll = RegExp(source, &quot;g&quot;);</span><br><span class=\"line\">            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    // 字符串中的转义字符</span><br><span class=\"line\">    var escapes = &#123;</span><br><span class=\"line\">        &apos;&quot;&apos;: &apos;&quot;&apos;,</span><br><span class=\"line\">        &quot;&apos;&quot;: &quot;&apos;&quot;,</span><br><span class=\"line\">        &quot;\\\\&quot;: &quot;\\\\&quot;,</span><br><span class=\"line\">        &apos;\\n&apos;: &apos;n&apos;,</span><br><span class=\"line\">        &apos;\\r&apos;: &apos;r&apos;,</span><br><span class=\"line\">        &apos;\\u2028&apos;: &apos;u2028&apos;,</span><br><span class=\"line\">        &apos;\\u2029&apos;: &apos;u2029&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var escaper = /\\\\|&apos;|&quot;|\\r|\\n|\\u2028|\\u2029/g;</span><br><span class=\"line\">    var convertEscapes = function (match) &#123;</span><br><span class=\"line\">        return &quot;\\\\&quot; + escapes[match];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var template = function (tpl, settings) &#123;</span><br><span class=\"line\">        // 可以在外部修改template.templateSettings来自定义语法</span><br><span class=\"line\">        // 一定要保证evaluate在最后，不然会匹配到&lt;%=%&gt;和&lt;%-%&gt;</span><br><span class=\"line\">        var templateSettings = Object.assign(&#123;&#125;, &#123;</span><br><span class=\"line\">            interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            escape: /&lt;%-([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            evaluate: /&lt;%([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">        &#125;, template.templateSettings);</span><br><span class=\"line\">        settings = Object.assign(&#123;&#125;, settings);</span><br><span class=\"line\">        // /&lt;%=([\\s\\S]+?)%&gt;|&lt;%-([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g</span><br><span class=\"line\">        // 其中$是为了匹配字符串的最后一个字符</span><br><span class=\"line\">        var matcher = RegExp(Object.keys(templateSettings).map(function (key) &#123;</span><br><span class=\"line\">            return templateSettings[key].source</span><br><span class=\"line\">        &#125;).join(&quot;|&quot;) + &quot;|$&quot;, &quot;g&quot;)</span><br><span class=\"line\">        var source = &quot;&quot;, index = 0;</span><br><span class=\"line\">        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串</span><br><span class=\"line\">        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) &#123;</span><br><span class=\"line\">            source += &quot;__p += &apos;&quot; + tpl.slice(index, offset).replace(escaper, convertEscapes) + &quot;&apos;\\n&quot;;</span><br><span class=\"line\">            index = offset + match.length;</span><br><span class=\"line\">            if (evaluate) &#123;</span><br><span class=\"line\">                source += evaluate + &quot;\\n&quot;</span><br><span class=\"line\">            &#125; else if (interpolate) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + interpolate + &quot;) == null ? &apos;&apos; : &quot; + interpolate + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125; else if (escape) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + escape + &quot;) == null ? &apos;&apos; : &quot; + html2Entity(escape) + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return match;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        source = &quot;var __p = &apos;&apos;;&quot; + source + &apos;return __p;&apos;</span><br><span class=\"line\">        // 使用with可以修改作用域</span><br><span class=\"line\">        if (!settings.variable) source = &quot;with(obj||&#123;&#125;) &#123;\\n&quot; + source + &quot;\\n&#125;&quot;</span><br><span class=\"line\">        var render = new Function(settings.variable || &quot;obj&quot;, source);</span><br><span class=\"line\">        return render</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 将templateY导出到全局</span><br><span class=\"line\">    root.templateY = template</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>我们知道，在字符串中有一些特殊字符是需要转义的，比如”‘“, ‘“‘，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。<br>但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？<br>这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log = new Function(&quot;var a = &apos;1\\n23&apos;;console.log(a)&quot;);</span><br><span class=\"line\">log() // Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>\n<p>这是因为Function函数在执行的时候，里面的内容被解析成了这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &apos;1</span><br><span class=\"line\">23&apos;;console.log(a)</span><br></pre></td></tr></table></figure></p>\n<p>在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>underscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（&lt;%=%&gt;和&lt;%%&gt;）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似的语法了。<br>这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/&lt;%=([\\s\\S]+?)%&gt;/g是不会匹配到类似&lt;%=name&lt;%=age%&gt;%&gt;这种语法的，只会匹配到&lt;%=name%&gt;语法。</p>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h2><p>这里我们用到了replace第二个参数是函数的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /([a-z]+)\\s([a-z]+)/;</span><br><span class=\"line\">var str = &quot;hello world&quot;;</span><br><span class=\"line\">str.replace(pattern, function(match, p1, p2, offset) &#123;</span><br><span class=\"line\">    // p1 is &quot;hello&quot;</span><br><span class=\"line\">    // p2 is &quot;world&quot;</span><br><span class=\"line\">    return match;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是”hello world”。<br>p1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。</p>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>underscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。<br>我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [], str = &quot;&quot;;</span><br><span class=\"line\">var i = 0, j = 0</span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;i&lt;100000;i++) &#123;</span><br><span class=\"line\">  arr.push(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.join(&quot;&quot;);</span><br><span class=\"line\">console.timeEnd()</span><br><span class=\"line\"></span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;j&lt;100000;j++) &#123;</span><br><span class=\"line\">  str+= j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.timeEnd()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setting-variable\"><a href=\"#setting-variable\" class=\"headerlink\" title=\"setting.variable\"></a>setting.variable</h2><p>underscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: <a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a><br>你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.template(&quot;Using &apos;with&apos;: &lt;%= data.answer %&gt;&quot;, &#123;variable: &apos;data&apos;&#125;)(&#123;answer: &apos;no&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000003497780\" target=\"_blank\" rel=\"noopener\">js正则进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\" target=\"_blank\" rel=\"noopener\">JavaScript函数replace揭秘</a></li>\n<li><a href=\"https://blog.csdn.net/lihefei_coder/article/details/53022253\" target=\"_blank\" rel=\"noopener\">JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/77\" target=\"_blank\" rel=\"noopener\">underscore 系列之字符实体与 _.escape</a></li>\n<li><a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a></li>\n<li><a href=\"https://blog.csdn.net/wangjinyu501/article/details/7675599\" target=\"_blank\" rel=\"noopener\">高性能JavaScript模板引擎原理解析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：<a href=\"https://segmentfault.com/a/1190000005705169\" target=\"_blank\" rel=\"noopener\">只有20行的Javascript模板引擎</a><br>这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。<br>但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。<br>恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。<br>这个是我参考template后实现的模板，一共只有60行代码。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var root = this;</span><br><span class=\"line\">    // 将字符串中的HTML实体字符转义，可以有效减少xss风险</span><br><span class=\"line\">    var html2Entity = (function () &#123;</span><br><span class=\"line\">        var escapeMap = &#123;</span><br><span class=\"line\">            &apos;&amp;&apos;: &apos;&amp;amp;&apos;,</span><br><span class=\"line\">            &apos;&lt;&apos;: &apos;&amp;lt;&apos;,</span><br><span class=\"line\">            &apos;&gt;&apos;: &apos;&amp;gt;&apos;,</span><br><span class=\"line\">            &apos;&quot;&apos;: &apos;&amp;quot;&apos;,</span><br><span class=\"line\">            &quot;&apos;&quot;: &apos;&amp;#x27;&apos;,</span><br><span class=\"line\">            &apos;`&apos;: &apos;&amp;#x60;&apos;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var escaper = function (match) &#123;</span><br><span class=\"line\">            return escapeMap[match];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return function (string) &#123;</span><br><span class=\"line\">            var source = &quot;(&quot; + Object.keys(escapeMap).join(&quot;|&quot;) + &quot;)&quot;;</span><br><span class=\"line\">            var regexp = RegExp(source), regexpAll = RegExp(source, &quot;g&quot;);</span><br><span class=\"line\">            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    // 字符串中的转义字符</span><br><span class=\"line\">    var escapes = &#123;</span><br><span class=\"line\">        &apos;&quot;&apos;: &apos;&quot;&apos;,</span><br><span class=\"line\">        &quot;&apos;&quot;: &quot;&apos;&quot;,</span><br><span class=\"line\">        &quot;\\\\&quot;: &quot;\\\\&quot;,</span><br><span class=\"line\">        &apos;\\n&apos;: &apos;n&apos;,</span><br><span class=\"line\">        &apos;\\r&apos;: &apos;r&apos;,</span><br><span class=\"line\">        &apos;\\u2028&apos;: &apos;u2028&apos;,</span><br><span class=\"line\">        &apos;\\u2029&apos;: &apos;u2029&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var escaper = /\\\\|&apos;|&quot;|\\r|\\n|\\u2028|\\u2029/g;</span><br><span class=\"line\">    var convertEscapes = function (match) &#123;</span><br><span class=\"line\">        return &quot;\\\\&quot; + escapes[match];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var template = function (tpl, settings) &#123;</span><br><span class=\"line\">        // 可以在外部修改template.templateSettings来自定义语法</span><br><span class=\"line\">        // 一定要保证evaluate在最后，不然会匹配到&lt;%=%&gt;和&lt;%-%&gt;</span><br><span class=\"line\">        var templateSettings = Object.assign(&#123;&#125;, &#123;</span><br><span class=\"line\">            interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            escape: /&lt;%-([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            evaluate: /&lt;%([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">        &#125;, template.templateSettings);</span><br><span class=\"line\">        settings = Object.assign(&#123;&#125;, settings);</span><br><span class=\"line\">        // /&lt;%=([\\s\\S]+?)%&gt;|&lt;%-([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g</span><br><span class=\"line\">        // 其中$是为了匹配字符串的最后一个字符</span><br><span class=\"line\">        var matcher = RegExp(Object.keys(templateSettings).map(function (key) &#123;</span><br><span class=\"line\">            return templateSettings[key].source</span><br><span class=\"line\">        &#125;).join(&quot;|&quot;) + &quot;|$&quot;, &quot;g&quot;)</span><br><span class=\"line\">        var source = &quot;&quot;, index = 0;</span><br><span class=\"line\">        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串</span><br><span class=\"line\">        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) &#123;</span><br><span class=\"line\">            source += &quot;__p += &apos;&quot; + tpl.slice(index, offset).replace(escaper, convertEscapes) + &quot;&apos;\\n&quot;;</span><br><span class=\"line\">            index = offset + match.length;</span><br><span class=\"line\">            if (evaluate) &#123;</span><br><span class=\"line\">                source += evaluate + &quot;\\n&quot;</span><br><span class=\"line\">            &#125; else if (interpolate) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + interpolate + &quot;) == null ? &apos;&apos; : &quot; + interpolate + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125; else if (escape) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + escape + &quot;) == null ? &apos;&apos; : &quot; + html2Entity(escape) + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return match;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        source = &quot;var __p = &apos;&apos;;&quot; + source + &apos;return __p;&apos;</span><br><span class=\"line\">        // 使用with可以修改作用域</span><br><span class=\"line\">        if (!settings.variable) source = &quot;with(obj||&#123;&#125;) &#123;\\n&quot; + source + &quot;\\n&#125;&quot;</span><br><span class=\"line\">        var render = new Function(settings.variable || &quot;obj&quot;, source);</span><br><span class=\"line\">        return render</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 将templateY导出到全局</span><br><span class=\"line\">    root.templateY = template</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>我们知道，在字符串中有一些特殊字符是需要转义的，比如”‘“, ‘“‘，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。<br>但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？<br>这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log = new Function(&quot;var a = &apos;1\\n23&apos;;console.log(a)&quot;);</span><br><span class=\"line\">log() // Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>\n<p>这是因为Function函数在执行的时候，里面的内容被解析成了这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &apos;1</span><br><span class=\"line\">23&apos;;console.log(a)</span><br></pre></td></tr></table></figure></p>\n<p>在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>underscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（&lt;%=%&gt;和&lt;%%&gt;）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似的语法了。<br>这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/&lt;%=([\\s\\S]+?)%&gt;/g是不会匹配到类似&lt;%=name&lt;%=age%&gt;%&gt;这种语法的，只会匹配到&lt;%=name%&gt;语法。</p>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h2><p>这里我们用到了replace第二个参数是函数的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /([a-z]+)\\s([a-z]+)/;</span><br><span class=\"line\">var str = &quot;hello world&quot;;</span><br><span class=\"line\">str.replace(pattern, function(match, p1, p2, offset) &#123;</span><br><span class=\"line\">    // p1 is &quot;hello&quot;</span><br><span class=\"line\">    // p2 is &quot;world&quot;</span><br><span class=\"line\">    return match;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是”hello world”。<br>p1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。</p>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>underscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。<br>我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [], str = &quot;&quot;;</span><br><span class=\"line\">var i = 0, j = 0</span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;i&lt;100000;i++) &#123;</span><br><span class=\"line\">  arr.push(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.join(&quot;&quot;);</span><br><span class=\"line\">console.timeEnd()</span><br><span class=\"line\"></span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;j&lt;100000;j++) &#123;</span><br><span class=\"line\">  str+= j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.timeEnd()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setting-variable\"><a href=\"#setting-variable\" class=\"headerlink\" title=\"setting.variable\"></a>setting.variable</h2><p>underscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: <a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a><br>你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.template(&quot;Using &apos;with&apos;: &lt;%= data.answer %&gt;&quot;, &#123;variable: &apos;data&apos;&#125;)(&#123;answer: &apos;no&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000003497780\" target=\"_blank\" rel=\"noopener\">js正则进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\" target=\"_blank\" rel=\"noopener\">JavaScript函数replace揭秘</a></li>\n<li><a href=\"https://blog.csdn.net/lihefei_coder/article/details/53022253\" target=\"_blank\" rel=\"noopener\">JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/77\" target=\"_blank\" rel=\"noopener\">underscore 系列之字符实体与 _.escape</a></li>\n<li><a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a></li>\n<li><a href=\"https://blog.csdn.net/wangjinyu501/article/details/7675599\" target=\"_blank\" rel=\"noopener\">高性能JavaScript模板引擎原理解析</a></li>\n</ol>"},{"title":"TypeScript踩坑（持续更新）","date":"2018-11-22T11:26:05.000Z","_content":"\n## 配置\n### 为JS编写类型声明文件(d.ts)\n很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。\n\n我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。\n#### 集中管理，相对路径导入\n为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。\n目录结构如下：\n```\n- @types\n    - BasePage.d.ts\n- src\n    - frame\n        - BasePage.js\n    - page\n        - hotelList\n            - index.tsx\n```\n类型声明文件：\n```\n// BasePage.d.ts\nimport BasePage from '../src/frame/BasePage'\ndeclare module \"../src/frame/BasePage\" {\n    export default class BasePage{}\n}\n```\n引入类型文件：\n```\n// index.tsx\n/// <reference path=\"../../../@types/BasePage.d.ts\" />\n```\n如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。\n#### 自动导入\n上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。\n```\n- src\n    - frame\n        - BasePage.js\n        - BasePage.d.ts\n    - page\n        - hotelList\n            - index.tsx\n```\nindex.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。\n```\n// BasePage.d.ts\n// 注意：这里不需要再声明declare module \"BasePage\"了，否则会识别不了\nexport default class BasePage{}\n```\n<!-- more -->\n#### 自动导入\n上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。\n```\n- src\n    - frame\n        - BasePage.js\n        - BasePage.d.ts\n    - page\n        - hotelList\n            - index.tsx\n```\nindex.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。\n```\n// BasePage.d.ts\n// 注意：这里不需要再声明declare module \"BasePage\"了，否则会识别不了\nexport default class BasePage{}\n```\n## 语法\n### 1. Element implicitly has an 'any' type because type 'Test' has no index signature\n```\nclass PageFlag {\n    updatePageFlag(name: string, value: boolean) {\n        this[name] = value;\n    }\n}\n```\n这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。\n\n#### (1) 修改tsconfig.json里的noImplicitAny为false。\n\n#### (2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\n\n```\n// 例2\ninterface IParams {\n    [propName: string]: any\n}\nclass PageFlag {\n    updatePageFlag = (name: string, value: boolean) => {\n        (<IParams>this)[name] = value\n    }\n}\n```\n\n#### (3) 手动列举所有属性\n虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。\n```\ntype pageFlag = \"showLoading\" | \"showMask\" | \"showCalendar\";\nclass PageFlag {\n    showLoading: boolean = false;\n    showMask: boolean = false;\n    showCalendar: boolean = false;\n    \n    updatePageFlag = (name: pageFlag, value: boolean) => {\n       this[name] = value\n    }\n}\n```\n## export from\n有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：\n```\n// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：\nexport Hotel from './Hotel'\nexport * as HotelList from './HotelList'\nexport Header from './Header'\n```\n但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！\n后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。\n![image.png-872kB][1]\n但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。\n```\nexport {default as Hotel} from './Hotel'\nexport {default as HotelList} from './HotelList'\nexport {default as Header} from './Header'\n```\n顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。\n```\nexport { Hotel } from './Hotel'\nexport * from './Hotel\n```\n##  error TS2322: Type '(string | RegisteredStyle<ViewStyle | TextStyle | ImageStyle>)[]' is not assignable to type 'StyleProp<ViewStyle>'.\n这里是View使用的style类型问题，类似的还有Text、TouchableOpacity，这里需要类型断言，改为如下:\n```\n<Text style={[styles.subText, index == subActive ? styles.subActiveText : \"\"] as TextStyle} >{item}</Text>\n```\n\n  [1]: https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex","source":"_posts/TypeScript踩坑（持续更新）.md","raw":"---\ntitle: TypeScript踩坑（持续更新）\ndate: 2018-11-22 19:26:05\ncategories: [前端, TypeScript]\ntags:\n    - TypeScript\n    - 前端\n---\n\n## 配置\n### 为JS编写类型声明文件(d.ts)\n很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。\n\n我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。\n#### 集中管理，相对路径导入\n为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。\n目录结构如下：\n```\n- @types\n    - BasePage.d.ts\n- src\n    - frame\n        - BasePage.js\n    - page\n        - hotelList\n            - index.tsx\n```\n类型声明文件：\n```\n// BasePage.d.ts\nimport BasePage from '../src/frame/BasePage'\ndeclare module \"../src/frame/BasePage\" {\n    export default class BasePage{}\n}\n```\n引入类型文件：\n```\n// index.tsx\n/// <reference path=\"../../../@types/BasePage.d.ts\" />\n```\n如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。\n#### 自动导入\n上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。\n```\n- src\n    - frame\n        - BasePage.js\n        - BasePage.d.ts\n    - page\n        - hotelList\n            - index.tsx\n```\nindex.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。\n```\n// BasePage.d.ts\n// 注意：这里不需要再声明declare module \"BasePage\"了，否则会识别不了\nexport default class BasePage{}\n```\n<!-- more -->\n#### 自动导入\n上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。\n```\n- src\n    - frame\n        - BasePage.js\n        - BasePage.d.ts\n    - page\n        - hotelList\n            - index.tsx\n```\nindex.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。\n```\n// BasePage.d.ts\n// 注意：这里不需要再声明declare module \"BasePage\"了，否则会识别不了\nexport default class BasePage{}\n```\n## 语法\n### 1. Element implicitly has an 'any' type because type 'Test' has no index signature\n```\nclass PageFlag {\n    updatePageFlag(name: string, value: boolean) {\n        this[name] = value;\n    }\n}\n```\n这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。\n\n#### (1) 修改tsconfig.json里的noImplicitAny为false。\n\n#### (2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\n\n```\n// 例2\ninterface IParams {\n    [propName: string]: any\n}\nclass PageFlag {\n    updatePageFlag = (name: string, value: boolean) => {\n        (<IParams>this)[name] = value\n    }\n}\n```\n\n#### (3) 手动列举所有属性\n虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。\n```\ntype pageFlag = \"showLoading\" | \"showMask\" | \"showCalendar\";\nclass PageFlag {\n    showLoading: boolean = false;\n    showMask: boolean = false;\n    showCalendar: boolean = false;\n    \n    updatePageFlag = (name: pageFlag, value: boolean) => {\n       this[name] = value\n    }\n}\n```\n## export from\n有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：\n```\n// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：\nexport Hotel from './Hotel'\nexport * as HotelList from './HotelList'\nexport Header from './Header'\n```\n但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！\n后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。\n![image.png-872kB][1]\n但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。\n```\nexport {default as Hotel} from './Hotel'\nexport {default as HotelList} from './HotelList'\nexport {default as Header} from './Header'\n```\n顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。\n```\nexport { Hotel } from './Hotel'\nexport * from './Hotel\n```\n##  error TS2322: Type '(string | RegisteredStyle<ViewStyle | TextStyle | ImageStyle>)[]' is not assignable to type 'StyleProp<ViewStyle>'.\n这里是View使用的style类型问题，类似的还有Text、TouchableOpacity，这里需要类型断言，改为如下:\n```\n<Text style={[styles.subText, index == subActive ? styles.subActiveText : \"\"] as TextStyle} >{item}</Text>\n```\n\n  [1]: https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex","slug":"TypeScript踩坑（持续更新）","published":1,"updated":"2019-04-07T05:53:12.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsj0006drfdpc6lmqva","content":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"为JS编写类型声明文件-d-ts\"><a href=\"#为JS编写类型声明文件-d-ts\" class=\"headerlink\" title=\"为JS编写类型声明文件(d.ts)\"></a>为JS编写类型声明文件(d.ts)</h3><p>很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。</p>\n<p>我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。</p>\n<h4 id=\"集中管理，相对路径导入\"><a href=\"#集中管理，相对路径导入\" class=\"headerlink\" title=\"集中管理，相对路径导入\"></a>集中管理，相对路径导入</h4><p>为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。<br>目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- @types</span><br><span class=\"line\">    - BasePage.d.ts</span><br><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>类型声明文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">import BasePage from &apos;../src/frame/BasePage&apos;</span><br><span class=\"line\">declare module &quot;../src/frame/BasePage&quot; &#123;</span><br><span class=\"line\">    export default class BasePage&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引入类型文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.tsx</span><br><span class=\"line\">/// &lt;reference path=&quot;../../../@types/BasePage.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。</p>\n<h4 id=\"自动导入\"><a href=\"#自动导入\" class=\"headerlink\" title=\"自动导入\"></a>自动导入</h4><p>上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">        - BasePage.d.ts</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>index.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">// 注意：这里不需要再声明declare module &quot;BasePage&quot;了，否则会识别不了</span><br><span class=\"line\">export default class BasePage&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"自动导入-1\"><a href=\"#自动导入-1\" class=\"headerlink\" title=\"自动导入\"></a>自动导入</h4><p>上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">        - BasePage.d.ts</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>index.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">// 注意：这里不需要再声明declare module &quot;BasePage&quot;了，否则会识别不了</span><br><span class=\"line\">export default class BasePage&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\"><a href=\"#1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\" class=\"headerlink\" title=\"1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature\"></a>1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag(name: string, value: boolean) &#123;</span><br><span class=\"line\">        this[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。</p>\n<h4 id=\"1-修改tsconfig-json里的noImplicitAny为false。\"><a href=\"#1-修改tsconfig-json里的noImplicitAny为false。\" class=\"headerlink\" title=\"(1) 修改tsconfig.json里的noImplicitAny为false。\"></a>(1) 修改tsconfig.json里的noImplicitAny为false。</h4><h4 id=\"2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"><a href=\"#2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\" class=\"headerlink\" title=\"(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"></a>(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例2</span><br><span class=\"line\">interface IParams &#123;</span><br><span class=\"line\">    [propName: string]: any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag = (name: string, value: boolean) =&gt; &#123;</span><br><span class=\"line\">        (&lt;IParams&gt;this)[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-手动列举所有属性\"><a href=\"#3-手动列举所有属性\" class=\"headerlink\" title=\"(3) 手动列举所有属性\"></a>(3) 手动列举所有属性</h4><p>虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type pageFlag = &quot;showLoading&quot; | &quot;showMask&quot; | &quot;showCalendar&quot;;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    showLoading: boolean = false;</span><br><span class=\"line\">    showMask: boolean = false;</span><br><span class=\"line\">    showCalendar: boolean = false;</span><br><span class=\"line\">    </span><br><span class=\"line\">    updatePageFlag = (name: pageFlag, value: boolean) =&gt; &#123;</span><br><span class=\"line\">       this[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"export-from\"><a href=\"#export-from\" class=\"headerlink\" title=\"export from\"></a>export from</h2><p>有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：</span><br><span class=\"line\">export Hotel from &apos;./Hotel&apos;</span><br><span class=\"line\">export * as HotelList from &apos;./HotelList&apos;</span><br><span class=\"line\">export Header from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！<br>后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。<br><img src=\"https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex\" alt=\"image.png-872kB\"><br>但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;default as Hotel&#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export &#123;default as HotelList&#125; from &apos;./HotelList&apos;</span><br><span class=\"line\">export &#123;default as Header&#125; from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; Hotel &#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export * from &apos;./Hotel</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"error-TS2322-Type-‘-string-RegisteredStyle-’-is-not-assignable-to-type-‘StyleProp‘\"><a href=\"#error-TS2322-Type-‘-string-RegisteredStyle-’-is-not-assignable-to-type-‘StyleProp‘\" class=\"headerlink\" title=\"error TS2322: Type ‘(string | RegisteredStyle)[]’ is not assignable to type ‘StyleProp‘.\"></a>error TS2322: Type ‘(string | RegisteredStyle<viewstyle |=\"\" textstyle=\"\" imagestyle=\"\">)[]’ is not assignable to type ‘StyleProp<viewstyle>‘.</viewstyle></viewstyle></h2><p>这里是View使用的style类型问题，类似的还有Text、TouchableOpacity，这里需要类型断言，改为如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;[styles.subText, index == subActive ? styles.subActiveText : &quot;&quot;] as TextStyle&#125; &gt;&#123;item&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"为JS编写类型声明文件-d-ts\"><a href=\"#为JS编写类型声明文件-d-ts\" class=\"headerlink\" title=\"为JS编写类型声明文件(d.ts)\"></a>为JS编写类型声明文件(d.ts)</h3><p>很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。</p>\n<p>我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。</p>\n<h4 id=\"集中管理，相对路径导入\"><a href=\"#集中管理，相对路径导入\" class=\"headerlink\" title=\"集中管理，相对路径导入\"></a>集中管理，相对路径导入</h4><p>为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。<br>目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- @types</span><br><span class=\"line\">    - BasePage.d.ts</span><br><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>类型声明文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">import BasePage from &apos;../src/frame/BasePage&apos;</span><br><span class=\"line\">declare module &quot;../src/frame/BasePage&quot; &#123;</span><br><span class=\"line\">    export default class BasePage&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引入类型文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.tsx</span><br><span class=\"line\">/// &lt;reference path=&quot;../../../@types/BasePage.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。</p>\n<h4 id=\"自动导入\"><a href=\"#自动导入\" class=\"headerlink\" title=\"自动导入\"></a>自动导入</h4><p>上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">        - BasePage.d.ts</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>index.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">// 注意：这里不需要再声明declare module &quot;BasePage&quot;了，否则会识别不了</span><br><span class=\"line\">export default class BasePage&#123;&#125;</span><br></pre></td></tr></table></figure></p>","more":"<h4 id=\"自动导入-1\"><a href=\"#自动导入-1\" class=\"headerlink\" title=\"自动导入\"></a>自动导入</h4><p>上面那种方法虽然可以将types文件集中管理，但是有个很麻烦的地方就是需要在引入BasePage模块的地方手动引入d.ts文件，这个真的很繁琐，这里有个更好的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    - frame</span><br><span class=\"line\">        - BasePage.js</span><br><span class=\"line\">        - BasePage.d.ts</span><br><span class=\"line\">    - page</span><br><span class=\"line\">        - hotelList</span><br><span class=\"line\">            - index.tsx</span><br></pre></td></tr></table></figure></p>\n<p>index.tsx文件直接import导入BasePage就行了，不需要再专门引入BasePage.d.ts，这里两者命名一样，所以会自动识别BasePage.d.ts，但是BasePage.d.ts的语法也变化了一些。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BasePage.d.ts</span><br><span class=\"line\">// 注意：这里不需要再声明declare module &quot;BasePage&quot;了，否则会识别不了</span><br><span class=\"line\">export default class BasePage&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\"><a href=\"#1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\" class=\"headerlink\" title=\"1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature\"></a>1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag(name: string, value: boolean) &#123;</span><br><span class=\"line\">        this[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。</p>\n<h4 id=\"1-修改tsconfig-json里的noImplicitAny为false。\"><a href=\"#1-修改tsconfig-json里的noImplicitAny为false。\" class=\"headerlink\" title=\"(1) 修改tsconfig.json里的noImplicitAny为false。\"></a>(1) 修改tsconfig.json里的noImplicitAny为false。</h4><h4 id=\"2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"><a href=\"#2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\" class=\"headerlink\" title=\"(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"></a>(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例2</span><br><span class=\"line\">interface IParams &#123;</span><br><span class=\"line\">    [propName: string]: any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag = (name: string, value: boolean) =&gt; &#123;</span><br><span class=\"line\">        (&lt;IParams&gt;this)[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-手动列举所有属性\"><a href=\"#3-手动列举所有属性\" class=\"headerlink\" title=\"(3) 手动列举所有属性\"></a>(3) 手动列举所有属性</h4><p>虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type pageFlag = &quot;showLoading&quot; | &quot;showMask&quot; | &quot;showCalendar&quot;;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    showLoading: boolean = false;</span><br><span class=\"line\">    showMask: boolean = false;</span><br><span class=\"line\">    showCalendar: boolean = false;</span><br><span class=\"line\">    </span><br><span class=\"line\">    updatePageFlag = (name: pageFlag, value: boolean) =&gt; &#123;</span><br><span class=\"line\">       this[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"export-from\"><a href=\"#export-from\" class=\"headerlink\" title=\"export from\"></a>export from</h2><p>有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：</span><br><span class=\"line\">export Hotel from &apos;./Hotel&apos;</span><br><span class=\"line\">export * as HotelList from &apos;./HotelList&apos;</span><br><span class=\"line\">export Header from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！<br>后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。<br><img src=\"https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex\" alt=\"image.png-872kB\"><br>但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;default as Hotel&#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export &#123;default as HotelList&#125; from &apos;./HotelList&apos;</span><br><span class=\"line\">export &#123;default as Header&#125; from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; Hotel &#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export * from &apos;./Hotel</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"error-TS2322-Type-‘-string-RegisteredStyle-’-is-not-assignable-to-type-‘StyleProp‘\"><a href=\"#error-TS2322-Type-‘-string-RegisteredStyle-’-is-not-assignable-to-type-‘StyleProp‘\" class=\"headerlink\" title=\"error TS2322: Type ‘(string | RegisteredStyle)[]’ is not assignable to type ‘StyleProp‘.\"></a>error TS2322: Type ‘(string | RegisteredStyle<viewstyle |=\"\" textstyle=\"\" imagestyle=\"\">)[]’ is not assignable to type ‘StyleProp<viewstyle>‘.</viewstyle></viewstyle></h2><p>这里是View使用的style类型问题，类似的还有Text、TouchableOpacity，这里需要类型断言，改为如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;[styles.subText, index == subActive ? styles.subActiveText : &quot;&quot;] as TextStyle&#125; &gt;&#123;item&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure></p>"},{"title":"react状态管理","date":"2018-10-05T09:47:30.000Z","_content":"react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。\n\n## 全局state\n如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。\n\n## redux\nredux是我们公司老项目中最常用的状态库，redux遵守dispatch -> action -> reducer -> store -> view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。\n\n## relite\nrelite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。\n\n## mobx\nmobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。\nmobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。\n\n如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。\n\n","source":"_posts/react状态管理.md","raw":"---\ntitle: react状态管理\ndate: 2018-10-05 17:47:30\ncategories: [前端, react]\ntags:\n    - redux\n    - react\n    - 前端\n---\nreact作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。\n\n## 全局state\n如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。\n\n## redux\nredux是我们公司老项目中最常用的状态库，redux遵守dispatch -> action -> reducer -> store -> view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。\n\n## relite\nrelite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。\n\n## mobx\nmobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。\nmobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。\n\n如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。\n\n","slug":"react状态管理","published":1,"updated":"2019-04-07T05:53:12.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsl0008drfd4i3pkoo8","content":"<p>react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。</p>\n<h2 id=\"全局state\"><a href=\"#全局state\" class=\"headerlink\" title=\"全局state\"></a>全局state</h2><p>如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。</p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><p>redux是我们公司老项目中最常用的状态库，redux遵守dispatch -&gt; action -&gt; reducer -&gt; store -&gt; view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。</p>\n<h2 id=\"relite\"><a href=\"#relite\" class=\"headerlink\" title=\"relite\"></a>relite</h2><p>relite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。</p>\n<h2 id=\"mobx\"><a href=\"#mobx\" class=\"headerlink\" title=\"mobx\"></a>mobx</h2><p>mobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。<br>mobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。</p>\n<p>如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。</p>\n<h2 id=\"全局state\"><a href=\"#全局state\" class=\"headerlink\" title=\"全局state\"></a>全局state</h2><p>如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。</p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><p>redux是我们公司老项目中最常用的状态库，redux遵守dispatch -&gt; action -&gt; reducer -&gt; store -&gt; view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。</p>\n<h2 id=\"relite\"><a href=\"#relite\" class=\"headerlink\" title=\"relite\"></a>relite</h2><p>relite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。</p>\n<h2 id=\"mobx\"><a href=\"#mobx\" class=\"headerlink\" title=\"mobx\"></a>mobx</h2><p>mobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。<br>mobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。</p>\n<p>如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。</p>\n"},{"title":"underscore debounce防抖动函数分析","date":"2018-03-23T14:15:06.000Z","_content":"本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。\nthrottle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。\n## 电梯 ##\n\n假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。\n## 应用场景 ##\n除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。\n<!-- more -->\n未使用debounce的输入：\n![未使用debounce][2]\n使用debounce的输入：\n![使用debounce][3]\n## 简单的debounce ##\n知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。\n```\nfunction debounce(func, wait) {\n\tvar timeout,\n\t\targs, \n\t\tcontext\n\tvar later = function() {\n\t\tfunc.apply(context, args)\n\t\ttimeout = context = args = null\n\t}\n\treturn function() {\n\t\tcontext = this\n\t\targs = arguments\n\t\t// 每次触发都清理掉前一次的定时器\n\t\tclearTimeout(timeout)\n\t\t// 只有最后一次触发后才会调用later\n\t\ttimeout = setTimeout(later, wait)\n\t}\n}\n```\n麻雀虽小，五脏俱全。\n不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。\n## underscore debounce ##\n```\n// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate\n// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func\n// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用\n_.debounce = function (func, wait, immediate) {\n\t\tvar timeout, args, context, timestamp, result;\n\n\t\tvar later = function () {\n\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp\n\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的\n\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait\n\t\t    // last是执行later的时间和上一次触发的时间差\n\t\t\tvar last = _.now() - timestamp;\n            // 如果在later执行前还有其他触发，那么就会重新设置定时器\n            // last >= 0应该是防止客户端系统时间被调整\n\t\t\tif (last < wait && last >= 0) {\n\t\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过\n\t\t\t} else {\n\t\t\t\ttimeout = null;\n\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发\n\t\t\t\tif (!immediate) {\n\t\t\t\t\tresult = func.apply(context, args);\n\t\t\t\t\t// 解除引用\n\t\t\t\t\tif (!timeout) context = args = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn function () {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// 每次触发都用timestamp记录时间戳\n\t\t\ttimestamp = _.now();\n\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func\n\t\t\tvar callNow = immediate && !timeout;\n\t\t\t// 第一次进来的时候会设置一个定时器\n\t\t\tif (!timeout) timeout = setTimeout(later, wait);\n\t\t\tif (callNow) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tcontext = args = null;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t};\n```\nunderscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。\n\n同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。\n\n**参考链接：**\n1、[浅谈throttle以及debounce的原理和实现\n][1]\n\n\n  [1]: https://segmentfault.com/a/1190000010983733\n  [2]: http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\n  [3]: http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore debounce防抖动函数分析.md","raw":"---\ntitle: underscore debounce防抖动函数分析\ndate: 2018-03-23 22:15:06\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。\nthrottle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。\n## 电梯 ##\n\n假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。\n## 应用场景 ##\n除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。\n<!-- more -->\n未使用debounce的输入：\n![未使用debounce][2]\n使用debounce的输入：\n![使用debounce][3]\n## 简单的debounce ##\n知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。\n```\nfunction debounce(func, wait) {\n\tvar timeout,\n\t\targs, \n\t\tcontext\n\tvar later = function() {\n\t\tfunc.apply(context, args)\n\t\ttimeout = context = args = null\n\t}\n\treturn function() {\n\t\tcontext = this\n\t\targs = arguments\n\t\t// 每次触发都清理掉前一次的定时器\n\t\tclearTimeout(timeout)\n\t\t// 只有最后一次触发后才会调用later\n\t\ttimeout = setTimeout(later, wait)\n\t}\n}\n```\n麻雀虽小，五脏俱全。\n不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。\n## underscore debounce ##\n```\n// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate\n// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func\n// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用\n_.debounce = function (func, wait, immediate) {\n\t\tvar timeout, args, context, timestamp, result;\n\n\t\tvar later = function () {\n\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp\n\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的\n\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait\n\t\t    // last是执行later的时间和上一次触发的时间差\n\t\t\tvar last = _.now() - timestamp;\n            // 如果在later执行前还有其他触发，那么就会重新设置定时器\n            // last >= 0应该是防止客户端系统时间被调整\n\t\t\tif (last < wait && last >= 0) {\n\t\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过\n\t\t\t} else {\n\t\t\t\ttimeout = null;\n\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发\n\t\t\t\tif (!immediate) {\n\t\t\t\t\tresult = func.apply(context, args);\n\t\t\t\t\t// 解除引用\n\t\t\t\t\tif (!timeout) context = args = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn function () {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// 每次触发都用timestamp记录时间戳\n\t\t\ttimestamp = _.now();\n\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func\n\t\t\tvar callNow = immediate && !timeout;\n\t\t\t// 第一次进来的时候会设置一个定时器\n\t\t\tif (!timeout) timeout = setTimeout(later, wait);\n\t\t\tif (callNow) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tcontext = args = null;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t};\n```\nunderscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。\n\n同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。\n\n**参考链接：**\n1、[浅谈throttle以及debounce的原理和实现\n][1]\n\n\n  [1]: https://segmentfault.com/a/1190000010983733\n  [2]: http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\n  [3]: http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore debounce防抖动函数分析","published":1,"updated":"2019-04-07T05:53:12.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsn0009drfdocnvtfuz","content":"<p>本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。<br>throttle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。</p>\n<h2 id=\"电梯\"><a href=\"#电梯\" class=\"headerlink\" title=\"电梯\"></a>电梯</h2><p>假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。<br><a id=\"more\"></a><br>未使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\" alt=\"未使用debounce\"><br>使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\" alt=\"使用debounce\"></p>\n<h2 id=\"简单的debounce\"><a href=\"#简单的debounce\" class=\"headerlink\" title=\"简单的debounce\"></a>简单的debounce</h2><p>知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">\tvar timeout,</span><br><span class=\"line\">\t\targs, </span><br><span class=\"line\">\t\tcontext</span><br><span class=\"line\">\tvar later = function() &#123;</span><br><span class=\"line\">\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\ttimeout = context = args = null</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tcontext = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 每次触发都清理掉前一次的定时器</span><br><span class=\"line\">\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t// 只有最后一次触发后才会调用later</span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>麻雀虽小，五脏俱全。<br>不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。</p>\n<h2 id=\"underscore-debounce\"><a href=\"#underscore-debounce\" class=\"headerlink\" title=\"underscore debounce\"></a>underscore debounce</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate</span><br><span class=\"line\">// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func</span><br><span class=\"line\">// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用</span><br><span class=\"line\">_.debounce = function (func, wait, immediate) &#123;</span><br><span class=\"line\">\t\tvar timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp</span><br><span class=\"line\">\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的</span><br><span class=\"line\">\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait</span><br><span class=\"line\">\t\t    // last是执行later的时间和上一次触发的时间差</span><br><span class=\"line\">\t\t\tvar last = _.now() - timestamp;</span><br><span class=\"line\">            // 如果在later执行前还有其他触发，那么就会重新设置定时器</span><br><span class=\"line\">            // last &gt;= 0应该是防止客户端系统时间被调整</span><br><span class=\"line\">\t\t\tif (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, wait - last);</span><br><span class=\"line\">\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发</span><br><span class=\"line\">\t\t\t\tif (!immediate) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// 每次触发都用timestamp记录时间戳</span><br><span class=\"line\">\t\t\ttimestamp = _.now();</span><br><span class=\"line\">\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func</span><br><span class=\"line\">\t\t\tvar callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\t\t// 第一次进来的时候会设置一个定时器</span><br><span class=\"line\">\t\t\tif (!timeout) timeout = setTimeout(later, wait);</span><br><span class=\"line\">\t\t\tif (callNow) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tcontext = args = null;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>underscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。</p>\n<p>同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。</p>\n<p><strong>参考链接：</strong><br>1、<a href=\"https://segmentfault.com/a/1190000010983733\" target=\"_blank\" rel=\"noopener\">浅谈throttle以及debounce的原理和实现\n</a></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。<br>throttle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。</p>\n<h2 id=\"电梯\"><a href=\"#电梯\" class=\"headerlink\" title=\"电梯\"></a>电梯</h2><p>假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。<br>","more":"<br>未使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\" alt=\"未使用debounce\"><br>使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\" alt=\"使用debounce\"></p>\n<h2 id=\"简单的debounce\"><a href=\"#简单的debounce\" class=\"headerlink\" title=\"简单的debounce\"></a>简单的debounce</h2><p>知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">\tvar timeout,</span><br><span class=\"line\">\t\targs, </span><br><span class=\"line\">\t\tcontext</span><br><span class=\"line\">\tvar later = function() &#123;</span><br><span class=\"line\">\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\ttimeout = context = args = null</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tcontext = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 每次触发都清理掉前一次的定时器</span><br><span class=\"line\">\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t// 只有最后一次触发后才会调用later</span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>麻雀虽小，五脏俱全。<br>不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。</p>\n<h2 id=\"underscore-debounce\"><a href=\"#underscore-debounce\" class=\"headerlink\" title=\"underscore debounce\"></a>underscore debounce</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate</span><br><span class=\"line\">// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func</span><br><span class=\"line\">// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用</span><br><span class=\"line\">_.debounce = function (func, wait, immediate) &#123;</span><br><span class=\"line\">\t\tvar timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp</span><br><span class=\"line\">\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的</span><br><span class=\"line\">\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait</span><br><span class=\"line\">\t\t    // last是执行later的时间和上一次触发的时间差</span><br><span class=\"line\">\t\t\tvar last = _.now() - timestamp;</span><br><span class=\"line\">            // 如果在later执行前还有其他触发，那么就会重新设置定时器</span><br><span class=\"line\">            // last &gt;= 0应该是防止客户端系统时间被调整</span><br><span class=\"line\">\t\t\tif (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, wait - last);</span><br><span class=\"line\">\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发</span><br><span class=\"line\">\t\t\t\tif (!immediate) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// 每次触发都用timestamp记录时间戳</span><br><span class=\"line\">\t\t\ttimestamp = _.now();</span><br><span class=\"line\">\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func</span><br><span class=\"line\">\t\t\tvar callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\t\t// 第一次进来的时候会设置一个定时器</span><br><span class=\"line\">\t\t\tif (!timeout) timeout = setTimeout(later, wait);</span><br><span class=\"line\">\t\t\tif (callNow) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tcontext = args = null;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>underscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。</p>\n<p>同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。</p>\n<p><strong>参考链接：</strong><br>1、<a href=\"https://segmentfault.com/a/1190000010983733\" target=\"_blank\" rel=\"noopener\">浅谈throttle以及debounce的原理和实现\n</a></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之基础方法","date":"2018-03-17T14:10:16.000Z","_content":"本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。\n## mixin ##\n在上篇文章[underscore整体架构分析][1]中，我们讲过**\\_**上面的方法有两种挂载方式，一个是挂载到**\\_**构造函数上以\\_.map(arr)的形式直接调用**（在后文上统称构造函数调用）**，另一种则是挂到\\_.prototype上以\\_(arr).map()的形式被实例调用**（在后文上统称原型调用）**。\n\n翻一遍underscore源码你会发现underscore中的方法都是直接挂到\\_构造函数上实现的，但是会通过mixin方法来将\\_上面的方法扩展到\\_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。\n```\n_.mixin = function(obj) {\n    // 遍历obj上所有的方法\n    _.each(_.functions(obj), function(name) {\n        // 保存方法的引用\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            // 将一开始传入的值放到数组中\n            var args = [this._wrapped];\n            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）\n            push.apply(args, arguments);\n            // 这里先用apply方法执行了func，并将结果传给了result\n            return result(this, func.apply(_, args));\n        };\n    });\n};\n\n_.mixin(_);\n```\n从这段代码中我们可以看出，mixin方法将\\_上的所有方法通过遍历的形式挂载到了\\_.prototype上面。\n<!-- more -->\n细心观察一下，构造函数调用和原型调用的区别在哪里？\n没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入\\_构造函数来创建一个实例。\n```\nvar arr = [1, 2, 3]\nvar func = function(item) {\n    console.log(item);\n}\n// 构造函数调用时arr被传入第一个参数\n_.each(arr, func)\n// 原型调用的时候，arr被当做参数传给_方法来创建一个实例\n_(arr).each(func)\n// 链式调用，和上面类似\n_.chain(arr).each(func)\n```\n从上一节中我们知道，在创建一个\\_的实例时，会用this.\\_wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this.\\_wrapped];是将我们传给\\_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接\\_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。\n## 链式调用 ##\n那么上面最后return result(this, func.apply(\\_, args))，result又是做什么的呢？\n\n首先来看result源码：\n```\nvar result = function(instance, obj) {\n    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果\n    return instance._chain ? _(obj).chain() : obj;\n};\n_.chain = function(obj) {\n    // 创建一个实例\n    var instance = _(obj);\n    // 给这个实例加个_chain属性来表明这是链式调用\n    instance._chain = true;\n    return instance;\n};\n```\n我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：\n```\nvar arr = [1, 2, 3]\nvar newArr = _.chain(a).map(function(item) {\n    return item + 1\n}).filter(function(item) {\n    return item > 2\n}).value()\n```\n链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。\nchain方法会用传入的obj创建一个\\_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。\n链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的\\_实例）\n## 数组函数 ##\nunderscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。\n```\n_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n    var obj = this._wrapped;\n    method.apply(obj, arguments);\n    // 这句是好像是为了解决ie上的bug？\n    if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n        return result(this, obj);\n    };\n});\n\n_.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n        return result(this, method.apply(this._wrapped, arguments));\n    };\n});\n```\n\n  [1]: https://segmentfault.com/a/1190000013789060?_ea=3463450\n  <head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之基础方法.md","raw":"---\ntitle: underscore源码剖析之基础方法\ndate: 2018-03-17 22:10:16\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。\n## mixin ##\n在上篇文章[underscore整体架构分析][1]中，我们讲过**\\_**上面的方法有两种挂载方式，一个是挂载到**\\_**构造函数上以\\_.map(arr)的形式直接调用**（在后文上统称构造函数调用）**，另一种则是挂到\\_.prototype上以\\_(arr).map()的形式被实例调用**（在后文上统称原型调用）**。\n\n翻一遍underscore源码你会发现underscore中的方法都是直接挂到\\_构造函数上实现的，但是会通过mixin方法来将\\_上面的方法扩展到\\_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。\n```\n_.mixin = function(obj) {\n    // 遍历obj上所有的方法\n    _.each(_.functions(obj), function(name) {\n        // 保存方法的引用\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            // 将一开始传入的值放到数组中\n            var args = [this._wrapped];\n            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）\n            push.apply(args, arguments);\n            // 这里先用apply方法执行了func，并将结果传给了result\n            return result(this, func.apply(_, args));\n        };\n    });\n};\n\n_.mixin(_);\n```\n从这段代码中我们可以看出，mixin方法将\\_上的所有方法通过遍历的形式挂载到了\\_.prototype上面。\n<!-- more -->\n细心观察一下，构造函数调用和原型调用的区别在哪里？\n没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入\\_构造函数来创建一个实例。\n```\nvar arr = [1, 2, 3]\nvar func = function(item) {\n    console.log(item);\n}\n// 构造函数调用时arr被传入第一个参数\n_.each(arr, func)\n// 原型调用的时候，arr被当做参数传给_方法来创建一个实例\n_(arr).each(func)\n// 链式调用，和上面类似\n_.chain(arr).each(func)\n```\n从上一节中我们知道，在创建一个\\_的实例时，会用this.\\_wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this.\\_wrapped];是将我们传给\\_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接\\_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。\n## 链式调用 ##\n那么上面最后return result(this, func.apply(\\_, args))，result又是做什么的呢？\n\n首先来看result源码：\n```\nvar result = function(instance, obj) {\n    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果\n    return instance._chain ? _(obj).chain() : obj;\n};\n_.chain = function(obj) {\n    // 创建一个实例\n    var instance = _(obj);\n    // 给这个实例加个_chain属性来表明这是链式调用\n    instance._chain = true;\n    return instance;\n};\n```\n我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：\n```\nvar arr = [1, 2, 3]\nvar newArr = _.chain(a).map(function(item) {\n    return item + 1\n}).filter(function(item) {\n    return item > 2\n}).value()\n```\n链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。\nchain方法会用传入的obj创建一个\\_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。\n链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的\\_实例）\n## 数组函数 ##\nunderscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。\n```\n_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n    var obj = this._wrapped;\n    method.apply(obj, arguments);\n    // 这句是好像是为了解决ie上的bug？\n    if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n        return result(this, obj);\n    };\n});\n\n_.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n        return result(this, method.apply(this._wrapped, arguments));\n    };\n});\n```\n\n  [1]: https://segmentfault.com/a/1190000013789060?_ea=3463450\n  <head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之基础方法","published":1,"updated":"2019-04-07T05:53:12.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsp000cdrfdfztrn3gd","content":"<p>本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。</p>\n<h2 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h2><p>在上篇文章<a href=\"https://segmentfault.com/a/1190000013789060?_ea=3463450\" target=\"_blank\" rel=\"noopener\">underscore整体架构分析</a>中，我们讲过<strong>_</strong>上面的方法有两种挂载方式，一个是挂载到<strong>_</strong>构造函数上以_.map(arr)的形式直接调用<strong>（在后文上统称构造函数调用）</strong>，另一种则是挂到_.prototype上以_(arr).map()的形式被实例调用<strong>（在后文上统称原型调用）</strong>。</p>\n<p>翻一遍underscore源码你会发现underscore中的方法都是直接挂到_构造函数上实现的，但是会通过mixin方法来将_上面的方法扩展到_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.mixin = function(obj) &#123;</span><br><span class=\"line\">    // 遍历obj上所有的方法</span><br><span class=\"line\">    _.each(_.functions(obj), function(name) &#123;</span><br><span class=\"line\">        // 保存方法的引用</span><br><span class=\"line\">        var func = _[name] = obj[name];</span><br><span class=\"line\">        _.prototype[name] = function() &#123;</span><br><span class=\"line\">            // 将一开始传入的值放到数组中</span><br><span class=\"line\">            var args = [this._wrapped];</span><br><span class=\"line\">            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）</span><br><span class=\"line\">            push.apply(args, arguments);</span><br><span class=\"line\">            // 这里先用apply方法执行了func，并将结果传给了result</span><br><span class=\"line\">            return result(this, func.apply(_, args));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_.mixin(_);</span><br></pre></td></tr></table></figure></p>\n<p>从这段代码中我们可以看出，mixin方法将_上的所有方法通过遍历的形式挂载到了_.prototype上面。<br><a id=\"more\"></a><br>细心观察一下，构造函数调用和原型调用的区别在哪里？<br>没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入_构造函数来创建一个实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var func = function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造函数调用时arr被传入第一个参数</span><br><span class=\"line\">_.each(arr, func)</span><br><span class=\"line\">// 原型调用的时候，arr被当做参数传给_方法来创建一个实例</span><br><span class=\"line\">_(arr).each(func)</span><br><span class=\"line\">// 链式调用，和上面类似</span><br><span class=\"line\">_.chain(arr).each(func)</span><br></pre></td></tr></table></figure></p>\n<p>从上一节中我们知道，在创建一个_的实例时，会用this._wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this._wrapped];是将我们传给_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>那么上面最后return result(this, func.apply(_, args))，result又是做什么的呢？</p>\n<p>首先来看result源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = function(instance, obj) &#123;</span><br><span class=\"line\">    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果</span><br><span class=\"line\">    return instance._chain ? _(obj).chain() : obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.chain = function(obj) &#123;</span><br><span class=\"line\">    // 创建一个实例</span><br><span class=\"line\">    var instance = _(obj);</span><br><span class=\"line\">    // 给这个实例加个_chain属性来表明这是链式调用</span><br><span class=\"line\">    instance._chain = true;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = _.chain(a).map(function(item) &#123;</span><br><span class=\"line\">    return item + 1</span><br><span class=\"line\">&#125;).filter(function(item) &#123;</span><br><span class=\"line\">    return item &gt; 2</span><br><span class=\"line\">&#125;).value()</span><br></pre></td></tr></table></figure></p>\n<p>链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。<br>chain方法会用传入的obj创建一个_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。<br>链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的_实例）</p>\n<h2 id=\"数组函数\"><a href=\"#数组函数\" class=\"headerlink\" title=\"数组函数\"></a>数组函数</h2><p>underscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">    var obj = this._wrapped;</span><br><span class=\"line\">    method.apply(obj, arguments);</span><br><span class=\"line\">    // 这句是好像是为了解决ie上的bug？</span><br><span class=\"line\">    if ((name === &apos;shift&apos; || name === &apos;splice&apos;) &amp;&amp; obj.length === 0) delete obj[0];</span><br><span class=\"line\">        return result(this, obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_.each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">        return result(this, method.apply(this._wrapped, arguments));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。</p>\n<h2 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h2><p>在上篇文章<a href=\"https://segmentfault.com/a/1190000013789060?_ea=3463450\" target=\"_blank\" rel=\"noopener\">underscore整体架构分析</a>中，我们讲过<strong>_</strong>上面的方法有两种挂载方式，一个是挂载到<strong>_</strong>构造函数上以_.map(arr)的形式直接调用<strong>（在后文上统称构造函数调用）</strong>，另一种则是挂到_.prototype上以_(arr).map()的形式被实例调用<strong>（在后文上统称原型调用）</strong>。</p>\n<p>翻一遍underscore源码你会发现underscore中的方法都是直接挂到_构造函数上实现的，但是会通过mixin方法来将_上面的方法扩展到_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.mixin = function(obj) &#123;</span><br><span class=\"line\">    // 遍历obj上所有的方法</span><br><span class=\"line\">    _.each(_.functions(obj), function(name) &#123;</span><br><span class=\"line\">        // 保存方法的引用</span><br><span class=\"line\">        var func = _[name] = obj[name];</span><br><span class=\"line\">        _.prototype[name] = function() &#123;</span><br><span class=\"line\">            // 将一开始传入的值放到数组中</span><br><span class=\"line\">            var args = [this._wrapped];</span><br><span class=\"line\">            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）</span><br><span class=\"line\">            push.apply(args, arguments);</span><br><span class=\"line\">            // 这里先用apply方法执行了func，并将结果传给了result</span><br><span class=\"line\">            return result(this, func.apply(_, args));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_.mixin(_);</span><br></pre></td></tr></table></figure></p>\n<p>从这段代码中我们可以看出，mixin方法将_上的所有方法通过遍历的形式挂载到了_.prototype上面。<br>","more":"<br>细心观察一下，构造函数调用和原型调用的区别在哪里？<br>没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入_构造函数来创建一个实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var func = function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造函数调用时arr被传入第一个参数</span><br><span class=\"line\">_.each(arr, func)</span><br><span class=\"line\">// 原型调用的时候，arr被当做参数传给_方法来创建一个实例</span><br><span class=\"line\">_(arr).each(func)</span><br><span class=\"line\">// 链式调用，和上面类似</span><br><span class=\"line\">_.chain(arr).each(func)</span><br></pre></td></tr></table></figure></p>\n<p>从上一节中我们知道，在创建一个_的实例时，会用this._wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this._wrapped];是将我们传给_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>那么上面最后return result(this, func.apply(_, args))，result又是做什么的呢？</p>\n<p>首先来看result源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = function(instance, obj) &#123;</span><br><span class=\"line\">    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果</span><br><span class=\"line\">    return instance._chain ? _(obj).chain() : obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.chain = function(obj) &#123;</span><br><span class=\"line\">    // 创建一个实例</span><br><span class=\"line\">    var instance = _(obj);</span><br><span class=\"line\">    // 给这个实例加个_chain属性来表明这是链式调用</span><br><span class=\"line\">    instance._chain = true;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = _.chain(a).map(function(item) &#123;</span><br><span class=\"line\">    return item + 1</span><br><span class=\"line\">&#125;).filter(function(item) &#123;</span><br><span class=\"line\">    return item &gt; 2</span><br><span class=\"line\">&#125;).value()</span><br></pre></td></tr></table></figure></p>\n<p>链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。<br>chain方法会用传入的obj创建一个_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。<br>链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的_实例）</p>\n<h2 id=\"数组函数\"><a href=\"#数组函数\" class=\"headerlink\" title=\"数组函数\"></a>数组函数</h2><p>underscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">    var obj = this._wrapped;</span><br><span class=\"line\">    method.apply(obj, arguments);</span><br><span class=\"line\">    // 这句是好像是为了解决ie上的bug？</span><br><span class=\"line\">    if ((name === &apos;shift&apos; || name === &apos;splice&apos;) &amp;&amp; obj.length === 0) delete obj[0];</span><br><span class=\"line\">        return result(this, obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_.each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">        return result(this, method.apply(this._wrapped, arguments));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之数组遍历函数分析（二）","date":"2018-03-20T14:13:12.000Z","_content":"## 用法 ##\n\n上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。\n在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。\n```\nvar arr = [1, 2, 3, 4];\n_.reduce(arr, function(result, item) {\n    result += item;\n    console.log(result); // 1, 3, 6, 10\n    return result;\n}, 0)\n_.reduceRight(arr, function(result, item) {\n    result += item;\n    console.log(result); // 4, 7, 9, 10\n    return result;\n}, 0)\n```\nreduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：[reduce的用法][1]\n<!-- more -->\n## createReduce实现 ##\n\n```\n_.reduce = _.foldl = _.inject = createReduce(1);\n_.reduceRight = _.foldr = createReduce(-1);\n// createReduce会根据dir的值来控制遍历方向\nfunction createReduce(dir) {\n\tfunction iterator(obj, iteratee, memo, keys, index, length) {\n\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        \n\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn memo;\n\t}\n\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文\n\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）\n\t// 如果memo有值，那么就从obj第一个元素迭代\n\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值\n\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代\n\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代\n\treturn function (obj, iteratee, memo, context) {\n\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee\n\t\titeratee = optimizeCb(iteratee, context, 4);\n\t\t\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tindex = dir > 0 ? 0 : length - 1;\n\t\t// 如果没有memo和context\n\t\tif (arguments.length < 3) {\n\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去\n\t\t\tmemo = obj[keys ? keys[index] : index];\n\t\t\tindex += dir;\n\t\t}\n\t\treturn iterator(obj, iteratee, memo, keys, index, length);\n\t};\n}\n```\ncreateReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。\n\n如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。\n\n一共就是下面四种情况：\n\n 1. 如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。\n 2. 如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。\n 3. 如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。\n 4. 如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。\n## 应用场景 ##\nreduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？\n### 深层取值 ###\n我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。\n```\nvar obj = {\n    info1: {\n        age: 20\n    }\n}\nvar age = obj.info1.age\nvar name = obj.info2.name // Cannot read property 'name' of undefined\n```\n我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 && obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&&，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。\n```\nvar get = function(obj, attrArr) {\n    return _.reduce(attrArr, function(obj, attr) {\n        return obj && obj[attr]\n    }, obj)\n}\n\n```\n我们找个例子来试试看：\n```\nvar obj = {\n\tcountry: {\n\t\tname: \"china\",\n\t\tcity: {\n\t\t\tname: \"shanghai\",\n\t\t\tstreet: {\n\t\t\t\tname: \"changning\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nget(obj, [\"name\", \"name\"]) // undefined\nget(obj, [\"country\", \"city\", \"name\"]) // \"shanghai\"\nget(obj, [\"country\", \"city\", \"street\", \"name\"]) // \"changning\"\n```\n### 数组扁平化 ###\n这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？\n```\n    var arr = [1, [2, [3, [4]]]]\n    var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]\n```\n我们可以用reduce这样写。\n```\n    var flatten = function(arr) {  \n        return _.reduce(arr, function(originArr, item) {\n            return originArr.concat(Array.isArray(item) ? flatten(item) : item)\n        }, [])\n    }\n```\n这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。\n\n  [1]: http://www.bootcss.com/p/underscore/#reduce\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之数组遍历函数分析（二）.md","raw":"---\ntitle: underscore源码剖析之数组遍历函数分析（二）\ndate: 2018-03-20 22:13:12\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n## 用法 ##\n\n上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。\n在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。\n```\nvar arr = [1, 2, 3, 4];\n_.reduce(arr, function(result, item) {\n    result += item;\n    console.log(result); // 1, 3, 6, 10\n    return result;\n}, 0)\n_.reduceRight(arr, function(result, item) {\n    result += item;\n    console.log(result); // 4, 7, 9, 10\n    return result;\n}, 0)\n```\nreduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：[reduce的用法][1]\n<!-- more -->\n## createReduce实现 ##\n\n```\n_.reduce = _.foldl = _.inject = createReduce(1);\n_.reduceRight = _.foldr = createReduce(-1);\n// createReduce会根据dir的值来控制遍历方向\nfunction createReduce(dir) {\n\tfunction iterator(obj, iteratee, memo, keys, index, length) {\n\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        \n\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn memo;\n\t}\n\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文\n\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）\n\t// 如果memo有值，那么就从obj第一个元素迭代\n\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值\n\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代\n\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代\n\treturn function (obj, iteratee, memo, context) {\n\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee\n\t\titeratee = optimizeCb(iteratee, context, 4);\n\t\t\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tindex = dir > 0 ? 0 : length - 1;\n\t\t// 如果没有memo和context\n\t\tif (arguments.length < 3) {\n\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去\n\t\t\tmemo = obj[keys ? keys[index] : index];\n\t\t\tindex += dir;\n\t\t}\n\t\treturn iterator(obj, iteratee, memo, keys, index, length);\n\t};\n}\n```\ncreateReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。\n\n如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。\n\n一共就是下面四种情况：\n\n 1. 如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。\n 2. 如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。\n 3. 如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。\n 4. 如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。\n## 应用场景 ##\nreduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？\n### 深层取值 ###\n我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。\n```\nvar obj = {\n    info1: {\n        age: 20\n    }\n}\nvar age = obj.info1.age\nvar name = obj.info2.name // Cannot read property 'name' of undefined\n```\n我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 && obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&&，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。\n```\nvar get = function(obj, attrArr) {\n    return _.reduce(attrArr, function(obj, attr) {\n        return obj && obj[attr]\n    }, obj)\n}\n\n```\n我们找个例子来试试看：\n```\nvar obj = {\n\tcountry: {\n\t\tname: \"china\",\n\t\tcity: {\n\t\t\tname: \"shanghai\",\n\t\t\tstreet: {\n\t\t\t\tname: \"changning\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nget(obj, [\"name\", \"name\"]) // undefined\nget(obj, [\"country\", \"city\", \"name\"]) // \"shanghai\"\nget(obj, [\"country\", \"city\", \"street\", \"name\"]) // \"changning\"\n```\n### 数组扁平化 ###\n这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？\n```\n    var arr = [1, [2, [3, [4]]]]\n    var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]\n```\n我们可以用reduce这样写。\n```\n    var flatten = function(arr) {  \n        return _.reduce(arr, function(originArr, item) {\n            return originArr.concat(Array.isArray(item) ? flatten(item) : item)\n        }, [])\n    }\n```\n这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。\n\n  [1]: http://www.bootcss.com/p/underscore/#reduce\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之数组遍历函数分析（二）","published":1,"updated":"2019-04-07T05:53:12.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrss000ddrfd3bl91kxb","content":"<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。<br>在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">_.reduce(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 1, 3, 6, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">_.reduceRight(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 4, 7, 9, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br></pre></td></tr></table></figure></p>\n<p>reduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：<a href=\"http://www.bootcss.com/p/underscore/#reduce\" target=\"_blank\" rel=\"noopener\">reduce的用法</a><br><a id=\"more\"></a></p>\n<h2 id=\"createReduce实现\"><a href=\"#createReduce实现\" class=\"headerlink\" title=\"createReduce实现\"></a>createReduce实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.reduce = _.foldl = _.inject = createReduce(1);</span><br><span class=\"line\">_.reduceRight = _.foldr = createReduce(-1);</span><br><span class=\"line\">// createReduce会根据dir的值来控制遍历方向</span><br><span class=\"line\">function createReduce(dir) &#123;</span><br><span class=\"line\">\tfunction iterator(obj, iteratee, memo, keys, index, length) &#123;</span><br><span class=\"line\">\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        </span><br><span class=\"line\">\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn memo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文</span><br><span class=\"line\">\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）</span><br><span class=\"line\">\t// 如果memo有值，那么就从obj第一个元素迭代</span><br><span class=\"line\">\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值</span><br><span class=\"line\">\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代</span><br><span class=\"line\">\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代</span><br><span class=\"line\">\treturn function (obj, iteratee, memo, context) &#123;</span><br><span class=\"line\">\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context, 4);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tindex = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 如果没有memo和context</span><br><span class=\"line\">\t\tif (arguments.length &lt; 3) &#123;</span><br><span class=\"line\">\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去</span><br><span class=\"line\">\t\t\tmemo = obj[keys ? keys[index] : index];</span><br><span class=\"line\">\t\t\tindex += dir;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn iterator(obj, iteratee, memo, keys, index, length);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>createReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。</p>\n<p>如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。</p>\n<p>一共就是下面四种情况：</p>\n<ol>\n<li>如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。</li>\n<li>如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。</li>\n<li>如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。</li>\n<li>如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2>reduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？<h3 id=\"深层取值\"><a href=\"#深层取值\" class=\"headerlink\" title=\"深层取值\"></a>深层取值</h3>我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    info1: &#123;</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = obj.info1.age</span><br><span class=\"line\">var name = obj.info2.name // Cannot read property &apos;name&apos; of undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 &amp;&amp; obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&amp;&amp;，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var get = function(obj, attrArr) &#123;</span><br><span class=\"line\">    return _.reduce(attrArr, function(obj, attr) &#123;</span><br><span class=\"line\">        return obj &amp;&amp; obj[attr]</span><br><span class=\"line\">    &#125;, obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们找个例子来试试看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\tcountry: &#123;</span><br><span class=\"line\">\t\tname: &quot;china&quot;,</span><br><span class=\"line\">\t\tcity: &#123;</span><br><span class=\"line\">\t\t\tname: &quot;shanghai&quot;,</span><br><span class=\"line\">\t\t\tstreet: &#123;</span><br><span class=\"line\">\t\t\t\tname: &quot;changning&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">get(obj, [&quot;name&quot;, &quot;name&quot;]) // undefined</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;name&quot;]) // &quot;shanghai&quot;</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;street&quot;, &quot;name&quot;]) // &quot;changning&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><p>这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, [2, [3, [4]]]]</span><br><span class=\"line\">var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]</span><br></pre></td></tr></table></figure></p>\n<p>我们可以用reduce这样写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flatten = function(arr) &#123;  </span><br><span class=\"line\">    return _.reduce(arr, function(originArr, item) &#123;</span><br><span class=\"line\">        return originArr.concat(Array.isArray(item) ? flatten(item) : item)</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。<br>在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">_.reduce(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 1, 3, 6, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">_.reduceRight(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 4, 7, 9, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br></pre></td></tr></table></figure></p>\n<p>reduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：<a href=\"http://www.bootcss.com/p/underscore/#reduce\" target=\"_blank\" rel=\"noopener\">reduce的用法</a><br>","more":"</p>\n<h2 id=\"createReduce实现\"><a href=\"#createReduce实现\" class=\"headerlink\" title=\"createReduce实现\"></a>createReduce实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.reduce = _.foldl = _.inject = createReduce(1);</span><br><span class=\"line\">_.reduceRight = _.foldr = createReduce(-1);</span><br><span class=\"line\">// createReduce会根据dir的值来控制遍历方向</span><br><span class=\"line\">function createReduce(dir) &#123;</span><br><span class=\"line\">\tfunction iterator(obj, iteratee, memo, keys, index, length) &#123;</span><br><span class=\"line\">\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        </span><br><span class=\"line\">\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn memo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文</span><br><span class=\"line\">\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）</span><br><span class=\"line\">\t// 如果memo有值，那么就从obj第一个元素迭代</span><br><span class=\"line\">\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值</span><br><span class=\"line\">\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代</span><br><span class=\"line\">\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代</span><br><span class=\"line\">\treturn function (obj, iteratee, memo, context) &#123;</span><br><span class=\"line\">\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context, 4);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tindex = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 如果没有memo和context</span><br><span class=\"line\">\t\tif (arguments.length &lt; 3) &#123;</span><br><span class=\"line\">\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去</span><br><span class=\"line\">\t\t\tmemo = obj[keys ? keys[index] : index];</span><br><span class=\"line\">\t\t\tindex += dir;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn iterator(obj, iteratee, memo, keys, index, length);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>createReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。</p>\n<p>如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。</p>\n<p>一共就是下面四种情况：</p>\n<ol>\n<li>如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。</li>\n<li>如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。</li>\n<li>如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。</li>\n<li>如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2>reduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？<h3 id=\"深层取值\"><a href=\"#深层取值\" class=\"headerlink\" title=\"深层取值\"></a>深层取值</h3>我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    info1: &#123;</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = obj.info1.age</span><br><span class=\"line\">var name = obj.info2.name // Cannot read property &apos;name&apos; of undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 &amp;&amp; obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&amp;&amp;，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var get = function(obj, attrArr) &#123;</span><br><span class=\"line\">    return _.reduce(attrArr, function(obj, attr) &#123;</span><br><span class=\"line\">        return obj &amp;&amp; obj[attr]</span><br><span class=\"line\">    &#125;, obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们找个例子来试试看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\tcountry: &#123;</span><br><span class=\"line\">\t\tname: &quot;china&quot;,</span><br><span class=\"line\">\t\tcity: &#123;</span><br><span class=\"line\">\t\t\tname: &quot;shanghai&quot;,</span><br><span class=\"line\">\t\t\tstreet: &#123;</span><br><span class=\"line\">\t\t\t\tname: &quot;changning&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">get(obj, [&quot;name&quot;, &quot;name&quot;]) // undefined</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;name&quot;]) // &quot;shanghai&quot;</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;street&quot;, &quot;name&quot;]) // &quot;changning&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><p>这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, [2, [3, [4]]]]</span><br><span class=\"line\">var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]</span><br></pre></td></tr></table></figure></p>\n<p>我们可以用reduce这样写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flatten = function(arr) &#123;  </span><br><span class=\"line\">    return _.reduce(arr, function(originArr, item) &#123;</span><br><span class=\"line\">        return originArr.concat(Array.isArray(item) ? flatten(item) : item)</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"《守望者》观后感","date":"2018-02-21T07:11:12.000Z","_content":"在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。\n我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房全靠特效砸，完全没有给观众留下任何值得思考回味的价值。\n<!-- more -->\n在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。\n而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。\n即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。\n法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。\n现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下\n《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。\n","source":"_posts/《守望者》观后感.md","raw":"---\ntitle: 《守望者》观后感\ndate: 2018-02-21 15:11:12\ntags:\n    - 影评\n    - 观后感\n    - 个人笔记\ncategories:\n    - 电影\n---\n在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。\n我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房全靠特效砸，完全没有给观众留下任何值得思考回味的价值。\n<!-- more -->\n在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。\n而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。\n即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。\n法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。\n现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下\n《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。\n","slug":"《守望者》观后感","published":1,"updated":"2019-04-07T05:55:40.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrsy000hdrfdlrmnpw1c","content":"<p>在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。<br>我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房全靠特效砸，完全没有给观众留下任何值得思考回味的价值。<br><a id=\"more\"></a><br>在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。<br>而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。<br>即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。<br>法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。<br>现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下<br>《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。</p>\n","site":{"data":{}},"excerpt":"<p>在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。<br>我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房全靠特效砸，完全没有给观众留下任何值得思考回味的价值。<br>","more":"<br>在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。<br>而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。<br>即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。<br>法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。<br>现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下<br>《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。</p>"},{"title":"《编写可维护的JS》笔记","date":"2018-07-07T15:28:19.000Z","_content":"\n这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。\n## 编程风格\n### 格式化\n\n 1. 一行代码长度一般不超过80个字符\n 2. JS语句在换行的时候一般需要两个缩进\n 3. 在语义不相关的JS语句之间空行\n 4. 避免没有意义的函数/变量命名，如foo、tmp等等\n 5. 使用大写来定义常量\n\n### 注释\n 1. 多行注释使用/* */\n 2. hack注释\n<!-- more -->\n### 语句和表达式\n\n 1. 语句最好不要不带花括号\n 2. 严格模式下使用with语句会报错\n 3. 尽量避免在循环中使用continue\n 4. for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链\n 5. 严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中\n 6. 如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==\n 7. 避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中\n 8. 避免使用原始包装类型，如new String\n\n## 编程实践\n### UI层的松耦合\n\n 1. 避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替\n\n### 避免使用全局变量\n\n 1. 尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试\n 2. 尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面\n```javascript\n// 创建命名空间\nvar yourGlobal = {\n    namespace: function(ns) {\n        var paths = ns && ns.split(\".\") || [],\n            self = this\n        paths.reduce(function(result, currentAttr) {\n            self[result] = self[result] || {}\n            return self[result][currentAttr] = self[result][currentAttr] || {}\n        })  \n    }\n}\n// yourGlobal.a.b就是一个命名空间\nyourGlobal.namespace(\"a.b\")\nyourGlobal.a.b.c = 0\nconsole.log(yourGlobal.a.b)\n```\n\n### 事件处理\n\n 1. 事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试\n 2. 不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试\n\n### 避免空比较\n\n 1. 避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型\n 2. 检查引用值类型的时候使用instanceof方法\n\n### 将配置数据从代码中抽离\n### 抛出自定义错误\n\n 1. 针对会引发错误的场景，将错误抛出（throw），有利于调试\n\n### 不是你的对象不要动\n\n 1. 不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象\n 2. 对待已存在的对象应该不覆盖方法、不新增方法、不删除方法\n 3. 如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作\n 4. 使用[门面模式][1]，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为\n 5. 禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展\n 6. 密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封\n 7. 冻结对象Object.freeze()，禁止删除、增加和修改对象\n\n### 浏览器嗅探\n\n 1. 不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById\n 2. 避免使用浏览器推断和特性推断，尽量使用特性检测\n\n### 自动化\n### 文件和目录结构\n\n 1. 保持一个文件只有一个对象（组件？类？）\n 2. 相关的文件用目录分组\n 3. 保持第三方代码独立（npm了解一下？）\n 4. 目录结构（build、src、test）\n### 校验\n这几章使用的工具比较过时了，建议直接学习webpack\n### 压缩\n 5. 现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型\n 6. apache2和nginx内置了gzip作为http压缩\n### 文档化\n### 自动化测试\n书上的内容也比较老的，建议使用jest和mocha\n### 组装到一起\n 1. 编制打包计划\n 2. 开发版本的构建\n 3. 集成版本的构建\n 4. 发布版本的构建\n 5. 使用CI系统\n\n  [1]: http://www.cnblogs.com/skywang/articles/1375447.html","source":"_posts/《编写可维护的JS》笔记.md","raw":"---\ntitle: 《编写可维护的JS》笔记\ndate: 2018-07-07 23:28:19\ntags:\n    - 读书笔记\n    - 前端\ncategories:\n    - 前端\n---\n\n这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。\n## 编程风格\n### 格式化\n\n 1. 一行代码长度一般不超过80个字符\n 2. JS语句在换行的时候一般需要两个缩进\n 3. 在语义不相关的JS语句之间空行\n 4. 避免没有意义的函数/变量命名，如foo、tmp等等\n 5. 使用大写来定义常量\n\n### 注释\n 1. 多行注释使用/* */\n 2. hack注释\n<!-- more -->\n### 语句和表达式\n\n 1. 语句最好不要不带花括号\n 2. 严格模式下使用with语句会报错\n 3. 尽量避免在循环中使用continue\n 4. for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链\n 5. 严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中\n 6. 如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==\n 7. 避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中\n 8. 避免使用原始包装类型，如new String\n\n## 编程实践\n### UI层的松耦合\n\n 1. 避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替\n\n### 避免使用全局变量\n\n 1. 尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试\n 2. 尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面\n```javascript\n// 创建命名空间\nvar yourGlobal = {\n    namespace: function(ns) {\n        var paths = ns && ns.split(\".\") || [],\n            self = this\n        paths.reduce(function(result, currentAttr) {\n            self[result] = self[result] || {}\n            return self[result][currentAttr] = self[result][currentAttr] || {}\n        })  \n    }\n}\n// yourGlobal.a.b就是一个命名空间\nyourGlobal.namespace(\"a.b\")\nyourGlobal.a.b.c = 0\nconsole.log(yourGlobal.a.b)\n```\n\n### 事件处理\n\n 1. 事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试\n 2. 不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试\n\n### 避免空比较\n\n 1. 避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型\n 2. 检查引用值类型的时候使用instanceof方法\n\n### 将配置数据从代码中抽离\n### 抛出自定义错误\n\n 1. 针对会引发错误的场景，将错误抛出（throw），有利于调试\n\n### 不是你的对象不要动\n\n 1. 不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象\n 2. 对待已存在的对象应该不覆盖方法、不新增方法、不删除方法\n 3. 如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作\n 4. 使用[门面模式][1]，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为\n 5. 禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展\n 6. 密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封\n 7. 冻结对象Object.freeze()，禁止删除、增加和修改对象\n\n### 浏览器嗅探\n\n 1. 不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById\n 2. 避免使用浏览器推断和特性推断，尽量使用特性检测\n\n### 自动化\n### 文件和目录结构\n\n 1. 保持一个文件只有一个对象（组件？类？）\n 2. 相关的文件用目录分组\n 3. 保持第三方代码独立（npm了解一下？）\n 4. 目录结构（build、src、test）\n### 校验\n这几章使用的工具比较过时了，建议直接学习webpack\n### 压缩\n 5. 现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型\n 6. apache2和nginx内置了gzip作为http压缩\n### 文档化\n### 自动化测试\n书上的内容也比较老的，建议使用jest和mocha\n### 组装到一起\n 1. 编制打包计划\n 2. 开发版本的构建\n 3. 集成版本的构建\n 4. 发布版本的构建\n 5. 使用CI系统\n\n  [1]: http://www.cnblogs.com/skywang/articles/1375447.html","slug":"《编写可维护的JS》笔记","published":1,"updated":"2019-04-07T05:53:12.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt0000jdrfd02ml5ft6","content":"<p>这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。</p>\n<h2 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h2><h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><ol>\n<li>一行代码长度一般不超过80个字符</li>\n<li>JS语句在换行的时候一般需要两个缩进</li>\n<li>在语义不相关的JS语句之间空行</li>\n<li>避免没有意义的函数/变量命名，如foo、tmp等等</li>\n<li>使用大写来定义常量</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ol>\n<li>多行注释使用/<em> </em>/</li>\n<li><p>hack注释</p>\n<a id=\"more\"></a>\n<h3 id=\"语句和表达式\"><a href=\"#语句和表达式\" class=\"headerlink\" title=\"语句和表达式\"></a>语句和表达式</h3></li>\n<li><p>语句最好不要不带花括号</p>\n</li>\n<li>严格模式下使用with语句会报错</li>\n<li>尽量避免在循环中使用continue</li>\n<li>for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链</li>\n<li>严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中</li>\n<li>如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==</li>\n<li>避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中</li>\n<li>避免使用原始包装类型，如new String</li>\n</ol>\n<h2 id=\"编程实践\"><a href=\"#编程实践\" class=\"headerlink\" title=\"编程实践\"></a>编程实践</h2><h3 id=\"UI层的松耦合\"><a href=\"#UI层的松耦合\" class=\"headerlink\" title=\"UI层的松耦合\"></a>UI层的松耦合</h3><ol>\n<li>避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替</li>\n</ol>\n<h3 id=\"避免使用全局变量\"><a href=\"#避免使用全局变量\" class=\"headerlink\" title=\"避免使用全局变量\"></a>避免使用全局变量</h3><ol>\n<li>尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试</li>\n<li>尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> yourGlobal = &#123;</span><br><span class=\"line\">    namespace: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ns</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> paths = ns &amp;&amp; ns.split(<span class=\"string\">\".\"</span>) || [],</span><br><span class=\"line\">            self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        paths.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, currentAttr</span>) </span>&#123;</span><br><span class=\"line\">            self[result] = self[result] || &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[result][currentAttr] = self[result][currentAttr] || &#123;&#125;</span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// yourGlobal.a.b就是一个命名空间</span></span><br><span class=\"line\">yourGlobal.namespace(<span class=\"string\">\"a.b\"</span>)</span><br><span class=\"line\">yourGlobal.a.b.c = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(yourGlobal.a.b)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><ol>\n<li>事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试</li>\n<li>不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试</li>\n</ol>\n<h3 id=\"避免空比较\"><a href=\"#避免空比较\" class=\"headerlink\" title=\"避免空比较\"></a>避免空比较</h3><ol>\n<li>避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型</li>\n<li>检查引用值类型的时候使用instanceof方法</li>\n</ol>\n<h3 id=\"将配置数据从代码中抽离\"><a href=\"#将配置数据从代码中抽离\" class=\"headerlink\" title=\"将配置数据从代码中抽离\"></a>将配置数据从代码中抽离</h3><h3 id=\"抛出自定义错误\"><a href=\"#抛出自定义错误\" class=\"headerlink\" title=\"抛出自定义错误\"></a>抛出自定义错误</h3><ol>\n<li>针对会引发错误的场景，将错误抛出（throw），有利于调试</li>\n</ol>\n<h3 id=\"不是你的对象不要动\"><a href=\"#不是你的对象不要动\" class=\"headerlink\" title=\"不是你的对象不要动\"></a>不是你的对象不要动</h3><ol>\n<li>不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象</li>\n<li>对待已存在的对象应该不覆盖方法、不新增方法、不删除方法</li>\n<li>如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作</li>\n<li>使用<a href=\"http://www.cnblogs.com/skywang/articles/1375447.html\" target=\"_blank\" rel=\"noopener\">门面模式</a>，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为</li>\n<li>禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展</li>\n<li>密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封</li>\n<li>冻结对象Object.freeze()，禁止删除、增加和修改对象</li>\n</ol>\n<h3 id=\"浏览器嗅探\"><a href=\"#浏览器嗅探\" class=\"headerlink\" title=\"浏览器嗅探\"></a>浏览器嗅探</h3><ol>\n<li>不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById</li>\n<li>避免使用浏览器推断和特性推断，尽量使用特性检测</li>\n</ol>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><h3 id=\"文件和目录结构\"><a href=\"#文件和目录结构\" class=\"headerlink\" title=\"文件和目录结构\"></a>文件和目录结构</h3><ol>\n<li>保持一个文件只有一个对象（组件？类？）</li>\n<li>相关的文件用目录分组</li>\n<li>保持第三方代码独立（npm了解一下？）</li>\n<li>目录结构（build、src、test）<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3>这几章使用的工具比较过时了，建议直接学习webpack<h3 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h3></li>\n<li>现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型</li>\n<li>apache2和nginx内置了gzip作为http压缩<h3 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3>书上的内容也比较老的，建议使用jest和mocha<h3 id=\"组装到一起\"><a href=\"#组装到一起\" class=\"headerlink\" title=\"组装到一起\"></a>组装到一起</h3></li>\n<li>编制打包计划</li>\n<li>开发版本的构建</li>\n<li>集成版本的构建</li>\n<li>发布版本的构建</li>\n<li>使用CI系统</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。</p>\n<h2 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h2><h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><ol>\n<li>一行代码长度一般不超过80个字符</li>\n<li>JS语句在换行的时候一般需要两个缩进</li>\n<li>在语义不相关的JS语句之间空行</li>\n<li>避免没有意义的函数/变量命名，如foo、tmp等等</li>\n<li>使用大写来定义常量</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ol>\n<li>多行注释使用/<em> </em>/</li>\n<li><p>hack注释</p>","more":"<h3 id=\"语句和表达式\"><a href=\"#语句和表达式\" class=\"headerlink\" title=\"语句和表达式\"></a>语句和表达式</h3></li>\n<li><p>语句最好不要不带花括号</p>\n</li>\n<li>严格模式下使用with语句会报错</li>\n<li>尽量避免在循环中使用continue</li>\n<li>for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链</li>\n<li>严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中</li>\n<li>如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==</li>\n<li>避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中</li>\n<li>避免使用原始包装类型，如new String</li>\n</ol>\n<h2 id=\"编程实践\"><a href=\"#编程实践\" class=\"headerlink\" title=\"编程实践\"></a>编程实践</h2><h3 id=\"UI层的松耦合\"><a href=\"#UI层的松耦合\" class=\"headerlink\" title=\"UI层的松耦合\"></a>UI层的松耦合</h3><ol>\n<li>避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替</li>\n</ol>\n<h3 id=\"避免使用全局变量\"><a href=\"#避免使用全局变量\" class=\"headerlink\" title=\"避免使用全局变量\"></a>避免使用全局变量</h3><ol>\n<li>尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试</li>\n<li>尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> yourGlobal = &#123;</span><br><span class=\"line\">    namespace: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ns</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> paths = ns &amp;&amp; ns.split(<span class=\"string\">\".\"</span>) || [],</span><br><span class=\"line\">            self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        paths.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, currentAttr</span>) </span>&#123;</span><br><span class=\"line\">            self[result] = self[result] || &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[result][currentAttr] = self[result][currentAttr] || &#123;&#125;</span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// yourGlobal.a.b就是一个命名空间</span></span><br><span class=\"line\">yourGlobal.namespace(<span class=\"string\">\"a.b\"</span>)</span><br><span class=\"line\">yourGlobal.a.b.c = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(yourGlobal.a.b)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><ol>\n<li>事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试</li>\n<li>不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试</li>\n</ol>\n<h3 id=\"避免空比较\"><a href=\"#避免空比较\" class=\"headerlink\" title=\"避免空比较\"></a>避免空比较</h3><ol>\n<li>避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型</li>\n<li>检查引用值类型的时候使用instanceof方法</li>\n</ol>\n<h3 id=\"将配置数据从代码中抽离\"><a href=\"#将配置数据从代码中抽离\" class=\"headerlink\" title=\"将配置数据从代码中抽离\"></a>将配置数据从代码中抽离</h3><h3 id=\"抛出自定义错误\"><a href=\"#抛出自定义错误\" class=\"headerlink\" title=\"抛出自定义错误\"></a>抛出自定义错误</h3><ol>\n<li>针对会引发错误的场景，将错误抛出（throw），有利于调试</li>\n</ol>\n<h3 id=\"不是你的对象不要动\"><a href=\"#不是你的对象不要动\" class=\"headerlink\" title=\"不是你的对象不要动\"></a>不是你的对象不要动</h3><ol>\n<li>不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象</li>\n<li>对待已存在的对象应该不覆盖方法、不新增方法、不删除方法</li>\n<li>如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作</li>\n<li>使用<a href=\"http://www.cnblogs.com/skywang/articles/1375447.html\" target=\"_blank\" rel=\"noopener\">门面模式</a>，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为</li>\n<li>禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展</li>\n<li>密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封</li>\n<li>冻结对象Object.freeze()，禁止删除、增加和修改对象</li>\n</ol>\n<h3 id=\"浏览器嗅探\"><a href=\"#浏览器嗅探\" class=\"headerlink\" title=\"浏览器嗅探\"></a>浏览器嗅探</h3><ol>\n<li>不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById</li>\n<li>避免使用浏览器推断和特性推断，尽量使用特性检测</li>\n</ol>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><h3 id=\"文件和目录结构\"><a href=\"#文件和目录结构\" class=\"headerlink\" title=\"文件和目录结构\"></a>文件和目录结构</h3><ol>\n<li>保持一个文件只有一个对象（组件？类？）</li>\n<li>相关的文件用目录分组</li>\n<li>保持第三方代码独立（npm了解一下？）</li>\n<li>目录结构（build、src、test）<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3>这几章使用的工具比较过时了，建议直接学习webpack<h3 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h3></li>\n<li>现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型</li>\n<li>apache2和nginx内置了gzip作为http压缩<h3 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3>书上的内容也比较老的，建议使用jest和mocha<h3 id=\"组装到一起\"><a href=\"#组装到一起\" class=\"headerlink\" title=\"组装到一起\"></a>组装到一起</h3></li>\n<li>编制打包计划</li>\n<li>开发版本的构建</li>\n<li>集成版本的构建</li>\n<li>发布版本的构建</li>\n<li>使用CI系统</li>\n</ol>"},{"title":"为什么活着","date":"2015-02-25T06:27:20.000Z","_content":"人活着的意义是什么？你感觉活着无聊吗？你为什么要活着？\n\n最近看了诺兰的蝙蝠侠三部曲，感触很大。布鲁斯身为一个富二代，目睹父母的死，但是又对黑暗的社会现状无可奈何，对未来很迷失的他，为了寻找打击罪犯的方法，自愿和囚犯们生活在一起，体会他们的生活，又到影武者联盟磨练自己的意志，最终化身黑暗骑士忍受一切来保护哥谭市。\n\n可是我，却一直在迷失方向。\n\n不想像普通人那样碌碌无为一辈子，一直把自己放在一个太高的位置，所以自己慢慢庸碌的时候不断摔倒。\n\n可以说我努力不够，但是更多的是不知道往哪努力。我对未来没有很明确的打算，更别提人生了。\n\n以前老是想到自己毕业后就要面对找工作的压力，面对买房结婚的压力，心想人在世上为什么要活的这么累。尤其经过一次恋爱后，心很累，变得自暴自弃。  \n\n记得有人说过“迷茫就是才华配不上梦想”。现在回头想想我的大学，我没有大学霸们那样的高绩点，也没有大神们那样好的技术，甚至也没有“交际花”们那样四海之内皆兄弟。我错过了很多东西。但是每次去努力的时候，心总是被懒惰和浮躁占据了，梦想也慢慢在乱七八糟无关紧要的事情上被消磨掉了。\n\n大一的时候为了找出自己活着的意义，开始去图书馆看一些哲学，但是感觉晦涩难懂。大二上学期的时候被人推荐了《金刚经》，后来为了送一个朋友手抄《金刚经》当生日礼物，在自习室一边看书一边抄佛经，我想从佛经中找出一些修“心”的方法，从而大彻大悟。失恋后的这段时间我更加消极，慢慢自暴自弃，甚至极少吃饭。后来觉得自己这样真的不能这么堕落，我不需要任何人的同情。为了平静下来，想了很多办法都没有用，后来想起了上学期一直看的《般若波罗蜜多心经》，然后就继续看，慢慢的也领悟到了佛家所说的“空”，这些无非是自己的心魔，虽然她始终是我的软肋，但是我也不会很在乎了。\n\n现在明白了，有时候既然不知道该做什么，那么不如喜欢什么就去做，不喜欢就不去做呗。\n  \n\n就像之前的恋爱，虽然甜蜜，但是也让我很累很累，或许我更适合单身吧，即使她不提出分手，我想我早晚也会厌烦的，因为难以平衡两个人的生活。\n\n人生短暂，无非要活的开心，活的精彩，不刻意追求，不逃避现实。\n\n心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。佛家追求五蕴皆空的那种无上大涅槃境界，一切都要以无所求心，无住的心，来面对凡夫和圣者的生活境界。\n\n心怀天下，忧国忧民不是每个人都能做到的。但是，我们能做到的最基本的应该是让自己活得精彩。数年之后，即使自己碌碌无为，也不会因为自己浪费了时间而后悔吧。\n\n世界远比你想象的精彩，未来也远比你想象的光明。\n\n\n所以，打开房门多出去走走，多去看看世界吧。\n\n为什么活着？当然是为了活着而活着啊。\n\n","source":"_posts/为什么活着.md","raw":"---\ntitle: 为什么活着\ndate: 2015-02-25 14:27:20\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n人活着的意义是什么？你感觉活着无聊吗？你为什么要活着？\n\n最近看了诺兰的蝙蝠侠三部曲，感触很大。布鲁斯身为一个富二代，目睹父母的死，但是又对黑暗的社会现状无可奈何，对未来很迷失的他，为了寻找打击罪犯的方法，自愿和囚犯们生活在一起，体会他们的生活，又到影武者联盟磨练自己的意志，最终化身黑暗骑士忍受一切来保护哥谭市。\n\n可是我，却一直在迷失方向。\n\n不想像普通人那样碌碌无为一辈子，一直把自己放在一个太高的位置，所以自己慢慢庸碌的时候不断摔倒。\n\n可以说我努力不够，但是更多的是不知道往哪努力。我对未来没有很明确的打算，更别提人生了。\n\n以前老是想到自己毕业后就要面对找工作的压力，面对买房结婚的压力，心想人在世上为什么要活的这么累。尤其经过一次恋爱后，心很累，变得自暴自弃。  \n\n记得有人说过“迷茫就是才华配不上梦想”。现在回头想想我的大学，我没有大学霸们那样的高绩点，也没有大神们那样好的技术，甚至也没有“交际花”们那样四海之内皆兄弟。我错过了很多东西。但是每次去努力的时候，心总是被懒惰和浮躁占据了，梦想也慢慢在乱七八糟无关紧要的事情上被消磨掉了。\n\n大一的时候为了找出自己活着的意义，开始去图书馆看一些哲学，但是感觉晦涩难懂。大二上学期的时候被人推荐了《金刚经》，后来为了送一个朋友手抄《金刚经》当生日礼物，在自习室一边看书一边抄佛经，我想从佛经中找出一些修“心”的方法，从而大彻大悟。失恋后的这段时间我更加消极，慢慢自暴自弃，甚至极少吃饭。后来觉得自己这样真的不能这么堕落，我不需要任何人的同情。为了平静下来，想了很多办法都没有用，后来想起了上学期一直看的《般若波罗蜜多心经》，然后就继续看，慢慢的也领悟到了佛家所说的“空”，这些无非是自己的心魔，虽然她始终是我的软肋，但是我也不会很在乎了。\n\n现在明白了，有时候既然不知道该做什么，那么不如喜欢什么就去做，不喜欢就不去做呗。\n  \n\n就像之前的恋爱，虽然甜蜜，但是也让我很累很累，或许我更适合单身吧，即使她不提出分手，我想我早晚也会厌烦的，因为难以平衡两个人的生活。\n\n人生短暂，无非要活的开心，活的精彩，不刻意追求，不逃避现实。\n\n心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。佛家追求五蕴皆空的那种无上大涅槃境界，一切都要以无所求心，无住的心，来面对凡夫和圣者的生活境界。\n\n心怀天下，忧国忧民不是每个人都能做到的。但是，我们能做到的最基本的应该是让自己活得精彩。数年之后，即使自己碌碌无为，也不会因为自己浪费了时间而后悔吧。\n\n世界远比你想象的精彩，未来也远比你想象的光明。\n\n\n所以，打开房门多出去走走，多去看看世界吧。\n\n为什么活着？当然是为了活着而活着啊。\n\n","slug":"为什么活着","published":1,"updated":"2019-04-07T05:53:12.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt2000ndrfd5xvclr7s","content":"<p>人活着的意义是什么？你感觉活着无聊吗？你为什么要活着？</p>\n<p>最近看了诺兰的蝙蝠侠三部曲，感触很大。布鲁斯身为一个富二代，目睹父母的死，但是又对黑暗的社会现状无可奈何，对未来很迷失的他，为了寻找打击罪犯的方法，自愿和囚犯们生活在一起，体会他们的生活，又到影武者联盟磨练自己的意志，最终化身黑暗骑士忍受一切来保护哥谭市。</p>\n<p>可是我，却一直在迷失方向。</p>\n<p>不想像普通人那样碌碌无为一辈子，一直把自己放在一个太高的位置，所以自己慢慢庸碌的时候不断摔倒。</p>\n<p>可以说我努力不够，但是更多的是不知道往哪努力。我对未来没有很明确的打算，更别提人生了。</p>\n<p>以前老是想到自己毕业后就要面对找工作的压力，面对买房结婚的压力，心想人在世上为什么要活的这么累。尤其经过一次恋爱后，心很累，变得自暴自弃。  </p>\n<p>记得有人说过“迷茫就是才华配不上梦想”。现在回头想想我的大学，我没有大学霸们那样的高绩点，也没有大神们那样好的技术，甚至也没有“交际花”们那样四海之内皆兄弟。我错过了很多东西。但是每次去努力的时候，心总是被懒惰和浮躁占据了，梦想也慢慢在乱七八糟无关紧要的事情上被消磨掉了。</p>\n<p>大一的时候为了找出自己活着的意义，开始去图书馆看一些哲学，但是感觉晦涩难懂。大二上学期的时候被人推荐了《金刚经》，后来为了送一个朋友手抄《金刚经》当生日礼物，在自习室一边看书一边抄佛经，我想从佛经中找出一些修“心”的方法，从而大彻大悟。失恋后的这段时间我更加消极，慢慢自暴自弃，甚至极少吃饭。后来觉得自己这样真的不能这么堕落，我不需要任何人的同情。为了平静下来，想了很多办法都没有用，后来想起了上学期一直看的《般若波罗蜜多心经》，然后就继续看，慢慢的也领悟到了佛家所说的“空”，这些无非是自己的心魔，虽然她始终是我的软肋，但是我也不会很在乎了。</p>\n<p>现在明白了，有时候既然不知道该做什么，那么不如喜欢什么就去做，不喜欢就不去做呗。</p>\n<p>就像之前的恋爱，虽然甜蜜，但是也让我很累很累，或许我更适合单身吧，即使她不提出分手，我想我早晚也会厌烦的，因为难以平衡两个人的生活。</p>\n<p>人生短暂，无非要活的开心，活的精彩，不刻意追求，不逃避现实。</p>\n<p>心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。佛家追求五蕴皆空的那种无上大涅槃境界，一切都要以无所求心，无住的心，来面对凡夫和圣者的生活境界。</p>\n<p>心怀天下，忧国忧民不是每个人都能做到的。但是，我们能做到的最基本的应该是让自己活得精彩。数年之后，即使自己碌碌无为，也不会因为自己浪费了时间而后悔吧。</p>\n<p>世界远比你想象的精彩，未来也远比你想象的光明。</p>\n<p>所以，打开房门多出去走走，多去看看世界吧。</p>\n<p>为什么活着？当然是为了活着而活着啊。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>人活着的意义是什么？你感觉活着无聊吗？你为什么要活着？</p>\n<p>最近看了诺兰的蝙蝠侠三部曲，感触很大。布鲁斯身为一个富二代，目睹父母的死，但是又对黑暗的社会现状无可奈何，对未来很迷失的他，为了寻找打击罪犯的方法，自愿和囚犯们生活在一起，体会他们的生活，又到影武者联盟磨练自己的意志，最终化身黑暗骑士忍受一切来保护哥谭市。</p>\n<p>可是我，却一直在迷失方向。</p>\n<p>不想像普通人那样碌碌无为一辈子，一直把自己放在一个太高的位置，所以自己慢慢庸碌的时候不断摔倒。</p>\n<p>可以说我努力不够，但是更多的是不知道往哪努力。我对未来没有很明确的打算，更别提人生了。</p>\n<p>以前老是想到自己毕业后就要面对找工作的压力，面对买房结婚的压力，心想人在世上为什么要活的这么累。尤其经过一次恋爱后，心很累，变得自暴自弃。  </p>\n<p>记得有人说过“迷茫就是才华配不上梦想”。现在回头想想我的大学，我没有大学霸们那样的高绩点，也没有大神们那样好的技术，甚至也没有“交际花”们那样四海之内皆兄弟。我错过了很多东西。但是每次去努力的时候，心总是被懒惰和浮躁占据了，梦想也慢慢在乱七八糟无关紧要的事情上被消磨掉了。</p>\n<p>大一的时候为了找出自己活着的意义，开始去图书馆看一些哲学，但是感觉晦涩难懂。大二上学期的时候被人推荐了《金刚经》，后来为了送一个朋友手抄《金刚经》当生日礼物，在自习室一边看书一边抄佛经，我想从佛经中找出一些修“心”的方法，从而大彻大悟。失恋后的这段时间我更加消极，慢慢自暴自弃，甚至极少吃饭。后来觉得自己这样真的不能这么堕落，我不需要任何人的同情。为了平静下来，想了很多办法都没有用，后来想起了上学期一直看的《般若波罗蜜多心经》，然后就继续看，慢慢的也领悟到了佛家所说的“空”，这些无非是自己的心魔，虽然她始终是我的软肋，但是我也不会很在乎了。</p>\n<p>现在明白了，有时候既然不知道该做什么，那么不如喜欢什么就去做，不喜欢就不去做呗。</p>\n<p>就像之前的恋爱，虽然甜蜜，但是也让我很累很累，或许我更适合单身吧，即使她不提出分手，我想我早晚也会厌烦的，因为难以平衡两个人的生活。</p>\n<p>人生短暂，无非要活的开心，活的精彩，不刻意追求，不逃避现实。</p>\n<p>心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。佛家追求五蕴皆空的那种无上大涅槃境界，一切都要以无所求心，无住的心，来面对凡夫和圣者的生活境界。</p>\n<p>心怀天下，忧国忧民不是每个人都能做到的。但是，我们能做到的最基本的应该是让自己活得精彩。数年之后，即使自己碌碌无为，也不会因为自己浪费了时间而后悔吧。</p>\n<p>世界远比你想象的精彩，未来也远比你想象的光明。</p>\n<p>所以，打开房门多出去走走，多去看看世界吧。</p>\n<p>为什么活着？当然是为了活着而活着啊。</p>\n"},{"title":"再见，携程","date":"2019-03-14T05:47:02.000Z","_content":"## 前言\n从16年校招就开始与携程结缘，17年毕业后加入携程至今。在这短暂的一年多时间里，我受益匪浅，很感谢携程的培养，希望携程能越做越好。\n\n## 初次相遇\n时间回到2016年9月，我正在为校招找工作的事情急得团团转。由于对面试缺少准备，也错过了内推，又一直挂在笔试上，每天压力大到睡不着。\n\n恰好那个时候，我收到了携程的面试电话，虽然对携程这家公司没有太多好感，但还是抱着试试的心态去参加了面试。\n\n面试官是个温柔、和蔼的人，问了我一些问题，给我耐心地讲了这边的业务和技术栈。\n\n后来我才知道，这位面试官是度假BU的前端老大 —— 路总。\n<!-- more -->\n## 热恋期\n刚毕业的时候，我总是带着一股学生气，心理不够强大，也过于任性，总是被需求折腾的崩溃了，还好有同事包容着。\n\n记得刚来这边的时候，我们做的还是老自由行项目，可以说是历史遗留技术债了，对于刚毕业的我来说，阅读前人代码非常吃力。原本很简单的需求，我总是要花很多天才能完成，对自己打击也比较大。\n\n后来老大让我智伟带一下我，我还记得在这边写的第一个新页面是门票详情页。是的，那一个页面我写了整整一个多月，智伟总会指出我哪里写的不好，我也会和他讨论哪种实现更好，很感激他的耐心。\n\n大概在工作三个月后，这边的技术栈全面更新，从原来的lizard+react换成了映杰大佬的react-imvc，这是一个集成了react、状态管理、路由和同构的框架，功能很强大，也很实用。\n\n得益于react-imvc这个新框架，我们也随便将原来的项目迁移到新的技术栈上。DP2.0一期的时候我几乎每天都在加班，每周末都在加班，一边赶工，一边思考怎么实现功能，累并快乐着。（现在回头看，当时的代码写的不忍直视）\n\n那时候的我，对这一切都感觉很新鲜，每天都在不断地吸收新的知识。\n\n## 平淡期\n转眼间，2017年就过去了，我也从一个刚毕业时懵懂的学生变成了一个稍微有些经验的社会人了。\n\n没有了刚毕业时的繁忙，也没有了对新框架的新鲜感，我也开始把工作当做完成任务，每天都想着早点儿下班回家看看书，刷刷github，很渴望提升技术。\n\n由于后来一直在做重复工作，我也对工作越来越没有兴趣。工作对于我来说就是打打卡而已，我也懒得关心其他的事情。这也导致了我年中的时候，就有离职跳槽的想法，但是又觉得，应该是我对工作关心太少了，只沉浸在自己的世界里面，也许应该再观察半年看看？\n\n真正的转折点在11月份团建去三亚，每天都躺在酒店里面，无聊的时候就去游泳，简直就是神仙日子。在那段日子里，我开始思考，工作和生活的意义是什么？\n\n我意识到自己一心沉迷于技术，却忽悠了业务的重要性。和我同时进来的小伙伴们都能独挡一面了，我却还像个襁褓中的孩子一样，需要别人把需求喂到我的嘴边，我也开始对自己的能力产生了怀疑。\n\n至于意识怎么觉醒的呢？也许是从看到映杰开发imvc框架的时候种子就已经埋在了心里，亦或许是看到了雨飞的微信打包机器人。是啊，如果技术不能服务于产品，那又有什么用呢？\n\n纠结良久，我胆怯地找了领导沟通，聊了聊自己这一年的状态，聊了聊自己以后想做什么，也表示自己愿意去做更多重要的、核心的业务，领导也表示赞许。\n\n\n年终自评的时候，我果断地写下了，我想像映杰那样，成为一个内外兼修的技术大神，可以用自己的技术来推动业务发展。\n\n## 离别\n\n离开的想法一旦产生，就会一直埋在心底，发芽，生长。\n\n在携程的最后两三个月，我变得更加积极、主动，也变得更乐于分享，我很清楚自己的问题在哪里，即使是亡羊补牢，我也希望能够改正自己的缺点。\n\n领导也履行了自己的诺言，让我负责更多的业务，让我尝试去带新人。我带着新人去开会，给他们讲需求，自己也慢慢变得可以独挡一面。\n\n可我还是会觉得无聊，没有热情。真的是我不愿意去了解业务吗？我思考了很久，我对这边的业务和产品确实不感兴趣。\n\n重复的工作和低效率的沟通让我疲于奔命，我也知道自己是时候离开了。\n\n终于，在年后的第一周，拒绝了领导的各种挽留后，我毅然选择提了离职。\n\n## 结语\n虽然很多人说，同事和朋友是两回事，可我还是要说，我在这边一年多来交到了很多不错的朋友。\n\n我从智伟、雨飞和映杰身上学习到了很多东西，关于技术，关于业务，关于生活，这些东西也改变了我的思维方式。\n\n最后，感谢一直和我斗嘴的智康，感谢对我很宽容照顾的卓予小姐姐，感谢能撩又调皮的秋玉小姐姐，感谢经常和我谈论人生未来的桢哥，也感谢组里面其他的小伙伴们，谢谢你们给了团队一个良好的氛围。\n\n虽有百般不舍，但终究难免一别，希望大家以后还能再遇见。\n\n![image_1d5ovu38e82phbgvo5itdetm16.png-431.2kB][1]\n![image_1d5pbhpsuqhg1jbh141h1mg06gpr.png-11278.4kB][2]\n![image_1d5pbk661139j30tiaf7a74ld1h.png-1290.9kB][3]\n\n\n  [1]: http://static.zybuluo.com/gyyin/s2tf9uzobi43vp8gne8upcvn/image_1d5ovu38e82phbgvo5itdetm16.png\n  [2]: http://static.zybuluo.com/gyyin/s3dsxil4g5m4iab3xmg01cv7/image_1d5pbhpsuqhg1jbh141h1mg06gpr.png\n  [3]: http://static.zybuluo.com/gyyin/oj8ls6jasmj0vig2n43as8dz/image_1d5pbk661139j30tiaf7a74ld1h.png","source":"_posts/再见，携程.md","raw":"---\ntitle: 再见，携程\ndate: 2019-03-14 13:47:02\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n## 前言\n从16年校招就开始与携程结缘，17年毕业后加入携程至今。在这短暂的一年多时间里，我受益匪浅，很感谢携程的培养，希望携程能越做越好。\n\n## 初次相遇\n时间回到2016年9月，我正在为校招找工作的事情急得团团转。由于对面试缺少准备，也错过了内推，又一直挂在笔试上，每天压力大到睡不着。\n\n恰好那个时候，我收到了携程的面试电话，虽然对携程这家公司没有太多好感，但还是抱着试试的心态去参加了面试。\n\n面试官是个温柔、和蔼的人，问了我一些问题，给我耐心地讲了这边的业务和技术栈。\n\n后来我才知道，这位面试官是度假BU的前端老大 —— 路总。\n<!-- more -->\n## 热恋期\n刚毕业的时候，我总是带着一股学生气，心理不够强大，也过于任性，总是被需求折腾的崩溃了，还好有同事包容着。\n\n记得刚来这边的时候，我们做的还是老自由行项目，可以说是历史遗留技术债了，对于刚毕业的我来说，阅读前人代码非常吃力。原本很简单的需求，我总是要花很多天才能完成，对自己打击也比较大。\n\n后来老大让我智伟带一下我，我还记得在这边写的第一个新页面是门票详情页。是的，那一个页面我写了整整一个多月，智伟总会指出我哪里写的不好，我也会和他讨论哪种实现更好，很感激他的耐心。\n\n大概在工作三个月后，这边的技术栈全面更新，从原来的lizard+react换成了映杰大佬的react-imvc，这是一个集成了react、状态管理、路由和同构的框架，功能很强大，也很实用。\n\n得益于react-imvc这个新框架，我们也随便将原来的项目迁移到新的技术栈上。DP2.0一期的时候我几乎每天都在加班，每周末都在加班，一边赶工，一边思考怎么实现功能，累并快乐着。（现在回头看，当时的代码写的不忍直视）\n\n那时候的我，对这一切都感觉很新鲜，每天都在不断地吸收新的知识。\n\n## 平淡期\n转眼间，2017年就过去了，我也从一个刚毕业时懵懂的学生变成了一个稍微有些经验的社会人了。\n\n没有了刚毕业时的繁忙，也没有了对新框架的新鲜感，我也开始把工作当做完成任务，每天都想着早点儿下班回家看看书，刷刷github，很渴望提升技术。\n\n由于后来一直在做重复工作，我也对工作越来越没有兴趣。工作对于我来说就是打打卡而已，我也懒得关心其他的事情。这也导致了我年中的时候，就有离职跳槽的想法，但是又觉得，应该是我对工作关心太少了，只沉浸在自己的世界里面，也许应该再观察半年看看？\n\n真正的转折点在11月份团建去三亚，每天都躺在酒店里面，无聊的时候就去游泳，简直就是神仙日子。在那段日子里，我开始思考，工作和生活的意义是什么？\n\n我意识到自己一心沉迷于技术，却忽悠了业务的重要性。和我同时进来的小伙伴们都能独挡一面了，我却还像个襁褓中的孩子一样，需要别人把需求喂到我的嘴边，我也开始对自己的能力产生了怀疑。\n\n至于意识怎么觉醒的呢？也许是从看到映杰开发imvc框架的时候种子就已经埋在了心里，亦或许是看到了雨飞的微信打包机器人。是啊，如果技术不能服务于产品，那又有什么用呢？\n\n纠结良久，我胆怯地找了领导沟通，聊了聊自己这一年的状态，聊了聊自己以后想做什么，也表示自己愿意去做更多重要的、核心的业务，领导也表示赞许。\n\n\n年终自评的时候，我果断地写下了，我想像映杰那样，成为一个内外兼修的技术大神，可以用自己的技术来推动业务发展。\n\n## 离别\n\n离开的想法一旦产生，就会一直埋在心底，发芽，生长。\n\n在携程的最后两三个月，我变得更加积极、主动，也变得更乐于分享，我很清楚自己的问题在哪里，即使是亡羊补牢，我也希望能够改正自己的缺点。\n\n领导也履行了自己的诺言，让我负责更多的业务，让我尝试去带新人。我带着新人去开会，给他们讲需求，自己也慢慢变得可以独挡一面。\n\n可我还是会觉得无聊，没有热情。真的是我不愿意去了解业务吗？我思考了很久，我对这边的业务和产品确实不感兴趣。\n\n重复的工作和低效率的沟通让我疲于奔命，我也知道自己是时候离开了。\n\n终于，在年后的第一周，拒绝了领导的各种挽留后，我毅然选择提了离职。\n\n## 结语\n虽然很多人说，同事和朋友是两回事，可我还是要说，我在这边一年多来交到了很多不错的朋友。\n\n我从智伟、雨飞和映杰身上学习到了很多东西，关于技术，关于业务，关于生活，这些东西也改变了我的思维方式。\n\n最后，感谢一直和我斗嘴的智康，感谢对我很宽容照顾的卓予小姐姐，感谢能撩又调皮的秋玉小姐姐，感谢经常和我谈论人生未来的桢哥，也感谢组里面其他的小伙伴们，谢谢你们给了团队一个良好的氛围。\n\n虽有百般不舍，但终究难免一别，希望大家以后还能再遇见。\n\n![image_1d5ovu38e82phbgvo5itdetm16.png-431.2kB][1]\n![image_1d5pbhpsuqhg1jbh141h1mg06gpr.png-11278.4kB][2]\n![image_1d5pbk661139j30tiaf7a74ld1h.png-1290.9kB][3]\n\n\n  [1]: http://static.zybuluo.com/gyyin/s2tf9uzobi43vp8gne8upcvn/image_1d5ovu38e82phbgvo5itdetm16.png\n  [2]: http://static.zybuluo.com/gyyin/s3dsxil4g5m4iab3xmg01cv7/image_1d5pbhpsuqhg1jbh141h1mg06gpr.png\n  [3]: http://static.zybuluo.com/gyyin/oj8ls6jasmj0vig2n43as8dz/image_1d5pbk661139j30tiaf7a74ld1h.png","slug":"再见，携程","published":1,"updated":"2019-04-07T05:53:12.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt3000odrfd59v67ut6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>从16年校招就开始与携程结缘，17年毕业后加入携程至今。在这短暂的一年多时间里，我受益匪浅，很感谢携程的培养，希望携程能越做越好。</p>\n<h2 id=\"初次相遇\"><a href=\"#初次相遇\" class=\"headerlink\" title=\"初次相遇\"></a>初次相遇</h2><p>时间回到2016年9月，我正在为校招找工作的事情急得团团转。由于对面试缺少准备，也错过了内推，又一直挂在笔试上，每天压力大到睡不着。</p>\n<p>恰好那个时候，我收到了携程的面试电话，虽然对携程这家公司没有太多好感，但还是抱着试试的心态去参加了面试。</p>\n<p>面试官是个温柔、和蔼的人，问了我一些问题，给我耐心地讲了这边的业务和技术栈。</p>\n<p>后来我才知道，这位面试官是度假BU的前端老大 —— 路总。<br><a id=\"more\"></a></p>\n<h2 id=\"热恋期\"><a href=\"#热恋期\" class=\"headerlink\" title=\"热恋期\"></a>热恋期</h2><p>刚毕业的时候，我总是带着一股学生气，心理不够强大，也过于任性，总是被需求折腾的崩溃了，还好有同事包容着。</p>\n<p>记得刚来这边的时候，我们做的还是老自由行项目，可以说是历史遗留技术债了，对于刚毕业的我来说，阅读前人代码非常吃力。原本很简单的需求，我总是要花很多天才能完成，对自己打击也比较大。</p>\n<p>后来老大让我智伟带一下我，我还记得在这边写的第一个新页面是门票详情页。是的，那一个页面我写了整整一个多月，智伟总会指出我哪里写的不好，我也会和他讨论哪种实现更好，很感激他的耐心。</p>\n<p>大概在工作三个月后，这边的技术栈全面更新，从原来的lizard+react换成了映杰大佬的react-imvc，这是一个集成了react、状态管理、路由和同构的框架，功能很强大，也很实用。</p>\n<p>得益于react-imvc这个新框架，我们也随便将原来的项目迁移到新的技术栈上。DP2.0一期的时候我几乎每天都在加班，每周末都在加班，一边赶工，一边思考怎么实现功能，累并快乐着。（现在回头看，当时的代码写的不忍直视）</p>\n<p>那时候的我，对这一切都感觉很新鲜，每天都在不断地吸收新的知识。</p>\n<h2 id=\"平淡期\"><a href=\"#平淡期\" class=\"headerlink\" title=\"平淡期\"></a>平淡期</h2><p>转眼间，2017年就过去了，我也从一个刚毕业时懵懂的学生变成了一个稍微有些经验的社会人了。</p>\n<p>没有了刚毕业时的繁忙，也没有了对新框架的新鲜感，我也开始把工作当做完成任务，每天都想着早点儿下班回家看看书，刷刷github，很渴望提升技术。</p>\n<p>由于后来一直在做重复工作，我也对工作越来越没有兴趣。工作对于我来说就是打打卡而已，我也懒得关心其他的事情。这也导致了我年中的时候，就有离职跳槽的想法，但是又觉得，应该是我对工作关心太少了，只沉浸在自己的世界里面，也许应该再观察半年看看？</p>\n<p>真正的转折点在11月份团建去三亚，每天都躺在酒店里面，无聊的时候就去游泳，简直就是神仙日子。在那段日子里，我开始思考，工作和生活的意义是什么？</p>\n<p>我意识到自己一心沉迷于技术，却忽悠了业务的重要性。和我同时进来的小伙伴们都能独挡一面了，我却还像个襁褓中的孩子一样，需要别人把需求喂到我的嘴边，我也开始对自己的能力产生了怀疑。</p>\n<p>至于意识怎么觉醒的呢？也许是从看到映杰开发imvc框架的时候种子就已经埋在了心里，亦或许是看到了雨飞的微信打包机器人。是啊，如果技术不能服务于产品，那又有什么用呢？</p>\n<p>纠结良久，我胆怯地找了领导沟通，聊了聊自己这一年的状态，聊了聊自己以后想做什么，也表示自己愿意去做更多重要的、核心的业务，领导也表示赞许。</p>\n<p>年终自评的时候，我果断地写下了，我想像映杰那样，成为一个内外兼修的技术大神，可以用自己的技术来推动业务发展。</p>\n<h2 id=\"离别\"><a href=\"#离别\" class=\"headerlink\" title=\"离别\"></a>离别</h2><p>离开的想法一旦产生，就会一直埋在心底，发芽，生长。</p>\n<p>在携程的最后两三个月，我变得更加积极、主动，也变得更乐于分享，我很清楚自己的问题在哪里，即使是亡羊补牢，我也希望能够改正自己的缺点。</p>\n<p>领导也履行了自己的诺言，让我负责更多的业务，让我尝试去带新人。我带着新人去开会，给他们讲需求，自己也慢慢变得可以独挡一面。</p>\n<p>可我还是会觉得无聊，没有热情。真的是我不愿意去了解业务吗？我思考了很久，我对这边的业务和产品确实不感兴趣。</p>\n<p>重复的工作和低效率的沟通让我疲于奔命，我也知道自己是时候离开了。</p>\n<p>终于，在年后的第一周，拒绝了领导的各种挽留后，我毅然选择提了离职。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>虽然很多人说，同事和朋友是两回事，可我还是要说，我在这边一年多来交到了很多不错的朋友。</p>\n<p>我从智伟、雨飞和映杰身上学习到了很多东西，关于技术，关于业务，关于生活，这些东西也改变了我的思维方式。</p>\n<p>最后，感谢一直和我斗嘴的智康，感谢对我很宽容照顾的卓予小姐姐，感谢能撩又调皮的秋玉小姐姐，感谢经常和我谈论人生未来的桢哥，也感谢组里面其他的小伙伴们，谢谢你们给了团队一个良好的氛围。</p>\n<p>虽有百般不舍，但终究难免一别，希望大家以后还能再遇见。</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/s2tf9uzobi43vp8gne8upcvn/image_1d5ovu38e82phbgvo5itdetm16.png\" alt=\"image_1d5ovu38e82phbgvo5itdetm16.png-431.2kB\"><br><img src=\"http://static.zybuluo.com/gyyin/s3dsxil4g5m4iab3xmg01cv7/image_1d5pbhpsuqhg1jbh141h1mg06gpr.png\" alt=\"image_1d5pbhpsuqhg1jbh141h1mg06gpr.png-11278.4kB\"><br><img src=\"http://static.zybuluo.com/gyyin/oj8ls6jasmj0vig2n43as8dz/image_1d5pbk661139j30tiaf7a74ld1h.png\" alt=\"image_1d5pbk661139j30tiaf7a74ld1h.png-1290.9kB\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>从16年校招就开始与携程结缘，17年毕业后加入携程至今。在这短暂的一年多时间里，我受益匪浅，很感谢携程的培养，希望携程能越做越好。</p>\n<h2 id=\"初次相遇\"><a href=\"#初次相遇\" class=\"headerlink\" title=\"初次相遇\"></a>初次相遇</h2><p>时间回到2016年9月，我正在为校招找工作的事情急得团团转。由于对面试缺少准备，也错过了内推，又一直挂在笔试上，每天压力大到睡不着。</p>\n<p>恰好那个时候，我收到了携程的面试电话，虽然对携程这家公司没有太多好感，但还是抱着试试的心态去参加了面试。</p>\n<p>面试官是个温柔、和蔼的人，问了我一些问题，给我耐心地讲了这边的业务和技术栈。</p>\n<p>后来我才知道，这位面试官是度假BU的前端老大 —— 路总。<br>","more":"</p>\n<h2 id=\"热恋期\"><a href=\"#热恋期\" class=\"headerlink\" title=\"热恋期\"></a>热恋期</h2><p>刚毕业的时候，我总是带着一股学生气，心理不够强大，也过于任性，总是被需求折腾的崩溃了，还好有同事包容着。</p>\n<p>记得刚来这边的时候，我们做的还是老自由行项目，可以说是历史遗留技术债了，对于刚毕业的我来说，阅读前人代码非常吃力。原本很简单的需求，我总是要花很多天才能完成，对自己打击也比较大。</p>\n<p>后来老大让我智伟带一下我，我还记得在这边写的第一个新页面是门票详情页。是的，那一个页面我写了整整一个多月，智伟总会指出我哪里写的不好，我也会和他讨论哪种实现更好，很感激他的耐心。</p>\n<p>大概在工作三个月后，这边的技术栈全面更新，从原来的lizard+react换成了映杰大佬的react-imvc，这是一个集成了react、状态管理、路由和同构的框架，功能很强大，也很实用。</p>\n<p>得益于react-imvc这个新框架，我们也随便将原来的项目迁移到新的技术栈上。DP2.0一期的时候我几乎每天都在加班，每周末都在加班，一边赶工，一边思考怎么实现功能，累并快乐着。（现在回头看，当时的代码写的不忍直视）</p>\n<p>那时候的我，对这一切都感觉很新鲜，每天都在不断地吸收新的知识。</p>\n<h2 id=\"平淡期\"><a href=\"#平淡期\" class=\"headerlink\" title=\"平淡期\"></a>平淡期</h2><p>转眼间，2017年就过去了，我也从一个刚毕业时懵懂的学生变成了一个稍微有些经验的社会人了。</p>\n<p>没有了刚毕业时的繁忙，也没有了对新框架的新鲜感，我也开始把工作当做完成任务，每天都想着早点儿下班回家看看书，刷刷github，很渴望提升技术。</p>\n<p>由于后来一直在做重复工作，我也对工作越来越没有兴趣。工作对于我来说就是打打卡而已，我也懒得关心其他的事情。这也导致了我年中的时候，就有离职跳槽的想法，但是又觉得，应该是我对工作关心太少了，只沉浸在自己的世界里面，也许应该再观察半年看看？</p>\n<p>真正的转折点在11月份团建去三亚，每天都躺在酒店里面，无聊的时候就去游泳，简直就是神仙日子。在那段日子里，我开始思考，工作和生活的意义是什么？</p>\n<p>我意识到自己一心沉迷于技术，却忽悠了业务的重要性。和我同时进来的小伙伴们都能独挡一面了，我却还像个襁褓中的孩子一样，需要别人把需求喂到我的嘴边，我也开始对自己的能力产生了怀疑。</p>\n<p>至于意识怎么觉醒的呢？也许是从看到映杰开发imvc框架的时候种子就已经埋在了心里，亦或许是看到了雨飞的微信打包机器人。是啊，如果技术不能服务于产品，那又有什么用呢？</p>\n<p>纠结良久，我胆怯地找了领导沟通，聊了聊自己这一年的状态，聊了聊自己以后想做什么，也表示自己愿意去做更多重要的、核心的业务，领导也表示赞许。</p>\n<p>年终自评的时候，我果断地写下了，我想像映杰那样，成为一个内外兼修的技术大神，可以用自己的技术来推动业务发展。</p>\n<h2 id=\"离别\"><a href=\"#离别\" class=\"headerlink\" title=\"离别\"></a>离别</h2><p>离开的想法一旦产生，就会一直埋在心底，发芽，生长。</p>\n<p>在携程的最后两三个月，我变得更加积极、主动，也变得更乐于分享，我很清楚自己的问题在哪里，即使是亡羊补牢，我也希望能够改正自己的缺点。</p>\n<p>领导也履行了自己的诺言，让我负责更多的业务，让我尝试去带新人。我带着新人去开会，给他们讲需求，自己也慢慢变得可以独挡一面。</p>\n<p>可我还是会觉得无聊，没有热情。真的是我不愿意去了解业务吗？我思考了很久，我对这边的业务和产品确实不感兴趣。</p>\n<p>重复的工作和低效率的沟通让我疲于奔命，我也知道自己是时候离开了。</p>\n<p>终于，在年后的第一周，拒绝了领导的各种挽留后，我毅然选择提了离职。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>虽然很多人说，同事和朋友是两回事，可我还是要说，我在这边一年多来交到了很多不错的朋友。</p>\n<p>我从智伟、雨飞和映杰身上学习到了很多东西，关于技术，关于业务，关于生活，这些东西也改变了我的思维方式。</p>\n<p>最后，感谢一直和我斗嘴的智康，感谢对我很宽容照顾的卓予小姐姐，感谢能撩又调皮的秋玉小姐姐，感谢经常和我谈论人生未来的桢哥，也感谢组里面其他的小伙伴们，谢谢你们给了团队一个良好的氛围。</p>\n<p>虽有百般不舍，但终究难免一别，希望大家以后还能再遇见。</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/s2tf9uzobi43vp8gne8upcvn/image_1d5ovu38e82phbgvo5itdetm16.png\" alt=\"image_1d5ovu38e82phbgvo5itdetm16.png-431.2kB\"><br><img src=\"http://static.zybuluo.com/gyyin/s3dsxil4g5m4iab3xmg01cv7/image_1d5pbhpsuqhg1jbh141h1mg06gpr.png\" alt=\"image_1d5pbhpsuqhg1jbh141h1mg06gpr.png-11278.4kB\"><br><img src=\"http://static.zybuluo.com/gyyin/oj8ls6jasmj0vig2n43as8dz/image_1d5pbk661139j30tiaf7a74ld1h.png\" alt=\"image_1d5pbk661139j30tiaf7a74ld1h.png-1290.9kB\"></p>"},{"title":"周报（2018-12-07）","date":"2018-12-07T15:39:07.000Z","_content":"\n这周正式开始做IBU项目，虽然之前用mobx和typescript写过demo，但毕竟没有在项目中用过。\n## 关于RN\n由于我们这边是CSS和JS分岗的形式，所以RN的样式也是由CSS组写好组件一起给我们，这和以前开发H5，他们直接给我们coding稿很不一样。\n以前我们可以在chrome里面查看coding稿的html结构和样式，可以自己去封装react组件。\n现在都是他们封装了组件，但是由于CSS组不是专门写JS的，他们封装的组件会有一些不合理，其次我们无法看到页面的整体结构，没法很容易地知道某个组件对应了页面上哪一部分，这样极大的增加了工作量和沟通成本。\n<!-- more-->\n## 关于TypeScript\n做IBU之前打算上TypeScript，我只是觉得很新鲜，一直想学新技术。在研究了一段时间后发现这个东西对代码的日后维护和重构有很大帮助，增加了静态类型，但又允许你使用any，保证类型检查的同时又保证了灵活度。\n除了类型之外，我觉得TypeScript在一定程度上改变了我的编程思维。老实说，我以前写的代码既不是面向对象，又不是函数式，最多只能叫面向过程，我也不懂为什么要用面向对象。\n因为这期用到了Mobx和TypeScript，我才思考面向对象的意义和重要性，因此我也去接触了不少的设计模式，遇到老代码里面的某些场景，我会思考这个适合哪种设计模式，我可以来重构和解耦。\n由于TypeScript的语法和c#、java比较像，这也让我可以去阅读一些java相关的文章，以前看不懂那些语法，现在可以大致看懂语法后理解一些后端编程的思想，并且运用到前端上面。\n## 关于FSM\n今天在做酒店列表页下拉加载的时候，突发奇想，酒店列表页下拉加载的时候一共有loading、fail、finish三种状态，其中对应关系只有loading -> fail，fail -> loading，loading -> finish，这不就是很符合状态机的思想吗？\n于是我想起了javascript-state-machine这个库，后来翻阅了一下github上的用法，但是发现很难和Mobx结合到一起，与其舍近求远强行用上这个库，还不如不用。\n后来我想了想，既然不用这个库，但是这个思想还是很值得借鉴的，我完全可以基于自己的业务封装一下这个功能，但是暂时也没有发现这个解决了什么问题，价值还是待定。\n## 总结\n总之，这周虽然写的进度很慢，目前只把页面store和组件设计好，但是也学到了不少的东西。与其低质量的赶工，我更愿意花更多时间来高质量的完成任务。\n\n\n\n","source":"_posts/周报（2018-12-07）.md","raw":"---\ntitle: 周报（2018-12-07）\ndate: 2018-12-07 23:39:07\ntags:\n- 工作\n- 周报\ncategories: 周报\n---\n\n这周正式开始做IBU项目，虽然之前用mobx和typescript写过demo，但毕竟没有在项目中用过。\n## 关于RN\n由于我们这边是CSS和JS分岗的形式，所以RN的样式也是由CSS组写好组件一起给我们，这和以前开发H5，他们直接给我们coding稿很不一样。\n以前我们可以在chrome里面查看coding稿的html结构和样式，可以自己去封装react组件。\n现在都是他们封装了组件，但是由于CSS组不是专门写JS的，他们封装的组件会有一些不合理，其次我们无法看到页面的整体结构，没法很容易地知道某个组件对应了页面上哪一部分，这样极大的增加了工作量和沟通成本。\n<!-- more-->\n## 关于TypeScript\n做IBU之前打算上TypeScript，我只是觉得很新鲜，一直想学新技术。在研究了一段时间后发现这个东西对代码的日后维护和重构有很大帮助，增加了静态类型，但又允许你使用any，保证类型检查的同时又保证了灵活度。\n除了类型之外，我觉得TypeScript在一定程度上改变了我的编程思维。老实说，我以前写的代码既不是面向对象，又不是函数式，最多只能叫面向过程，我也不懂为什么要用面向对象。\n因为这期用到了Mobx和TypeScript，我才思考面向对象的意义和重要性，因此我也去接触了不少的设计模式，遇到老代码里面的某些场景，我会思考这个适合哪种设计模式，我可以来重构和解耦。\n由于TypeScript的语法和c#、java比较像，这也让我可以去阅读一些java相关的文章，以前看不懂那些语法，现在可以大致看懂语法后理解一些后端编程的思想，并且运用到前端上面。\n## 关于FSM\n今天在做酒店列表页下拉加载的时候，突发奇想，酒店列表页下拉加载的时候一共有loading、fail、finish三种状态，其中对应关系只有loading -> fail，fail -> loading，loading -> finish，这不就是很符合状态机的思想吗？\n于是我想起了javascript-state-machine这个库，后来翻阅了一下github上的用法，但是发现很难和Mobx结合到一起，与其舍近求远强行用上这个库，还不如不用。\n后来我想了想，既然不用这个库，但是这个思想还是很值得借鉴的，我完全可以基于自己的业务封装一下这个功能，但是暂时也没有发现这个解决了什么问题，价值还是待定。\n## 总结\n总之，这周虽然写的进度很慢，目前只把页面store和组件设计好，但是也学到了不少的东西。与其低质量的赶工，我更愿意花更多时间来高质量的完成任务。\n\n\n\n","slug":"周报（2018-12-07）","published":1,"updated":"2019-04-07T05:57:24.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt5000rdrfd5xmmyi6a","content":"<p>这周正式开始做IBU项目，虽然之前用mobx和typescript写过demo，但毕竟没有在项目中用过。</p>\n<h2 id=\"关于RN\"><a href=\"#关于RN\" class=\"headerlink\" title=\"关于RN\"></a>关于RN</h2><p>由于我们这边是CSS和JS分岗的形式，所以RN的样式也是由CSS组写好组件一起给我们，这和以前开发H5，他们直接给我们coding稿很不一样。<br>以前我们可以在chrome里面查看coding稿的html结构和样式，可以自己去封装react组件。<br>现在都是他们封装了组件，但是由于CSS组不是专门写JS的，他们封装的组件会有一些不合理，其次我们无法看到页面的整体结构，没法很容易地知道某个组件对应了页面上哪一部分，这样极大的增加了工作量和沟通成本。<br><a id=\"more\"></a></p>\n<h2 id=\"关于TypeScript\"><a href=\"#关于TypeScript\" class=\"headerlink\" title=\"关于TypeScript\"></a>关于TypeScript</h2><p>做IBU之前打算上TypeScript，我只是觉得很新鲜，一直想学新技术。在研究了一段时间后发现这个东西对代码的日后维护和重构有很大帮助，增加了静态类型，但又允许你使用any，保证类型检查的同时又保证了灵活度。<br>除了类型之外，我觉得TypeScript在一定程度上改变了我的编程思维。老实说，我以前写的代码既不是面向对象，又不是函数式，最多只能叫面向过程，我也不懂为什么要用面向对象。<br>因为这期用到了Mobx和TypeScript，我才思考面向对象的意义和重要性，因此我也去接触了不少的设计模式，遇到老代码里面的某些场景，我会思考这个适合哪种设计模式，我可以来重构和解耦。<br>由于TypeScript的语法和c#、java比较像，这也让我可以去阅读一些java相关的文章，以前看不懂那些语法，现在可以大致看懂语法后理解一些后端编程的思想，并且运用到前端上面。</p>\n<h2 id=\"关于FSM\"><a href=\"#关于FSM\" class=\"headerlink\" title=\"关于FSM\"></a>关于FSM</h2><p>今天在做酒店列表页下拉加载的时候，突发奇想，酒店列表页下拉加载的时候一共有loading、fail、finish三种状态，其中对应关系只有loading -&gt; fail，fail -&gt; loading，loading -&gt; finish，这不就是很符合状态机的思想吗？<br>于是我想起了javascript-state-machine这个库，后来翻阅了一下github上的用法，但是发现很难和Mobx结合到一起，与其舍近求远强行用上这个库，还不如不用。<br>后来我想了想，既然不用这个库，但是这个思想还是很值得借鉴的，我完全可以基于自己的业务封装一下这个功能，但是暂时也没有发现这个解决了什么问题，价值还是待定。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之，这周虽然写的进度很慢，目前只把页面store和组件设计好，但是也学到了不少的东西。与其低质量的赶工，我更愿意花更多时间来高质量的完成任务。</p>\n","site":{"data":{}},"excerpt":"<p>这周正式开始做IBU项目，虽然之前用mobx和typescript写过demo，但毕竟没有在项目中用过。</p>\n<h2 id=\"关于RN\"><a href=\"#关于RN\" class=\"headerlink\" title=\"关于RN\"></a>关于RN</h2><p>由于我们这边是CSS和JS分岗的形式，所以RN的样式也是由CSS组写好组件一起给我们，这和以前开发H5，他们直接给我们coding稿很不一样。<br>以前我们可以在chrome里面查看coding稿的html结构和样式，可以自己去封装react组件。<br>现在都是他们封装了组件，但是由于CSS组不是专门写JS的，他们封装的组件会有一些不合理，其次我们无法看到页面的整体结构，没法很容易地知道某个组件对应了页面上哪一部分，这样极大的增加了工作量和沟通成本。<br>","more":"</p>\n<h2 id=\"关于TypeScript\"><a href=\"#关于TypeScript\" class=\"headerlink\" title=\"关于TypeScript\"></a>关于TypeScript</h2><p>做IBU之前打算上TypeScript，我只是觉得很新鲜，一直想学新技术。在研究了一段时间后发现这个东西对代码的日后维护和重构有很大帮助，增加了静态类型，但又允许你使用any，保证类型检查的同时又保证了灵活度。<br>除了类型之外，我觉得TypeScript在一定程度上改变了我的编程思维。老实说，我以前写的代码既不是面向对象，又不是函数式，最多只能叫面向过程，我也不懂为什么要用面向对象。<br>因为这期用到了Mobx和TypeScript，我才思考面向对象的意义和重要性，因此我也去接触了不少的设计模式，遇到老代码里面的某些场景，我会思考这个适合哪种设计模式，我可以来重构和解耦。<br>由于TypeScript的语法和c#、java比较像，这也让我可以去阅读一些java相关的文章，以前看不懂那些语法，现在可以大致看懂语法后理解一些后端编程的思想，并且运用到前端上面。</p>\n<h2 id=\"关于FSM\"><a href=\"#关于FSM\" class=\"headerlink\" title=\"关于FSM\"></a>关于FSM</h2><p>今天在做酒店列表页下拉加载的时候，突发奇想，酒店列表页下拉加载的时候一共有loading、fail、finish三种状态，其中对应关系只有loading -&gt; fail，fail -&gt; loading，loading -&gt; finish，这不就是很符合状态机的思想吗？<br>于是我想起了javascript-state-machine这个库，后来翻阅了一下github上的用法，但是发现很难和Mobx结合到一起，与其舍近求远强行用上这个库，还不如不用。<br>后来我想了想，既然不用这个库，但是这个思想还是很值得借鉴的，我完全可以基于自己的业务封装一下这个功能，但是暂时也没有发现这个解决了什么问题，价值还是待定。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之，这周虽然写的进度很慢，目前只把页面store和组件设计好，但是也学到了不少的东西。与其低质量的赶工，我更愿意花更多时间来高质量的完成任务。</p>"},{"title":"周报（2018-12-14）","date":"2018-12-15T09:24:16.000Z","_content":"这周的主要任务都是在做IBU酒店列表页，因为大家都是第一次用Mobx，所以我一直在探索Mobx的最佳实践，这里是自己总结的一些经验。\n\n## 更响应式\n我最喜欢mobx的地方就是和vue一样的数据监听，框架底层通过Object.defineProperty或Proxy来劫持数据，对组件可以进行更细粒度的渲染。在react中反而把更新组件的操作（setState）交给了使用者，由于setState的\"异步\"特性导致了没法立刻拿到更新后的state。\n<!--more-->\n### computed\n想像一下，在redux中，如果一个值A是由另外几个值B、C、D计算出来的，在store中该怎么实现？\n如果要实现这么一个功能，最麻烦的做法是在所有B、C、D变化的地方重新计算得出A，最后存入store。\n当然我也可以在组件渲染A的地方根据B、C、D计算出A，但是这样会把逻辑和组件耦合到一起，如果我需要在其他地方用到A怎么办？\n我甚至还可以在所有connect的地方计算A，最后传入组件。但由于redux监听的是整个store的变化，所以无法准确的监听到B、C、D变化后才重新计算A。\n但是mobx中提供了computed来解决这个问题。正如mobx官方介绍的一样，computed是基于现有状态或计算值衍生出的值，如下面todoList的例子，一旦已完成事项数量改变，那么completedCount会自动更新。\n```\nclass TodoStore {\n    @observable todos = []\n    @computed get completedCount() {\n\t\treturn (this.todos.filter(todo => todo.isCompleted) || []).length\n\t}\n}\n```\n### reaction\nreaction则是和autorun功能类似，但是autorun会立即执行一次，而reaction不会，使用reaction可以在监听到指定数据变化的时候执行一些操作，有利于和副作用代码解耦。\n```\n// 当todos改变的时候将其存入缓存\nreaction(\n    () => toJS(this.todos),\n    (todos) =>  localStorage.setItem('mobx-react-todomvc-todos', JSON.stringify({ todos }))\n)\n```\n## 拆分store\nmobx中的store的创建偏向于面向对象的形式，mobx官方给出的例子todomvc中的store更接近于mvc中的model。\n但是这样也会带来一个问题，业务逻辑我们应该放到哪里？如果也放到store里面很容易造成不同store之间数据的耦合，因为业务代码必然会耦合不同的数据。\n我参考了dobjs后，推荐将store拆分为action和dataModel两种。\naction和dataModel一起组合成了页面的总store，dataModel只存放UI数据以及只涉及自身数据变化的action操作（在mobx严格模式中，修改数据一定要用action或flow）。\naction store则是负责存放一些需要使用来自不同store数据的action操作。\n我个人理解，dataModel更像MVC中的model，action store是controller，react components则是view，三者构成了mvc的结构。\n```\n- stores\n    - actions\n        - hotelListAction.js\n    - dataModel\n        - globalStatus.js\n        - hotelList.js\n    - index.js\n// globalStatus\nclass GlobalStatus {\n    @observable isShowLoading = false;\n    @action showLoading = () => {\n        this.isShowLoading = true\n    }\n    @action hideLoading = () => {\n        this.isShowLoading = false\n    }\n}\n// hotelList\nclass HotelList {\n    @observable hotels = []\n    @action addHotels = (hotels) => {\n        this.hotels = [...toJS(this.hotels), ...hotels];\n    }\n}\n// hotelListAction\nclass HotelListAction {\n    fetchHotelList = flow(function *() {\n        const {\n            globalStatus,\n            hotelList\n        } = this.rootStore\n        globalStatus.showLoading();\n        try {\n            const res = yield fetch('/hoteList', params);\n            hotelList.addHotels(res.hotels);\n        } catch (err) {\n        } finally {\n            globalStatus.hideLoading();\n        }\n    }).bind(this)\n}\n```\n![store结构][1]\n## 细粒度的渲染\nobserver可以给组件增加订阅功能，一旦收到数据变化的通知就会将组件重新渲染，从而做到更细粒度的更新，这是redux和react很难做到的，因为react中组件重新渲染基本是依赖于setState和接收到新的props，子组件的渲染几乎一定会伴随着父组件的渲染。\n也许很多人没有注意到，mobx-react中还提供了一个Observer组件，这个组件接收一个render方法或者render props。\n```\nconst App = () => <h1>hello, world</h1>;\n<Observer>{() => <App />}</Observer>\n<Observer render={() => <App />} />\n```\n也许你要问这个和observer有什么区别？还写的更加复杂了，下面这个例子对比起来会比较明显。\n```\nimport { observer, Observer, observable } from 'mobx-react'\nconst App = observer(\n    (props) => <h1>hello, {props.name}</h1>\n)\nconst Header = (props) => <h1>this is header</h1>\nconst Footer = (props) => <h1>this is footer</h1>\nconst Container = observer(\n    (props) => {\n        return (\n            <>\n                <Header />\n                <App name={props.person.name} />\n                <Footer />\n            </>\n        )\n    }\n)\nconst person = observable({name: \"gyyin\"});\nrender(<Container person={person} />, document.getElementById(\"app\"));\nperson.name = \"world\";\n```\n上面这个代码，Container组件监听到person.name改变的时候会重新渲染，这样就导致了原本不需要重新渲染的Header和Footer也跟着渲染了，如果使用Observer就可以做到更细粒度的渲染。\n```\nconst App = (props) => <h1>hello, {props.name}</h1>\nconst Header = (props) => <h1>this is header</h1>\nconst Footer = (props) => <h1>this is footer</h1>\nconst Container = (props) => {\n    return (\n        <>\n            <Header />\n            <Observer render={\n                () => <App name={props.person.name} />\n            }>\n            <Footer />\n        </>\n    )\n}\nconst person = observable({name: \"gyyin\"});\nrender(<Container person={person} />, document.getElementById(\"app\"));\nperson.name = \"world\";\n```\n如果在Header和Footer里面做console.log，你会发现只有被Observer包裹的App组件进行了重新渲染，由于Container没有订阅数据变化，所以也不会重新渲染。\n但如果不是对性能有极致的追求，observer已经足够了，大量的Observer会花费你很多精力来管理渲染问题。\n\n**参考链接：**\n1. [如何组织Mobx中的Store之一：构建State、拆分Action][2]\n2. [面向未来的前端数据流框架 - dob][3]\n3. [为什么我们需要reselect][4]\n\n\n  [1]: https://img.alicdn.com/tfs/TB1wm67mjihSKJjy0FiXXcuiFXa-601-435.png\n  [2]: https://www.jianshu.com/p/1bb41b726324\n  [3]: https://qianduan.group/posts/59fc26fbbc868873528cd556cd556\n  [4]: https://segmentfault.com/a/1190000011936772","source":"_posts/周报（2018-12-14）.md","raw":"---\ntitle: 周报（2018-12-14）\ndate: 2018-12-15 17:24:16\ntags:\n- 工作\n- 周报\ncategories: 周报\n---\n这周的主要任务都是在做IBU酒店列表页，因为大家都是第一次用Mobx，所以我一直在探索Mobx的最佳实践，这里是自己总结的一些经验。\n\n## 更响应式\n我最喜欢mobx的地方就是和vue一样的数据监听，框架底层通过Object.defineProperty或Proxy来劫持数据，对组件可以进行更细粒度的渲染。在react中反而把更新组件的操作（setState）交给了使用者，由于setState的\"异步\"特性导致了没法立刻拿到更新后的state。\n<!--more-->\n### computed\n想像一下，在redux中，如果一个值A是由另外几个值B、C、D计算出来的，在store中该怎么实现？\n如果要实现这么一个功能，最麻烦的做法是在所有B、C、D变化的地方重新计算得出A，最后存入store。\n当然我也可以在组件渲染A的地方根据B、C、D计算出A，但是这样会把逻辑和组件耦合到一起，如果我需要在其他地方用到A怎么办？\n我甚至还可以在所有connect的地方计算A，最后传入组件。但由于redux监听的是整个store的变化，所以无法准确的监听到B、C、D变化后才重新计算A。\n但是mobx中提供了computed来解决这个问题。正如mobx官方介绍的一样，computed是基于现有状态或计算值衍生出的值，如下面todoList的例子，一旦已完成事项数量改变，那么completedCount会自动更新。\n```\nclass TodoStore {\n    @observable todos = []\n    @computed get completedCount() {\n\t\treturn (this.todos.filter(todo => todo.isCompleted) || []).length\n\t}\n}\n```\n### reaction\nreaction则是和autorun功能类似，但是autorun会立即执行一次，而reaction不会，使用reaction可以在监听到指定数据变化的时候执行一些操作，有利于和副作用代码解耦。\n```\n// 当todos改变的时候将其存入缓存\nreaction(\n    () => toJS(this.todos),\n    (todos) =>  localStorage.setItem('mobx-react-todomvc-todos', JSON.stringify({ todos }))\n)\n```\n## 拆分store\nmobx中的store的创建偏向于面向对象的形式，mobx官方给出的例子todomvc中的store更接近于mvc中的model。\n但是这样也会带来一个问题，业务逻辑我们应该放到哪里？如果也放到store里面很容易造成不同store之间数据的耦合，因为业务代码必然会耦合不同的数据。\n我参考了dobjs后，推荐将store拆分为action和dataModel两种。\naction和dataModel一起组合成了页面的总store，dataModel只存放UI数据以及只涉及自身数据变化的action操作（在mobx严格模式中，修改数据一定要用action或flow）。\naction store则是负责存放一些需要使用来自不同store数据的action操作。\n我个人理解，dataModel更像MVC中的model，action store是controller，react components则是view，三者构成了mvc的结构。\n```\n- stores\n    - actions\n        - hotelListAction.js\n    - dataModel\n        - globalStatus.js\n        - hotelList.js\n    - index.js\n// globalStatus\nclass GlobalStatus {\n    @observable isShowLoading = false;\n    @action showLoading = () => {\n        this.isShowLoading = true\n    }\n    @action hideLoading = () => {\n        this.isShowLoading = false\n    }\n}\n// hotelList\nclass HotelList {\n    @observable hotels = []\n    @action addHotels = (hotels) => {\n        this.hotels = [...toJS(this.hotels), ...hotels];\n    }\n}\n// hotelListAction\nclass HotelListAction {\n    fetchHotelList = flow(function *() {\n        const {\n            globalStatus,\n            hotelList\n        } = this.rootStore\n        globalStatus.showLoading();\n        try {\n            const res = yield fetch('/hoteList', params);\n            hotelList.addHotels(res.hotels);\n        } catch (err) {\n        } finally {\n            globalStatus.hideLoading();\n        }\n    }).bind(this)\n}\n```\n![store结构][1]\n## 细粒度的渲染\nobserver可以给组件增加订阅功能，一旦收到数据变化的通知就会将组件重新渲染，从而做到更细粒度的更新，这是redux和react很难做到的，因为react中组件重新渲染基本是依赖于setState和接收到新的props，子组件的渲染几乎一定会伴随着父组件的渲染。\n也许很多人没有注意到，mobx-react中还提供了一个Observer组件，这个组件接收一个render方法或者render props。\n```\nconst App = () => <h1>hello, world</h1>;\n<Observer>{() => <App />}</Observer>\n<Observer render={() => <App />} />\n```\n也许你要问这个和observer有什么区别？还写的更加复杂了，下面这个例子对比起来会比较明显。\n```\nimport { observer, Observer, observable } from 'mobx-react'\nconst App = observer(\n    (props) => <h1>hello, {props.name}</h1>\n)\nconst Header = (props) => <h1>this is header</h1>\nconst Footer = (props) => <h1>this is footer</h1>\nconst Container = observer(\n    (props) => {\n        return (\n            <>\n                <Header />\n                <App name={props.person.name} />\n                <Footer />\n            </>\n        )\n    }\n)\nconst person = observable({name: \"gyyin\"});\nrender(<Container person={person} />, document.getElementById(\"app\"));\nperson.name = \"world\";\n```\n上面这个代码，Container组件监听到person.name改变的时候会重新渲染，这样就导致了原本不需要重新渲染的Header和Footer也跟着渲染了，如果使用Observer就可以做到更细粒度的渲染。\n```\nconst App = (props) => <h1>hello, {props.name}</h1>\nconst Header = (props) => <h1>this is header</h1>\nconst Footer = (props) => <h1>this is footer</h1>\nconst Container = (props) => {\n    return (\n        <>\n            <Header />\n            <Observer render={\n                () => <App name={props.person.name} />\n            }>\n            <Footer />\n        </>\n    )\n}\nconst person = observable({name: \"gyyin\"});\nrender(<Container person={person} />, document.getElementById(\"app\"));\nperson.name = \"world\";\n```\n如果在Header和Footer里面做console.log，你会发现只有被Observer包裹的App组件进行了重新渲染，由于Container没有订阅数据变化，所以也不会重新渲染。\n但如果不是对性能有极致的追求，observer已经足够了，大量的Observer会花费你很多精力来管理渲染问题。\n\n**参考链接：**\n1. [如何组织Mobx中的Store之一：构建State、拆分Action][2]\n2. [面向未来的前端数据流框架 - dob][3]\n3. [为什么我们需要reselect][4]\n\n\n  [1]: https://img.alicdn.com/tfs/TB1wm67mjihSKJjy0FiXXcuiFXa-601-435.png\n  [2]: https://www.jianshu.com/p/1bb41b726324\n  [3]: https://qianduan.group/posts/59fc26fbbc868873528cd556cd556\n  [4]: https://segmentfault.com/a/1190000011936772","slug":"周报（2018-12-14）","published":1,"updated":"2019-04-07T05:53:12.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt7000tdrfdxgl02cw2","content":"<p>这周的主要任务都是在做IBU酒店列表页，因为大家都是第一次用Mobx，所以我一直在探索Mobx的最佳实践，这里是自己总结的一些经验。</p>\n<h2 id=\"更响应式\"><a href=\"#更响应式\" class=\"headerlink\" title=\"更响应式\"></a>更响应式</h2><p>我最喜欢mobx的地方就是和vue一样的数据监听，框架底层通过Object.defineProperty或Proxy来劫持数据，对组件可以进行更细粒度的渲染。在react中反而把更新组件的操作（setState）交给了使用者，由于setState的”异步”特性导致了没法立刻拿到更新后的state。<br><a id=\"more\"></a></p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><p>想像一下，在redux中，如果一个值A是由另外几个值B、C、D计算出来的，在store中该怎么实现？<br>如果要实现这么一个功能，最麻烦的做法是在所有B、C、D变化的地方重新计算得出A，最后存入store。<br>当然我也可以在组件渲染A的地方根据B、C、D计算出A，但是这样会把逻辑和组件耦合到一起，如果我需要在其他地方用到A怎么办？<br>我甚至还可以在所有connect的地方计算A，最后传入组件。但由于redux监听的是整个store的变化，所以无法准确的监听到B、C、D变化后才重新计算A。<br>但是mobx中提供了computed来解决这个问题。正如mobx官方介绍的一样，computed是基于现有状态或计算值衍生出的值，如下面todoList的例子，一旦已完成事项数量改变，那么completedCount会自动更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoStore &#123;</span><br><span class=\"line\">    @observable todos = []</span><br><span class=\"line\">    @computed get completedCount() &#123;</span><br><span class=\"line\">\t\treturn (this.todos.filter(todo =&gt; todo.isCompleted) || []).length</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"reaction\"><a href=\"#reaction\" class=\"headerlink\" title=\"reaction\"></a>reaction</h3><p>reaction则是和autorun功能类似，但是autorun会立即执行一次，而reaction不会，使用reaction可以在监听到指定数据变化的时候执行一些操作，有利于和副作用代码解耦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当todos改变的时候将其存入缓存</span><br><span class=\"line\">reaction(</span><br><span class=\"line\">    () =&gt; toJS(this.todos),</span><br><span class=\"line\">    (todos) =&gt;  localStorage.setItem(&apos;mobx-react-todomvc-todos&apos;, JSON.stringify(&#123; todos &#125;))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"拆分store\"><a href=\"#拆分store\" class=\"headerlink\" title=\"拆分store\"></a>拆分store</h2><p>mobx中的store的创建偏向于面向对象的形式，mobx官方给出的例子todomvc中的store更接近于mvc中的model。<br>但是这样也会带来一个问题，业务逻辑我们应该放到哪里？如果也放到store里面很容易造成不同store之间数据的耦合，因为业务代码必然会耦合不同的数据。<br>我参考了dobjs后，推荐将store拆分为action和dataModel两种。<br>action和dataModel一起组合成了页面的总store，dataModel只存放UI数据以及只涉及自身数据变化的action操作（在mobx严格模式中，修改数据一定要用action或flow）。<br>action store则是负责存放一些需要使用来自不同store数据的action操作。<br>我个人理解，dataModel更像MVC中的model，action store是controller，react components则是view，三者构成了mvc的结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- stores</span><br><span class=\"line\">    - actions</span><br><span class=\"line\">        - hotelListAction.js</span><br><span class=\"line\">    - dataModel</span><br><span class=\"line\">        - globalStatus.js</span><br><span class=\"line\">        - hotelList.js</span><br><span class=\"line\">    - index.js</span><br><span class=\"line\">// globalStatus</span><br><span class=\"line\">class GlobalStatus &#123;</span><br><span class=\"line\">    @observable isShowLoading = false;</span><br><span class=\"line\">    @action showLoading = () =&gt; &#123;</span><br><span class=\"line\">        this.isShowLoading = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @action hideLoading = () =&gt; &#123;</span><br><span class=\"line\">        this.isShowLoading = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// hotelList</span><br><span class=\"line\">class HotelList &#123;</span><br><span class=\"line\">    @observable hotels = []</span><br><span class=\"line\">    @action addHotels = (hotels) =&gt; &#123;</span><br><span class=\"line\">        this.hotels = [...toJS(this.hotels), ...hotels];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// hotelListAction</span><br><span class=\"line\">class HotelListAction &#123;</span><br><span class=\"line\">    fetchHotelList = flow(function *() &#123;</span><br><span class=\"line\">        const &#123;</span><br><span class=\"line\">            globalStatus,</span><br><span class=\"line\">            hotelList</span><br><span class=\"line\">        &#125; = this.rootStore</span><br><span class=\"line\">        globalStatus.showLoading();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            const res = yield fetch(&apos;/hoteList&apos;, params);</span><br><span class=\"line\">            hotelList.addHotels(res.hotels);</span><br><span class=\"line\">        &#125; catch (err) &#123;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            globalStatus.hideLoading();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(this)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1wm67mjihSKJjy0FiXXcuiFXa-601-435.png\" alt=\"store结构\"></p>\n<h2 id=\"细粒度的渲染\"><a href=\"#细粒度的渲染\" class=\"headerlink\" title=\"细粒度的渲染\"></a>细粒度的渲染</h2><p>observer可以给组件增加订阅功能，一旦收到数据变化的通知就会将组件重新渲染，从而做到更细粒度的更新，这是redux和react很难做到的，因为react中组件重新渲染基本是依赖于setState和接收到新的props，子组件的渲染几乎一定会伴随着父组件的渲染。<br>也许很多人没有注意到，mobx-react中还提供了一个Observer组件，这个组件接收一个render方法或者render props。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = () =&gt; &lt;h1&gt;hello, world&lt;/h1&gt;;</span><br><span class=\"line\">&lt;Observer&gt;&#123;() =&gt; &lt;App /&gt;&#125;&lt;/Observer&gt;</span><br><span class=\"line\">&lt;Observer render=&#123;() =&gt; &lt;App /&gt;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>也许你要问这个和observer有什么区别？还写的更加复杂了，下面这个例子对比起来会比较明显。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; observer, Observer, observable &#125; from &apos;mobx-react&apos;</span><br><span class=\"line\">const App = observer(</span><br><span class=\"line\">    (props) =&gt; &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">const Header = (props) =&gt; &lt;h1&gt;this is header&lt;/h1&gt;</span><br><span class=\"line\">const Footer = (props) =&gt; &lt;h1&gt;this is footer&lt;/h1&gt;</span><br><span class=\"line\">const Container = observer(</span><br><span class=\"line\">    (props) =&gt; &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;&gt;</span><br><span class=\"line\">                &lt;Header /&gt;</span><br><span class=\"line\">                &lt;App name=&#123;props.person.name&#125; /&gt;</span><br><span class=\"line\">                &lt;Footer /&gt;</span><br><span class=\"line\">            &lt;/&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">const person = observable(&#123;name: &quot;gyyin&quot;&#125;);</span><br><span class=\"line\">render(&lt;Container person=&#123;person&#125; /&gt;, document.getElementById(&quot;app&quot;));</span><br><span class=\"line\">person.name = &quot;world&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>上面这个代码，Container组件监听到person.name改变的时候会重新渲染，这样就导致了原本不需要重新渲染的Header和Footer也跟着渲染了，如果使用Observer就可以做到更细粒度的渲染。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = (props) =&gt; &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">const Header = (props) =&gt; &lt;h1&gt;this is header&lt;/h1&gt;</span><br><span class=\"line\">const Footer = (props) =&gt; &lt;h1&gt;this is footer&lt;/h1&gt;</span><br><span class=\"line\">const Container = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;Header /&gt;</span><br><span class=\"line\">            &lt;Observer render=&#123;</span><br><span class=\"line\">                () =&gt; &lt;App name=&#123;props.person.name&#125; /&gt;</span><br><span class=\"line\">            &#125;&gt;</span><br><span class=\"line\">            &lt;Footer /&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const person = observable(&#123;name: &quot;gyyin&quot;&#125;);</span><br><span class=\"line\">render(&lt;Container person=&#123;person&#125; /&gt;, document.getElementById(&quot;app&quot;));</span><br><span class=\"line\">person.name = &quot;world&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>如果在Header和Footer里面做console.log，你会发现只有被Observer包裹的App组件进行了重新渲染，由于Container没有订阅数据变化，所以也不会重新渲染。<br>但如果不是对性能有极致的追求，observer已经足够了，大量的Observer会花费你很多精力来管理渲染问题。</p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/1bb41b726324\" target=\"_blank\" rel=\"noopener\">如何组织Mobx中的Store之一：构建State、拆分Action</a></li>\n<li><a href=\"https://qianduan.group/posts/59fc26fbbc868873528cd556cd556\" target=\"_blank\" rel=\"noopener\">面向未来的前端数据流框架 - dob</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011936772\" target=\"_blank\" rel=\"noopener\">为什么我们需要reselect</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这周的主要任务都是在做IBU酒店列表页，因为大家都是第一次用Mobx，所以我一直在探索Mobx的最佳实践，这里是自己总结的一些经验。</p>\n<h2 id=\"更响应式\"><a href=\"#更响应式\" class=\"headerlink\" title=\"更响应式\"></a>更响应式</h2><p>我最喜欢mobx的地方就是和vue一样的数据监听，框架底层通过Object.defineProperty或Proxy来劫持数据，对组件可以进行更细粒度的渲染。在react中反而把更新组件的操作（setState）交给了使用者，由于setState的”异步”特性导致了没法立刻拿到更新后的state。<br>","more":"</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><p>想像一下，在redux中，如果一个值A是由另外几个值B、C、D计算出来的，在store中该怎么实现？<br>如果要实现这么一个功能，最麻烦的做法是在所有B、C、D变化的地方重新计算得出A，最后存入store。<br>当然我也可以在组件渲染A的地方根据B、C、D计算出A，但是这样会把逻辑和组件耦合到一起，如果我需要在其他地方用到A怎么办？<br>我甚至还可以在所有connect的地方计算A，最后传入组件。但由于redux监听的是整个store的变化，所以无法准确的监听到B、C、D变化后才重新计算A。<br>但是mobx中提供了computed来解决这个问题。正如mobx官方介绍的一样，computed是基于现有状态或计算值衍生出的值，如下面todoList的例子，一旦已完成事项数量改变，那么completedCount会自动更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoStore &#123;</span><br><span class=\"line\">    @observable todos = []</span><br><span class=\"line\">    @computed get completedCount() &#123;</span><br><span class=\"line\">\t\treturn (this.todos.filter(todo =&gt; todo.isCompleted) || []).length</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"reaction\"><a href=\"#reaction\" class=\"headerlink\" title=\"reaction\"></a>reaction</h3><p>reaction则是和autorun功能类似，但是autorun会立即执行一次，而reaction不会，使用reaction可以在监听到指定数据变化的时候执行一些操作，有利于和副作用代码解耦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当todos改变的时候将其存入缓存</span><br><span class=\"line\">reaction(</span><br><span class=\"line\">    () =&gt; toJS(this.todos),</span><br><span class=\"line\">    (todos) =&gt;  localStorage.setItem(&apos;mobx-react-todomvc-todos&apos;, JSON.stringify(&#123; todos &#125;))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"拆分store\"><a href=\"#拆分store\" class=\"headerlink\" title=\"拆分store\"></a>拆分store</h2><p>mobx中的store的创建偏向于面向对象的形式，mobx官方给出的例子todomvc中的store更接近于mvc中的model。<br>但是这样也会带来一个问题，业务逻辑我们应该放到哪里？如果也放到store里面很容易造成不同store之间数据的耦合，因为业务代码必然会耦合不同的数据。<br>我参考了dobjs后，推荐将store拆分为action和dataModel两种。<br>action和dataModel一起组合成了页面的总store，dataModel只存放UI数据以及只涉及自身数据变化的action操作（在mobx严格模式中，修改数据一定要用action或flow）。<br>action store则是负责存放一些需要使用来自不同store数据的action操作。<br>我个人理解，dataModel更像MVC中的model，action store是controller，react components则是view，三者构成了mvc的结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- stores</span><br><span class=\"line\">    - actions</span><br><span class=\"line\">        - hotelListAction.js</span><br><span class=\"line\">    - dataModel</span><br><span class=\"line\">        - globalStatus.js</span><br><span class=\"line\">        - hotelList.js</span><br><span class=\"line\">    - index.js</span><br><span class=\"line\">// globalStatus</span><br><span class=\"line\">class GlobalStatus &#123;</span><br><span class=\"line\">    @observable isShowLoading = false;</span><br><span class=\"line\">    @action showLoading = () =&gt; &#123;</span><br><span class=\"line\">        this.isShowLoading = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @action hideLoading = () =&gt; &#123;</span><br><span class=\"line\">        this.isShowLoading = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// hotelList</span><br><span class=\"line\">class HotelList &#123;</span><br><span class=\"line\">    @observable hotels = []</span><br><span class=\"line\">    @action addHotels = (hotels) =&gt; &#123;</span><br><span class=\"line\">        this.hotels = [...toJS(this.hotels), ...hotels];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// hotelListAction</span><br><span class=\"line\">class HotelListAction &#123;</span><br><span class=\"line\">    fetchHotelList = flow(function *() &#123;</span><br><span class=\"line\">        const &#123;</span><br><span class=\"line\">            globalStatus,</span><br><span class=\"line\">            hotelList</span><br><span class=\"line\">        &#125; = this.rootStore</span><br><span class=\"line\">        globalStatus.showLoading();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            const res = yield fetch(&apos;/hoteList&apos;, params);</span><br><span class=\"line\">            hotelList.addHotels(res.hotels);</span><br><span class=\"line\">        &#125; catch (err) &#123;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            globalStatus.hideLoading();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(this)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1wm67mjihSKJjy0FiXXcuiFXa-601-435.png\" alt=\"store结构\"></p>\n<h2 id=\"细粒度的渲染\"><a href=\"#细粒度的渲染\" class=\"headerlink\" title=\"细粒度的渲染\"></a>细粒度的渲染</h2><p>observer可以给组件增加订阅功能，一旦收到数据变化的通知就会将组件重新渲染，从而做到更细粒度的更新，这是redux和react很难做到的，因为react中组件重新渲染基本是依赖于setState和接收到新的props，子组件的渲染几乎一定会伴随着父组件的渲染。<br>也许很多人没有注意到，mobx-react中还提供了一个Observer组件，这个组件接收一个render方法或者render props。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = () =&gt; &lt;h1&gt;hello, world&lt;/h1&gt;;</span><br><span class=\"line\">&lt;Observer&gt;&#123;() =&gt; &lt;App /&gt;&#125;&lt;/Observer&gt;</span><br><span class=\"line\">&lt;Observer render=&#123;() =&gt; &lt;App /&gt;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>也许你要问这个和observer有什么区别？还写的更加复杂了，下面这个例子对比起来会比较明显。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; observer, Observer, observable &#125; from &apos;mobx-react&apos;</span><br><span class=\"line\">const App = observer(</span><br><span class=\"line\">    (props) =&gt; &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">const Header = (props) =&gt; &lt;h1&gt;this is header&lt;/h1&gt;</span><br><span class=\"line\">const Footer = (props) =&gt; &lt;h1&gt;this is footer&lt;/h1&gt;</span><br><span class=\"line\">const Container = observer(</span><br><span class=\"line\">    (props) =&gt; &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;&gt;</span><br><span class=\"line\">                &lt;Header /&gt;</span><br><span class=\"line\">                &lt;App name=&#123;props.person.name&#125; /&gt;</span><br><span class=\"line\">                &lt;Footer /&gt;</span><br><span class=\"line\">            &lt;/&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">const person = observable(&#123;name: &quot;gyyin&quot;&#125;);</span><br><span class=\"line\">render(&lt;Container person=&#123;person&#125; /&gt;, document.getElementById(&quot;app&quot;));</span><br><span class=\"line\">person.name = &quot;world&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>上面这个代码，Container组件监听到person.name改变的时候会重新渲染，这样就导致了原本不需要重新渲染的Header和Footer也跟着渲染了，如果使用Observer就可以做到更细粒度的渲染。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = (props) =&gt; &lt;h1&gt;hello, &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">const Header = (props) =&gt; &lt;h1&gt;this is header&lt;/h1&gt;</span><br><span class=\"line\">const Footer = (props) =&gt; &lt;h1&gt;this is footer&lt;/h1&gt;</span><br><span class=\"line\">const Container = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;Header /&gt;</span><br><span class=\"line\">            &lt;Observer render=&#123;</span><br><span class=\"line\">                () =&gt; &lt;App name=&#123;props.person.name&#125; /&gt;</span><br><span class=\"line\">            &#125;&gt;</span><br><span class=\"line\">            &lt;Footer /&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const person = observable(&#123;name: &quot;gyyin&quot;&#125;);</span><br><span class=\"line\">render(&lt;Container person=&#123;person&#125; /&gt;, document.getElementById(&quot;app&quot;));</span><br><span class=\"line\">person.name = &quot;world&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>如果在Header和Footer里面做console.log，你会发现只有被Observer包裹的App组件进行了重新渲染，由于Container没有订阅数据变化，所以也不会重新渲染。<br>但如果不是对性能有极致的追求，observer已经足够了，大量的Observer会花费你很多精力来管理渲染问题。</p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/1bb41b726324\" target=\"_blank\" rel=\"noopener\">如何组织Mobx中的Store之一：构建State、拆分Action</a></li>\n<li><a href=\"https://qianduan.group/posts/59fc26fbbc868873528cd556cd556\" target=\"_blank\" rel=\"noopener\">面向未来的前端数据流框架 - dob</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011936772\" target=\"_blank\" rel=\"noopener\">为什么我们需要reselect</a></li>\n</ol>"},{"title":"塞尔达传说","date":"2018-10-14T09:48:46.000Z","_content":"## 海拉鲁王国\n### 海拉鲁\n位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。\n在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。\n相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。\n## 预言\n## 林克\n## 神兽\n## 英杰\n## 复活\n## 背叛\n## end","source":"_posts/塞尔达传说.md","raw":"---\ntitle: 塞尔达传说\ndate: 2018-10-14 17:48:46\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: \n    - 小说\n---\n## 海拉鲁王国\n### 海拉鲁\n位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。\n在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。\n相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。\n## 预言\n## 林克\n## 神兽\n## 英杰\n## 复活\n## 背叛\n## end","slug":"塞尔达传说","published":1,"updated":"2019-04-07T05:53:12.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrt8000wdrfdxtc67j0m","content":"<h2 id=\"海拉鲁王国\"><a href=\"#海拉鲁王国\" class=\"headerlink\" title=\"海拉鲁王国\"></a>海拉鲁王国</h2><h3 id=\"海拉鲁\"><a href=\"#海拉鲁\" class=\"headerlink\" title=\"海拉鲁\"></a>海拉鲁</h3><p>位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。<br>在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。<br>相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。</p>\n<h2 id=\"预言\"><a href=\"#预言\" class=\"headerlink\" title=\"预言\"></a>预言</h2><h2 id=\"林克\"><a href=\"#林克\" class=\"headerlink\" title=\"林克\"></a>林克</h2><h2 id=\"神兽\"><a href=\"#神兽\" class=\"headerlink\" title=\"神兽\"></a>神兽</h2><h2 id=\"英杰\"><a href=\"#英杰\" class=\"headerlink\" title=\"英杰\"></a>英杰</h2><h2 id=\"复活\"><a href=\"#复活\" class=\"headerlink\" title=\"复活\"></a>复活</h2><h2 id=\"背叛\"><a href=\"#背叛\" class=\"headerlink\" title=\"背叛\"></a>背叛</h2><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"海拉鲁王国\"><a href=\"#海拉鲁王国\" class=\"headerlink\" title=\"海拉鲁王国\"></a>海拉鲁王国</h2><h3 id=\"海拉鲁\"><a href=\"#海拉鲁\" class=\"headerlink\" title=\"海拉鲁\"></a>海拉鲁</h3><p>位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。<br>在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。<br>相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。</p>\n<h2 id=\"预言\"><a href=\"#预言\" class=\"headerlink\" title=\"预言\"></a>预言</h2><h2 id=\"林克\"><a href=\"#林克\" class=\"headerlink\" title=\"林克\"></a>林克</h2><h2 id=\"神兽\"><a href=\"#神兽\" class=\"headerlink\" title=\"神兽\"></a>神兽</h2><h2 id=\"英杰\"><a href=\"#英杰\" class=\"headerlink\" title=\"英杰\"></a>英杰</h2><h2 id=\"复活\"><a href=\"#复活\" class=\"headerlink\" title=\"复活\"></a>复活</h2><h2 id=\"背叛\"><a href=\"#背叛\" class=\"headerlink\" title=\"背叛\"></a>背叛</h2><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>"},{"title":"周报（2018-12-21）","date":"2018-12-21T09:24:16.000Z","_content":"对这周最大的感觉就是实在是太累了。\n前期一直在探索mobx和typescript的最佳实践，再加上对酒店列表页的逻辑不熟悉，导致进度非常慢。边看别人代码边写是最痛苦的，因为一不小心就被带入了别人的思维，我又觉得原来的代码写的过于耦合，就花费了很多的时间在拆分业务逻辑上面。\n<!-- more-->\n进度慢带来的后果就是只能加班来赶工，周末两天都在加班，让我很心累，下班后也几乎没有时间和精力去学习了，学了两周的数据结构就被我抛下了。\n关于mobx的store设计，我原本已经设计好了自己的store，后来发现了种种不合理的地方，再参考了酒店列表页原来的store后，决定按照酒店列表页的store来设计。刚开始的时候做起来挺正常的，问题就在后面，由于储存的是数组形式，导致很多场景下只能做遍历，原本我也想用对象储存，用数组保存key来保证顺序，但也懒得改动了，毕竟实在是没时间了。\n酒店列表页最好的store设计，就是给筛选项拼出来一个key，将这个key保存到已选的selected字段中，这样才能保证数据不冗余，这里所有的结构一定要是对象，如果涉及到排序，那就多存一个数组，保证顺序，用空间来换时间。\n至于其他的，这周确实是没啥更深刻的印象了，基本都在赶工。","source":"_posts/周报（2018-12-21）.md","raw":"---\ntitle: 周报（2018-12-21）\ndate: 2018-12-21 17:24:16\ntags:\n- 工作\n- 周报\ncategories: 周报\n---\n对这周最大的感觉就是实在是太累了。\n前期一直在探索mobx和typescript的最佳实践，再加上对酒店列表页的逻辑不熟悉，导致进度非常慢。边看别人代码边写是最痛苦的，因为一不小心就被带入了别人的思维，我又觉得原来的代码写的过于耦合，就花费了很多的时间在拆分业务逻辑上面。\n<!-- more-->\n进度慢带来的后果就是只能加班来赶工，周末两天都在加班，让我很心累，下班后也几乎没有时间和精力去学习了，学了两周的数据结构就被我抛下了。\n关于mobx的store设计，我原本已经设计好了自己的store，后来发现了种种不合理的地方，再参考了酒店列表页原来的store后，决定按照酒店列表页的store来设计。刚开始的时候做起来挺正常的，问题就在后面，由于储存的是数组形式，导致很多场景下只能做遍历，原本我也想用对象储存，用数组保存key来保证顺序，但也懒得改动了，毕竟实在是没时间了。\n酒店列表页最好的store设计，就是给筛选项拼出来一个key，将这个key保存到已选的selected字段中，这样才能保证数据不冗余，这里所有的结构一定要是对象，如果涉及到排序，那就多存一个数组，保证顺序，用空间来换时间。\n至于其他的，这周确实是没啥更深刻的印象了，基本都在赶工。","slug":"周报（2018-12-21）","published":1,"updated":"2019-04-07T05:57:33.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrta0010drfdgukygqaa","content":"<p>对这周最大的感觉就是实在是太累了。<br>前期一直在探索mobx和typescript的最佳实践，再加上对酒店列表页的逻辑不熟悉，导致进度非常慢。边看别人代码边写是最痛苦的，因为一不小心就被带入了别人的思维，我又觉得原来的代码写的过于耦合，就花费了很多的时间在拆分业务逻辑上面。<br><a id=\"more\"></a><br>进度慢带来的后果就是只能加班来赶工，周末两天都在加班，让我很心累，下班后也几乎没有时间和精力去学习了，学了两周的数据结构就被我抛下了。<br>关于mobx的store设计，我原本已经设计好了自己的store，后来发现了种种不合理的地方，再参考了酒店列表页原来的store后，决定按照酒店列表页的store来设计。刚开始的时候做起来挺正常的，问题就在后面，由于储存的是数组形式，导致很多场景下只能做遍历，原本我也想用对象储存，用数组保存key来保证顺序，但也懒得改动了，毕竟实在是没时间了。<br>酒店列表页最好的store设计，就是给筛选项拼出来一个key，将这个key保存到已选的selected字段中，这样才能保证数据不冗余，这里所有的结构一定要是对象，如果涉及到排序，那就多存一个数组，保证顺序，用空间来换时间。<br>至于其他的，这周确实是没啥更深刻的印象了，基本都在赶工。</p>\n","site":{"data":{}},"excerpt":"<p>对这周最大的感觉就是实在是太累了。<br>前期一直在探索mobx和typescript的最佳实践，再加上对酒店列表页的逻辑不熟悉，导致进度非常慢。边看别人代码边写是最痛苦的，因为一不小心就被带入了别人的思维，我又觉得原来的代码写的过于耦合，就花费了很多的时间在拆分业务逻辑上面。<br>","more":"<br>进度慢带来的后果就是只能加班来赶工，周末两天都在加班，让我很心累，下班后也几乎没有时间和精力去学习了，学了两周的数据结构就被我抛下了。<br>关于mobx的store设计，我原本已经设计好了自己的store，后来发现了种种不合理的地方，再参考了酒店列表页原来的store后，决定按照酒店列表页的store来设计。刚开始的时候做起来挺正常的，问题就在后面，由于储存的是数组形式，导致很多场景下只能做遍历，原本我也想用对象储存，用数组保存key来保证顺序，但也懒得改动了，毕竟实在是没时间了。<br>酒店列表页最好的store设计，就是给筛选项拼出来一个key，将这个key保存到已选的selected字段中，这样才能保证数据不冗余，这里所有的结构一定要是对象，如果涉及到排序，那就多存一个数组，保证顺序，用空间来换时间。<br>至于其他的，这周确实是没啥更深刻的印象了，基本都在赶工。</p>"},{"title":"实现一个bind函数","date":"2018-05-30T14:26:14.000Z","_content":"目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。\n## bind函数 ##\nbind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。\n```\nvar a = 10;\nvar test = function() {\n    console.log(this.a);\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest = test.bind({a: \"111\"})\nbindTest(); // 111\n```\n从上面这个例子可以看出来，bind函数改变了test函数中this的指向。\n除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。\n<!-- more -->\n### 柯里化 ###\nbind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。\n```\nvar test = function(b) {\n    return this.a + b;\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest1 = test.bind({a: 20});\nbindTest1(10); // 30\n// 这里的bind是个柯里化的函数\nvar bindTest2 = test.bind({a: 20}, 10);\nbindTest2(); // 30;\n```\n### 构造函数无效 ###\n其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。\n```\nvar a = 10;\nvar Test = function(a) {\n    console.log(this.a);\n}\nvar bindTest = Test.bind({a: 20});\nbindTest(); // 20\n// 在new的时候，Test中的this并没有指向bind中的对象\nnew bindTest(); // undefined\n```\n## 实现一个bind ##\n我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。\n\n然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。\n```\nFunction.prototype.bind = function() {\n    var args = arguments;\n    // 获取到新的上下文\n    var context = args[0];\n    // 保存当前的函数\n    var func = this;\n    // 获取其他的参数\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n        // 将两次获取到的参数合并\n        Array.prototype.push.apply(thisArgs, arguments)\n        // 使用apply改变上下文\n        return func.apply(context, thisArgs);\n    }\n    return returnFunc;\n}\n```\n这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。\n\n这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？\n\n所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？\n\n关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：[在js里面当new了一个对象时，这中间发生了什么？][1]\n\n所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。\n\n但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n  \tvar returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof returnFunc ? this : context, thisArgs);\n    }\n    return returnFunc\n}\nfunction foo(c) {\n    this.b = 100;\n    console.log(c);\n    return this.a;\n}\n\nvar func =  foo.bind({a:1});\nvar newFunc = new func() // undefined\n```\n但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。\n所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof func ? this : context, thisArgs);\n    }\n    returnFunc.prototype = new func()\n    return returnFunc\n}\n```\n这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：[Function.prototype.bind()][2]\n\n参考链接：\n+ [MDN：Function.prototype.bind()\n][2]\n+ [手写bind()函数，理解MDN上的标准Polyfill][3]\n\n\n  [1]: https://segmentfault.com/q/1010000006670906\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n  [3]: https://blog.csdn.net/u010552788/article/details/50850453","source":"_posts/实现一个bind函数.md","raw":"---\ntitle: 实现一个bind函数\ndate: 2018-05-30 22:26:14\ntags:\n- polyfill\n- 前端\n- 编程\ncategories: \n- 前端\n---\n目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。\n## bind函数 ##\nbind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。\n```\nvar a = 10;\nvar test = function() {\n    console.log(this.a);\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest = test.bind({a: \"111\"})\nbindTest(); // 111\n```\n从上面这个例子可以看出来，bind函数改变了test函数中this的指向。\n除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。\n<!-- more -->\n### 柯里化 ###\nbind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。\n```\nvar test = function(b) {\n    return this.a + b;\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest1 = test.bind({a: 20});\nbindTest1(10); // 30\n// 这里的bind是个柯里化的函数\nvar bindTest2 = test.bind({a: 20}, 10);\nbindTest2(); // 30;\n```\n### 构造函数无效 ###\n其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。\n```\nvar a = 10;\nvar Test = function(a) {\n    console.log(this.a);\n}\nvar bindTest = Test.bind({a: 20});\nbindTest(); // 20\n// 在new的时候，Test中的this并没有指向bind中的对象\nnew bindTest(); // undefined\n```\n## 实现一个bind ##\n我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。\n\n然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。\n```\nFunction.prototype.bind = function() {\n    var args = arguments;\n    // 获取到新的上下文\n    var context = args[0];\n    // 保存当前的函数\n    var func = this;\n    // 获取其他的参数\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n        // 将两次获取到的参数合并\n        Array.prototype.push.apply(thisArgs, arguments)\n        // 使用apply改变上下文\n        return func.apply(context, thisArgs);\n    }\n    return returnFunc;\n}\n```\n这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。\n\n这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？\n\n所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？\n\n关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：[在js里面当new了一个对象时，这中间发生了什么？][1]\n\n所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。\n\n但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n  \tvar returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof returnFunc ? this : context, thisArgs);\n    }\n    return returnFunc\n}\nfunction foo(c) {\n    this.b = 100;\n    console.log(c);\n    return this.a;\n}\n\nvar func =  foo.bind({a:1});\nvar newFunc = new func() // undefined\n```\n但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。\n所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof func ? this : context, thisArgs);\n    }\n    returnFunc.prototype = new func()\n    return returnFunc\n}\n```\n这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：[Function.prototype.bind()][2]\n\n参考链接：\n+ [MDN：Function.prototype.bind()\n][2]\n+ [手写bind()函数，理解MDN上的标准Polyfill][3]\n\n\n  [1]: https://segmentfault.com/q/1010000006670906\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n  [3]: https://blog.csdn.net/u010552788/article/details/50850453","slug":"实现一个bind函数","published":1,"updated":"2019-04-07T05:53:12.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtb0013drfd2khr09ow","content":"<p>目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。</p>\n<h2 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h2><p>bind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var test = function() &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest = test.bind(&#123;a: &quot;111&quot;&#125;)</span><br><span class=\"line\">bindTest(); // 111</span><br></pre></td></tr></table></figure></p>\n<p>从上面这个例子可以看出来，bind函数改变了test函数中this的指向。<br>除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。<br><a id=\"more\"></a></p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>bind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test = function(b) &#123;</span><br><span class=\"line\">    return this.a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest1 = test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest1(10); // 30</span><br><span class=\"line\">// 这里的bind是个柯里化的函数</span><br><span class=\"line\">var bindTest2 = test.bind(&#123;a: 20&#125;, 10);</span><br><span class=\"line\">bindTest2(); // 30;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"构造函数无效\"><a href=\"#构造函数无效\" class=\"headerlink\" title=\"构造函数无效\"></a>构造函数无效</h3><p>其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var Test = function(a) &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bindTest = Test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest(); // 20</span><br><span class=\"line\">// 在new的时候，Test中的this并没有指向bind中的对象</span><br><span class=\"line\">new bindTest(); // undefined</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现一个bind\"><a href=\"#实现一个bind\" class=\"headerlink\" title=\"实现一个bind\"></a>实现一个bind</h2><p>我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。</p>\n<p>然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments;</span><br><span class=\"line\">    // 获取到新的上下文</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    // 保存当前的函数</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    // 获取其他的参数</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">        // 将两次获取到的参数合并</span><br><span class=\"line\">        Array.prototype.push.apply(thisArgs, arguments)</span><br><span class=\"line\">        // 使用apply改变上下文</span><br><span class=\"line\">        return func.apply(context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。</p>\n<p>这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？</p>\n<p>所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？</p>\n<p>关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：<a href=\"https://segmentfault.com/q/1010000006670906\" target=\"_blank\" rel=\"noopener\">在js里面当new了一个对象时，这中间发生了什么？</a></p>\n<p>所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。</p>\n<p>但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">  \tvar returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof returnFunc ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo(c) &#123;</span><br><span class=\"line\">    this.b = 100;</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">    return this.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var func =  foo.bind(&#123;a:1&#125;);</span><br><span class=\"line\">var newFunc = new func() // undefined</span><br></pre></td></tr></table></figure></p>\n<p>但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。<br>所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof func ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    returnFunc.prototype = new func()</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN：Function.prototype.bind()\n</a></li>\n<li><a href=\"https://blog.csdn.net/u010552788/article/details/50850453\" target=\"_blank\" rel=\"noopener\">手写bind()函数，理解MDN上的标准Polyfill</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。</p>\n<h2 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h2><p>bind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var test = function() &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest = test.bind(&#123;a: &quot;111&quot;&#125;)</span><br><span class=\"line\">bindTest(); // 111</span><br></pre></td></tr></table></figure></p>\n<p>从上面这个例子可以看出来，bind函数改变了test函数中this的指向。<br>除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。<br>","more":"</p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>bind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test = function(b) &#123;</span><br><span class=\"line\">    return this.a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest1 = test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest1(10); // 30</span><br><span class=\"line\">// 这里的bind是个柯里化的函数</span><br><span class=\"line\">var bindTest2 = test.bind(&#123;a: 20&#125;, 10);</span><br><span class=\"line\">bindTest2(); // 30;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"构造函数无效\"><a href=\"#构造函数无效\" class=\"headerlink\" title=\"构造函数无效\"></a>构造函数无效</h3><p>其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var Test = function(a) &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bindTest = Test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest(); // 20</span><br><span class=\"line\">// 在new的时候，Test中的this并没有指向bind中的对象</span><br><span class=\"line\">new bindTest(); // undefined</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现一个bind\"><a href=\"#实现一个bind\" class=\"headerlink\" title=\"实现一个bind\"></a>实现一个bind</h2><p>我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。</p>\n<p>然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments;</span><br><span class=\"line\">    // 获取到新的上下文</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    // 保存当前的函数</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    // 获取其他的参数</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">        // 将两次获取到的参数合并</span><br><span class=\"line\">        Array.prototype.push.apply(thisArgs, arguments)</span><br><span class=\"line\">        // 使用apply改变上下文</span><br><span class=\"line\">        return func.apply(context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。</p>\n<p>这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？</p>\n<p>所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？</p>\n<p>关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：<a href=\"https://segmentfault.com/q/1010000006670906\" target=\"_blank\" rel=\"noopener\">在js里面当new了一个对象时，这中间发生了什么？</a></p>\n<p>所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。</p>\n<p>但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">  \tvar returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof returnFunc ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo(c) &#123;</span><br><span class=\"line\">    this.b = 100;</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">    return this.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var func =  foo.bind(&#123;a:1&#125;);</span><br><span class=\"line\">var newFunc = new func() // undefined</span><br></pre></td></tr></table></figure></p>\n<p>但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。<br>所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof func ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    returnFunc.prototype = new func()</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN：Function.prototype.bind()\n</a></li>\n<li><a href=\"https://blog.csdn.net/u010552788/article/details/50850453\" target=\"_blank\" rel=\"noopener\">手写bind()函数，理解MDN上的标准Polyfill</a></li>\n</ul>"},{"title":"富爸爸穷爸爸","date":"2018-04-19T14:39:02.000Z","_content":"去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。\n## 笔记 ##\n这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：\n+ 穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。\n+ 穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。\n+ 只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。\n+ 学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。\n+ 净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。\n+ 通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。\n+ 关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。\n<!-- more -->\n\n![2][2]\n\n![3][3]\n知乎大V温酒有更简单的总结: [《富爸爸，穷爸爸》这本书有何价值？][1]\n## 老鼠赛跑 ##\n前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。\n活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。\n这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。\n怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。\n游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。\n这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。\n如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。\n## 游戏心得 ##\n我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。\n游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。\n还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。\n## 总结 ##\n两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？\n之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。\n所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。\n\n[1]: https://www.zhihu.com/question/20528677/answer/169582274\n[2]: https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\n[3]: https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\n<head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/富爸爸穷爸爸.md","raw":"---\ntitle: 富爸爸穷爸爸\ndate: 2018-04-19 22:39:02\ntags:\n- 理财\n- 思考\ncategories: \n    - 理财\n---\n去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。\n## 笔记 ##\n这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：\n+ 穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。\n+ 穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。\n+ 只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。\n+ 学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。\n+ 净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。\n+ 通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。\n+ 关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。\n<!-- more -->\n\n![2][2]\n\n![3][3]\n知乎大V温酒有更简单的总结: [《富爸爸，穷爸爸》这本书有何价值？][1]\n## 老鼠赛跑 ##\n前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。\n活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。\n这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。\n怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。\n游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。\n这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。\n如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。\n## 游戏心得 ##\n我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。\n游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。\n还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。\n## 总结 ##\n两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？\n之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。\n所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。\n\n[1]: https://www.zhihu.com/question/20528677/answer/169582274\n[2]: https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\n[3]: https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\n<head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"富爸爸穷爸爸","published":1,"updated":"2019-04-07T05:53:12.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtd0016drfdo21o9jsx","content":"<p>去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。</p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：</p>\n<ul>\n<li>穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。</li>\n<li>穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。</li>\n<li>只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。</li>\n<li>学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。</li>\n<li>净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。</li>\n<li>通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。</li>\n<li>关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。<a id=\"more\"></a>\n</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\" alt=\"2\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\" alt=\"3\"><br>知乎大V温酒有更简单的总结: <a href=\"https://www.zhihu.com/question/20528677/answer/169582274\" target=\"_blank\" rel=\"noopener\">《富爸爸，穷爸爸》这本书有何价值？</a></p>\n<h2 id=\"老鼠赛跑\"><a href=\"#老鼠赛跑\" class=\"headerlink\" title=\"老鼠赛跑\"></a>老鼠赛跑</h2><p>前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。<br>活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。<br>这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。<br>怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。<br>游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。<br>这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。<br>如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。</p>\n<h2 id=\"游戏心得\"><a href=\"#游戏心得\" class=\"headerlink\" title=\"游戏心得\"></a>游戏心得</h2><p>我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。<br>游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。<br>还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？<br>之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。<br>所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。</p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：</p>\n<ul>\n<li>穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。</li>\n<li>穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。</li>\n<li>只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。</li>\n<li>学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。</li>\n<li>净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。</li>\n<li>通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。</li>\n<li>关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。","more":"</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\" alt=\"2\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\" alt=\"3\"><br>知乎大V温酒有更简单的总结: <a href=\"https://www.zhihu.com/question/20528677/answer/169582274\" target=\"_blank\" rel=\"noopener\">《富爸爸，穷爸爸》这本书有何价值？</a></p>\n<h2 id=\"老鼠赛跑\"><a href=\"#老鼠赛跑\" class=\"headerlink\" title=\"老鼠赛跑\"></a>老鼠赛跑</h2><p>前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。<br>活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。<br>这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。<br>怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。<br>游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。<br>这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。<br>如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。</p>\n<h2 id=\"游戏心得\"><a href=\"#游戏心得\" class=\"headerlink\" title=\"游戏心得\"></a>游戏心得</h2><p>我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。<br>游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。<br>还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？<br>之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。<br>所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"就算世界无童话","date":"2018-12-09T13:59:54.000Z","_content":"> 在这世间分享晚餐 \n> 有重担有万人分担 \n> 没有染污的晚空 \n> 会看见远方的花瓣\n> ......\n> 如所有苦衷都得到体谅 \n> 如占据会被换成分享 \n> 如挨穷仍然能被敬仰 \n> 挑剔的懂得赞赏 \n> 呼吸会更加清香\n> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 卫兰《就算世界无童话》\n\n冒着淅沥沥的小雨去买菜，回来时我看到路边叉腰站着一个抽烟的流浪汉大叔。\n心有不忍，遂骑车去买了两个肉包、一杯豆浆后又找到他。\n“我刚去那边买了两个包子，请你吃吧。”\n“不不，我不用，你拿走吧。”\n“天这么冷，趁着还是热的，你还是吃了吧。”我无奈的摇了摇头，“我给你放这里了，我走了。”\n我转身骑上摩拜，头也不回地走了，我也不知道他最后有没有吃，或许我伤了他的自尊心。\n又想起来另外一件事。\n上个月去三亚玩，我们在第一海鲜市场那里吃饭，一个乞丐（抱歉，我觉得这样称呼比较好）进来，走到我们桌边，求我们给他点钱。我已经多年没有带现金的习惯了，只能笑着说不好意思，我没带现金。可他却一直站在我旁边不走，我有些尴尬。我旁边的小伙伴出于好心，掏出钱包把所有的硬币都给了他，他这才离去。\n<!-- more -->\n虽然这两件事也算不上对比，但毕竟也是两种生活态度。在大街上经常能看到乞丐，但我却很少施舍，也不是说我没有同情心。我在朋友圈看到水滴筹也经常会捐款，我还在支付宝开通了月捐，虽然钱不多，但毕业一年来也多多少少捐了有上千块了，我很希望能够帮助那些真正困难的人。\n曾经看到这么一则新闻，日本流浪汉宁愿饿死也不愿意去乞讨，他们中有很多人每天靠着回收垃圾的钱来维持着生活。即使能够去领政府的保障金，他们依然认为「自食其力，是做人的尊严。」\n我很佩服他们的这种气节。但我也并非要说这两种生活方式哪个更好，站在道德制高点去谴责别人，毕竟连韩信都乞讨过。能够活着是人最重要的事情，至于怎么活着则是自己的生活态度。\n希望这个世界能够少一些穷苦的人，真心愿每一个人都能健健康康、吃饱穿暖地活着。\n\n\n\n\n\n","source":"_posts/就算世界无童话.md","raw":"---\ntitle: 就算世界无童话\ndate: 2018-12-09 21:59:54\ntags:\n- 生活\n- 理想\ncategories:\n- 生活\n---\n> 在这世间分享晚餐 \n> 有重担有万人分担 \n> 没有染污的晚空 \n> 会看见远方的花瓣\n> ......\n> 如所有苦衷都得到体谅 \n> 如占据会被换成分享 \n> 如挨穷仍然能被敬仰 \n> 挑剔的懂得赞赏 \n> 呼吸会更加清香\n> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 卫兰《就算世界无童话》\n\n冒着淅沥沥的小雨去买菜，回来时我看到路边叉腰站着一个抽烟的流浪汉大叔。\n心有不忍，遂骑车去买了两个肉包、一杯豆浆后又找到他。\n“我刚去那边买了两个包子，请你吃吧。”\n“不不，我不用，你拿走吧。”\n“天这么冷，趁着还是热的，你还是吃了吧。”我无奈的摇了摇头，“我给你放这里了，我走了。”\n我转身骑上摩拜，头也不回地走了，我也不知道他最后有没有吃，或许我伤了他的自尊心。\n又想起来另外一件事。\n上个月去三亚玩，我们在第一海鲜市场那里吃饭，一个乞丐（抱歉，我觉得这样称呼比较好）进来，走到我们桌边，求我们给他点钱。我已经多年没有带现金的习惯了，只能笑着说不好意思，我没带现金。可他却一直站在我旁边不走，我有些尴尬。我旁边的小伙伴出于好心，掏出钱包把所有的硬币都给了他，他这才离去。\n<!-- more -->\n虽然这两件事也算不上对比，但毕竟也是两种生活态度。在大街上经常能看到乞丐，但我却很少施舍，也不是说我没有同情心。我在朋友圈看到水滴筹也经常会捐款，我还在支付宝开通了月捐，虽然钱不多，但毕业一年来也多多少少捐了有上千块了，我很希望能够帮助那些真正困难的人。\n曾经看到这么一则新闻，日本流浪汉宁愿饿死也不愿意去乞讨，他们中有很多人每天靠着回收垃圾的钱来维持着生活。即使能够去领政府的保障金，他们依然认为「自食其力，是做人的尊严。」\n我很佩服他们的这种气节。但我也并非要说这两种生活方式哪个更好，站在道德制高点去谴责别人，毕竟连韩信都乞讨过。能够活着是人最重要的事情，至于怎么活着则是自己的生活态度。\n希望这个世界能够少一些穷苦的人，真心愿每一个人都能健健康康、吃饱穿暖地活着。\n\n\n\n\n\n","slug":"就算世界无童话","published":1,"updated":"2019-04-07T05:53:13.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtf0019drfdpdn9d5ch","content":"<blockquote>\n<p>在这世间分享晚餐<br>有重担有万人分担<br>没有染污的晚空<br>会看见远方的花瓣<br>……<br>如所有苦衷都得到体谅<br>如占据会被换成分享<br>如挨穷仍然能被敬仰<br>挑剔的懂得赞赏<br>呼吸会更加清香<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 卫兰《就算世界无童话》</p>\n</blockquote>\n<p>冒着淅沥沥的小雨去买菜，回来时我看到路边叉腰站着一个抽烟的流浪汉大叔。<br>心有不忍，遂骑车去买了两个肉包、一杯豆浆后又找到他。<br>“我刚去那边买了两个包子，请你吃吧。”<br>“不不，我不用，你拿走吧。”<br>“天这么冷，趁着还是热的，你还是吃了吧。”我无奈的摇了摇头，“我给你放这里了，我走了。”<br>我转身骑上摩拜，头也不回地走了，我也不知道他最后有没有吃，或许我伤了他的自尊心。<br>又想起来另外一件事。<br>上个月去三亚玩，我们在第一海鲜市场那里吃饭，一个乞丐（抱歉，我觉得这样称呼比较好）进来，走到我们桌边，求我们给他点钱。我已经多年没有带现金的习惯了，只能笑着说不好意思，我没带现金。可他却一直站在我旁边不走，我有些尴尬。我旁边的小伙伴出于好心，掏出钱包把所有的硬币都给了他，他这才离去。<br><a id=\"more\"></a><br>虽然这两件事也算不上对比，但毕竟也是两种生活态度。在大街上经常能看到乞丐，但我却很少施舍，也不是说我没有同情心。我在朋友圈看到水滴筹也经常会捐款，我还在支付宝开通了月捐，虽然钱不多，但毕业一年来也多多少少捐了有上千块了，我很希望能够帮助那些真正困难的人。<br>曾经看到这么一则新闻，日本流浪汉宁愿饿死也不愿意去乞讨，他们中有很多人每天靠着回收垃圾的钱来维持着生活。即使能够去领政府的保障金，他们依然认为「自食其力，是做人的尊严。」<br>我很佩服他们的这种气节。但我也并非要说这两种生活方式哪个更好，站在道德制高点去谴责别人，毕竟连韩信都乞讨过。能够活着是人最重要的事情，至于怎么活着则是自己的生活态度。<br>希望这个世界能够少一些穷苦的人，真心愿每一个人都能健健康康、吃饱穿暖地活着。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在这世间分享晚餐<br>有重担有万人分担<br>没有染污的晚空<br>会看见远方的花瓣<br>……<br>如所有苦衷都得到体谅<br>如占据会被换成分享<br>如挨穷仍然能被敬仰<br>挑剔的懂得赞赏<br>呼吸会更加清香<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 卫兰《就算世界无童话》</p>\n</blockquote>\n<p>冒着淅沥沥的小雨去买菜，回来时我看到路边叉腰站着一个抽烟的流浪汉大叔。<br>心有不忍，遂骑车去买了两个肉包、一杯豆浆后又找到他。<br>“我刚去那边买了两个包子，请你吃吧。”<br>“不不，我不用，你拿走吧。”<br>“天这么冷，趁着还是热的，你还是吃了吧。”我无奈的摇了摇头，“我给你放这里了，我走了。”<br>我转身骑上摩拜，头也不回地走了，我也不知道他最后有没有吃，或许我伤了他的自尊心。<br>又想起来另外一件事。<br>上个月去三亚玩，我们在第一海鲜市场那里吃饭，一个乞丐（抱歉，我觉得这样称呼比较好）进来，走到我们桌边，求我们给他点钱。我已经多年没有带现金的习惯了，只能笑着说不好意思，我没带现金。可他却一直站在我旁边不走，我有些尴尬。我旁边的小伙伴出于好心，掏出钱包把所有的硬币都给了他，他这才离去。<br>","more":"<br>虽然这两件事也算不上对比，但毕竟也是两种生活态度。在大街上经常能看到乞丐，但我却很少施舍，也不是说我没有同情心。我在朋友圈看到水滴筹也经常会捐款，我还在支付宝开通了月捐，虽然钱不多，但毕业一年来也多多少少捐了有上千块了，我很希望能够帮助那些真正困难的人。<br>曾经看到这么一则新闻，日本流浪汉宁愿饿死也不愿意去乞讨，他们中有很多人每天靠着回收垃圾的钱来维持着生活。即使能够去领政府的保障金，他们依然认为「自食其力，是做人的尊严。」<br>我很佩服他们的这种气节。但我也并非要说这两种生活方式哪个更好，站在道德制高点去谴责别人，毕竟连韩信都乞讨过。能够活着是人最重要的事情，至于怎么活着则是自己的生活态度。<br>希望这个世界能够少一些穷苦的人，真心愿每一个人都能健健康康、吃饱穿暖地活着。</p>"},{"title":"校招的一些感受","date":"2017-09-21T06:35:32.000Z","_content":"首先我想说的就是，最近很累，真的很累，整个人几乎都要垮掉了。\n\n之前我在杭州和武汉某两个不知名的创业公司实习，9月的时候满怀期待的回来参加秋招。虽然我一直对自己的技术很有自信，但是也不敢奢求bat这三家，当时目标是蘑菇街，因为我很想去杭州，但是从没想到秋招是如此艰难。\n\n9月5号参加了校招的第一次笔试。京东的笔试可能对别人来说不算难，但是对我这个C++和操作系统基础薄弱的人来说真的很难。之后的猿题库、腾讯、网易、美团、阿里这些更是考一个挂一个，直到9月中旬我都没有拿到面试机会，因为我操作系统和算法真的不行。拼多多也挂在了一面的算法上面，美团主要考安卓和ios，360全部考的都是c++，我不理解为什么前端的笔试都几乎不考前端。搜狐一面直接十分钟把我请了出来，搜狐问的很难很刁钻，但是一起去的做前端的研究生表示问的很简单，看起来还是会有学历歧视的。\n\n18号在图书馆考完滴滴后，因为编程题又一次没写出来了，我忍不住哭了出来。这个时候秋招已经过了一半，很多大公司的招聘基本上都已经结束了。巨大的压力让我几乎崩溃，每天都睡不着，小公司我看不上，大公司又看不上我，我质问自己我真的这么菜吗？连面试机会都拿不到？难道真的就像小新学长说的一样毕业后只能找个月薪4k的工作了？我很不服气，我对自己的前端技术原本非常自信，相信自己只要过了笔试，面试都会很有把握。可是面对一次次的笔试失败，刚开始还能安慰自己，后来我慢慢开始觉得自己是个废物，几乎已经绝望了，甚至打算秋招过后等补招，或者找个小公司先呆着。\n\n屋漏偏逢连夜雨。前几天我妈打电话告诉我姥姥已经下了病危了，可能最多到十一了，可是我正处于校招的关键时刻，没法抽身回家。我每天压力山大，不知道怎么取舍，可能是前20年都一路顺风顺水吧，也是自己大学浪费了太多时光，我感觉这一刻也许是我人生最低谷了，自己也知道如果错过了校招不知道又要多奋斗多少年。\n\n还好有我远在百度的小新学长一直鼓励我，他坚信我有实力能进百度和阿里。我觉得，一个丧失自信心的人真的已经和咸鱼没有区别了。\n\n真正的转机是某天晚上发现百度官网的状态变成了面试安排中，我当时真的很开心，好像一下子被从悬崖边上拉了回来一样，虽然当时依然心里没底。\n\n百度一面的哥哥是个老乡，人很好，问的东西都很细节和基础，大概面了70多分钟，他表示时间已经超了，今天就先到这里吧。当时我觉得自己答的还蛮好，不至于挂在一面上面，果然当天就收到了二面通知。\n\n百度一面结束之后，我还收到了百度外卖面试的通知，虽然我对百度外卖很不好看，但毕竟是百度的子公司，当时觉得黎明可能真的要来了。\n\n百度二面是个女面试官，人很严肃，给我的压力很大，面了50分钟左右，面完后感觉答的不是很好，说不定挂了，但是当天也收到了三面通知，当时我真的快激动哭了，我想就算我三面挂了，过了百度前两面也多多少少证明了自己的实力。\n\n百度三面恰好和百度外卖HR面时间冲突了，当时我希望能够协调一下时间，可惜最后双方都不愿意改时间，最后我被迫放弃了百度外卖的面试。\n\n百度三面也是一位人很好的哥哥，也面了快一个小时，问了一些技术方面的问题，手写了几道算法，然后就是问自己的职业规划，怎么学习的，性格问题等等，感觉自己答的还可以。百度的面试考察的基础和细节挺多的，给人一种非常靠谱的感觉。\n\n在秋招前我甚至都不相信自己能有机会进bat，因为我只学了大半年前端，bat对我来说是那么遥不可及，现在几乎只有一步之遥。九月前中旬的打击几乎让我一蹶不振，还好我真的就像自己说的一样，抗压能力强，心态调整比较快，真的很感谢百度，百度让我拾回了信心，以至于后面其他公司的面试我几乎都无压力到了终面。\n\n昨天晚上参加商汤科技的笔试时，我妈给我打电话，我没接。等考完后我回了电话，我妈告诉我姥姥已经走了，我没想到她走的那么快，甚至没来得及见最后一面，我真的太自私了，为了自己的前途甚至没去见亲人最后一面。\n\n所以，我准备这两天回家处理一下姥姥的后事，好好修养一阵子，慢慢地等百度的通知。如果过了，那我就打算在武汉找个实习，把接下来的面试都拒掉，毕竟这段时间压力实在太大了，自己也太没出息了，现在边写这篇文章边哭，可能是前阵子的压力确实大到难以承受了吧。\n\n更新：百度最后还是挂了，但我也证明了自己的实力，没有什么好遗憾的了，剩下的链家、新浪和携程我会尽力拿下的。\n\n最后，我想对现在没找到工作的小伙伴们说：不要放弃，也不要绝望，要坚信最好的总是最后才来。\n\n引用谢安琪的一句歌词，我可以被这个世界淘汰, 但不可以被世界击败。\n\n￼","source":"_posts/校招的一些感受.md","raw":"---\ntitle: 校招的一些感受\ndate: 2017-09-21 14:35:32\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n首先我想说的就是，最近很累，真的很累，整个人几乎都要垮掉了。\n\n之前我在杭州和武汉某两个不知名的创业公司实习，9月的时候满怀期待的回来参加秋招。虽然我一直对自己的技术很有自信，但是也不敢奢求bat这三家，当时目标是蘑菇街，因为我很想去杭州，但是从没想到秋招是如此艰难。\n\n9月5号参加了校招的第一次笔试。京东的笔试可能对别人来说不算难，但是对我这个C++和操作系统基础薄弱的人来说真的很难。之后的猿题库、腾讯、网易、美团、阿里这些更是考一个挂一个，直到9月中旬我都没有拿到面试机会，因为我操作系统和算法真的不行。拼多多也挂在了一面的算法上面，美团主要考安卓和ios，360全部考的都是c++，我不理解为什么前端的笔试都几乎不考前端。搜狐一面直接十分钟把我请了出来，搜狐问的很难很刁钻，但是一起去的做前端的研究生表示问的很简单，看起来还是会有学历歧视的。\n\n18号在图书馆考完滴滴后，因为编程题又一次没写出来了，我忍不住哭了出来。这个时候秋招已经过了一半，很多大公司的招聘基本上都已经结束了。巨大的压力让我几乎崩溃，每天都睡不着，小公司我看不上，大公司又看不上我，我质问自己我真的这么菜吗？连面试机会都拿不到？难道真的就像小新学长说的一样毕业后只能找个月薪4k的工作了？我很不服气，我对自己的前端技术原本非常自信，相信自己只要过了笔试，面试都会很有把握。可是面对一次次的笔试失败，刚开始还能安慰自己，后来我慢慢开始觉得自己是个废物，几乎已经绝望了，甚至打算秋招过后等补招，或者找个小公司先呆着。\n\n屋漏偏逢连夜雨。前几天我妈打电话告诉我姥姥已经下了病危了，可能最多到十一了，可是我正处于校招的关键时刻，没法抽身回家。我每天压力山大，不知道怎么取舍，可能是前20年都一路顺风顺水吧，也是自己大学浪费了太多时光，我感觉这一刻也许是我人生最低谷了，自己也知道如果错过了校招不知道又要多奋斗多少年。\n\n还好有我远在百度的小新学长一直鼓励我，他坚信我有实力能进百度和阿里。我觉得，一个丧失自信心的人真的已经和咸鱼没有区别了。\n\n真正的转机是某天晚上发现百度官网的状态变成了面试安排中，我当时真的很开心，好像一下子被从悬崖边上拉了回来一样，虽然当时依然心里没底。\n\n百度一面的哥哥是个老乡，人很好，问的东西都很细节和基础，大概面了70多分钟，他表示时间已经超了，今天就先到这里吧。当时我觉得自己答的还蛮好，不至于挂在一面上面，果然当天就收到了二面通知。\n\n百度一面结束之后，我还收到了百度外卖面试的通知，虽然我对百度外卖很不好看，但毕竟是百度的子公司，当时觉得黎明可能真的要来了。\n\n百度二面是个女面试官，人很严肃，给我的压力很大，面了50分钟左右，面完后感觉答的不是很好，说不定挂了，但是当天也收到了三面通知，当时我真的快激动哭了，我想就算我三面挂了，过了百度前两面也多多少少证明了自己的实力。\n\n百度三面恰好和百度外卖HR面时间冲突了，当时我希望能够协调一下时间，可惜最后双方都不愿意改时间，最后我被迫放弃了百度外卖的面试。\n\n百度三面也是一位人很好的哥哥，也面了快一个小时，问了一些技术方面的问题，手写了几道算法，然后就是问自己的职业规划，怎么学习的，性格问题等等，感觉自己答的还可以。百度的面试考察的基础和细节挺多的，给人一种非常靠谱的感觉。\n\n在秋招前我甚至都不相信自己能有机会进bat，因为我只学了大半年前端，bat对我来说是那么遥不可及，现在几乎只有一步之遥。九月前中旬的打击几乎让我一蹶不振，还好我真的就像自己说的一样，抗压能力强，心态调整比较快，真的很感谢百度，百度让我拾回了信心，以至于后面其他公司的面试我几乎都无压力到了终面。\n\n昨天晚上参加商汤科技的笔试时，我妈给我打电话，我没接。等考完后我回了电话，我妈告诉我姥姥已经走了，我没想到她走的那么快，甚至没来得及见最后一面，我真的太自私了，为了自己的前途甚至没去见亲人最后一面。\n\n所以，我准备这两天回家处理一下姥姥的后事，好好修养一阵子，慢慢地等百度的通知。如果过了，那我就打算在武汉找个实习，把接下来的面试都拒掉，毕竟这段时间压力实在太大了，自己也太没出息了，现在边写这篇文章边哭，可能是前阵子的压力确实大到难以承受了吧。\n\n更新：百度最后还是挂了，但我也证明了自己的实力，没有什么好遗憾的了，剩下的链家、新浪和携程我会尽力拿下的。\n\n最后，我想对现在没找到工作的小伙伴们说：不要放弃，也不要绝望，要坚信最好的总是最后才来。\n\n引用谢安琪的一句歌词，我可以被这个世界淘汰, 但不可以被世界击败。\n\n￼","slug":"校招的一些感受","published":1,"updated":"2019-04-07T05:53:13.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtg001cdrfdo1hoxag0","content":"<p>首先我想说的就是，最近很累，真的很累，整个人几乎都要垮掉了。</p>\n<p>之前我在杭州和武汉某两个不知名的创业公司实习，9月的时候满怀期待的回来参加秋招。虽然我一直对自己的技术很有自信，但是也不敢奢求bat这三家，当时目标是蘑菇街，因为我很想去杭州，但是从没想到秋招是如此艰难。</p>\n<p>9月5号参加了校招的第一次笔试。京东的笔试可能对别人来说不算难，但是对我这个C++和操作系统基础薄弱的人来说真的很难。之后的猿题库、腾讯、网易、美团、阿里这些更是考一个挂一个，直到9月中旬我都没有拿到面试机会，因为我操作系统和算法真的不行。拼多多也挂在了一面的算法上面，美团主要考安卓和ios，360全部考的都是c++，我不理解为什么前端的笔试都几乎不考前端。搜狐一面直接十分钟把我请了出来，搜狐问的很难很刁钻，但是一起去的做前端的研究生表示问的很简单，看起来还是会有学历歧视的。</p>\n<p>18号在图书馆考完滴滴后，因为编程题又一次没写出来了，我忍不住哭了出来。这个时候秋招已经过了一半，很多大公司的招聘基本上都已经结束了。巨大的压力让我几乎崩溃，每天都睡不着，小公司我看不上，大公司又看不上我，我质问自己我真的这么菜吗？连面试机会都拿不到？难道真的就像小新学长说的一样毕业后只能找个月薪4k的工作了？我很不服气，我对自己的前端技术原本非常自信，相信自己只要过了笔试，面试都会很有把握。可是面对一次次的笔试失败，刚开始还能安慰自己，后来我慢慢开始觉得自己是个废物，几乎已经绝望了，甚至打算秋招过后等补招，或者找个小公司先呆着。</p>\n<p>屋漏偏逢连夜雨。前几天我妈打电话告诉我姥姥已经下了病危了，可能最多到十一了，可是我正处于校招的关键时刻，没法抽身回家。我每天压力山大，不知道怎么取舍，可能是前20年都一路顺风顺水吧，也是自己大学浪费了太多时光，我感觉这一刻也许是我人生最低谷了，自己也知道如果错过了校招不知道又要多奋斗多少年。</p>\n<p>还好有我远在百度的小新学长一直鼓励我，他坚信我有实力能进百度和阿里。我觉得，一个丧失自信心的人真的已经和咸鱼没有区别了。</p>\n<p>真正的转机是某天晚上发现百度官网的状态变成了面试安排中，我当时真的很开心，好像一下子被从悬崖边上拉了回来一样，虽然当时依然心里没底。</p>\n<p>百度一面的哥哥是个老乡，人很好，问的东西都很细节和基础，大概面了70多分钟，他表示时间已经超了，今天就先到这里吧。当时我觉得自己答的还蛮好，不至于挂在一面上面，果然当天就收到了二面通知。</p>\n<p>百度一面结束之后，我还收到了百度外卖面试的通知，虽然我对百度外卖很不好看，但毕竟是百度的子公司，当时觉得黎明可能真的要来了。</p>\n<p>百度二面是个女面试官，人很严肃，给我的压力很大，面了50分钟左右，面完后感觉答的不是很好，说不定挂了，但是当天也收到了三面通知，当时我真的快激动哭了，我想就算我三面挂了，过了百度前两面也多多少少证明了自己的实力。</p>\n<p>百度三面恰好和百度外卖HR面时间冲突了，当时我希望能够协调一下时间，可惜最后双方都不愿意改时间，最后我被迫放弃了百度外卖的面试。</p>\n<p>百度三面也是一位人很好的哥哥，也面了快一个小时，问了一些技术方面的问题，手写了几道算法，然后就是问自己的职业规划，怎么学习的，性格问题等等，感觉自己答的还可以。百度的面试考察的基础和细节挺多的，给人一种非常靠谱的感觉。</p>\n<p>在秋招前我甚至都不相信自己能有机会进bat，因为我只学了大半年前端，bat对我来说是那么遥不可及，现在几乎只有一步之遥。九月前中旬的打击几乎让我一蹶不振，还好我真的就像自己说的一样，抗压能力强，心态调整比较快，真的很感谢百度，百度让我拾回了信心，以至于后面其他公司的面试我几乎都无压力到了终面。</p>\n<p>昨天晚上参加商汤科技的笔试时，我妈给我打电话，我没接。等考完后我回了电话，我妈告诉我姥姥已经走了，我没想到她走的那么快，甚至没来得及见最后一面，我真的太自私了，为了自己的前途甚至没去见亲人最后一面。</p>\n<p>所以，我准备这两天回家处理一下姥姥的后事，好好修养一阵子，慢慢地等百度的通知。如果过了，那我就打算在武汉找个实习，把接下来的面试都拒掉，毕竟这段时间压力实在太大了，自己也太没出息了，现在边写这篇文章边哭，可能是前阵子的压力确实大到难以承受了吧。</p>\n<p>更新：百度最后还是挂了，但我也证明了自己的实力，没有什么好遗憾的了，剩下的链家、新浪和携程我会尽力拿下的。</p>\n<p>最后，我想对现在没找到工作的小伙伴们说：不要放弃，也不要绝望，要坚信最好的总是最后才来。</p>\n<p>引用谢安琪的一句歌词，我可以被这个世界淘汰, 但不可以被世界击败。</p>\n<p>￼</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先我想说的就是，最近很累，真的很累，整个人几乎都要垮掉了。</p>\n<p>之前我在杭州和武汉某两个不知名的创业公司实习，9月的时候满怀期待的回来参加秋招。虽然我一直对自己的技术很有自信，但是也不敢奢求bat这三家，当时目标是蘑菇街，因为我很想去杭州，但是从没想到秋招是如此艰难。</p>\n<p>9月5号参加了校招的第一次笔试。京东的笔试可能对别人来说不算难，但是对我这个C++和操作系统基础薄弱的人来说真的很难。之后的猿题库、腾讯、网易、美团、阿里这些更是考一个挂一个，直到9月中旬我都没有拿到面试机会，因为我操作系统和算法真的不行。拼多多也挂在了一面的算法上面，美团主要考安卓和ios，360全部考的都是c++，我不理解为什么前端的笔试都几乎不考前端。搜狐一面直接十分钟把我请了出来，搜狐问的很难很刁钻，但是一起去的做前端的研究生表示问的很简单，看起来还是会有学历歧视的。</p>\n<p>18号在图书馆考完滴滴后，因为编程题又一次没写出来了，我忍不住哭了出来。这个时候秋招已经过了一半，很多大公司的招聘基本上都已经结束了。巨大的压力让我几乎崩溃，每天都睡不着，小公司我看不上，大公司又看不上我，我质问自己我真的这么菜吗？连面试机会都拿不到？难道真的就像小新学长说的一样毕业后只能找个月薪4k的工作了？我很不服气，我对自己的前端技术原本非常自信，相信自己只要过了笔试，面试都会很有把握。可是面对一次次的笔试失败，刚开始还能安慰自己，后来我慢慢开始觉得自己是个废物，几乎已经绝望了，甚至打算秋招过后等补招，或者找个小公司先呆着。</p>\n<p>屋漏偏逢连夜雨。前几天我妈打电话告诉我姥姥已经下了病危了，可能最多到十一了，可是我正处于校招的关键时刻，没法抽身回家。我每天压力山大，不知道怎么取舍，可能是前20年都一路顺风顺水吧，也是自己大学浪费了太多时光，我感觉这一刻也许是我人生最低谷了，自己也知道如果错过了校招不知道又要多奋斗多少年。</p>\n<p>还好有我远在百度的小新学长一直鼓励我，他坚信我有实力能进百度和阿里。我觉得，一个丧失自信心的人真的已经和咸鱼没有区别了。</p>\n<p>真正的转机是某天晚上发现百度官网的状态变成了面试安排中，我当时真的很开心，好像一下子被从悬崖边上拉了回来一样，虽然当时依然心里没底。</p>\n<p>百度一面的哥哥是个老乡，人很好，问的东西都很细节和基础，大概面了70多分钟，他表示时间已经超了，今天就先到这里吧。当时我觉得自己答的还蛮好，不至于挂在一面上面，果然当天就收到了二面通知。</p>\n<p>百度一面结束之后，我还收到了百度外卖面试的通知，虽然我对百度外卖很不好看，但毕竟是百度的子公司，当时觉得黎明可能真的要来了。</p>\n<p>百度二面是个女面试官，人很严肃，给我的压力很大，面了50分钟左右，面完后感觉答的不是很好，说不定挂了，但是当天也收到了三面通知，当时我真的快激动哭了，我想就算我三面挂了，过了百度前两面也多多少少证明了自己的实力。</p>\n<p>百度三面恰好和百度外卖HR面时间冲突了，当时我希望能够协调一下时间，可惜最后双方都不愿意改时间，最后我被迫放弃了百度外卖的面试。</p>\n<p>百度三面也是一位人很好的哥哥，也面了快一个小时，问了一些技术方面的问题，手写了几道算法，然后就是问自己的职业规划，怎么学习的，性格问题等等，感觉自己答的还可以。百度的面试考察的基础和细节挺多的，给人一种非常靠谱的感觉。</p>\n<p>在秋招前我甚至都不相信自己能有机会进bat，因为我只学了大半年前端，bat对我来说是那么遥不可及，现在几乎只有一步之遥。九月前中旬的打击几乎让我一蹶不振，还好我真的就像自己说的一样，抗压能力强，心态调整比较快，真的很感谢百度，百度让我拾回了信心，以至于后面其他公司的面试我几乎都无压力到了终面。</p>\n<p>昨天晚上参加商汤科技的笔试时，我妈给我打电话，我没接。等考完后我回了电话，我妈告诉我姥姥已经走了，我没想到她走的那么快，甚至没来得及见最后一面，我真的太自私了，为了自己的前途甚至没去见亲人最后一面。</p>\n<p>所以，我准备这两天回家处理一下姥姥的后事，好好修养一阵子，慢慢地等百度的通知。如果过了，那我就打算在武汉找个实习，把接下来的面试都拒掉，毕竟这段时间压力实在太大了，自己也太没出息了，现在边写这篇文章边哭，可能是前阵子的压力确实大到难以承受了吧。</p>\n<p>更新：百度最后还是挂了，但我也证明了自己的实力，没有什么好遗憾的了，剩下的链家、新浪和携程我会尽力拿下的。</p>\n<p>最后，我想对现在没找到工作的小伙伴们说：不要放弃，也不要绝望，要坚信最好的总是最后才来。</p>\n<p>引用谢安琪的一句歌词，我可以被这个世界淘汰, 但不可以被世界击败。</p>\n<p>￼</p>\n"},{"title":"梦境小说","date":"2015-04-19T04:54:09.000Z","_content":"“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。\n所有人都胆战心惊的看着他和旁边那具已经腐烂的尸体，心里都明白再过不久眼前这个人也会变成这样。\n......\n在一个公寓里面，潘琳珊刚刚醒来。”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，仿若犯了一场大病。\n她走到阳台，想透透气，但是眼前这噩梦般的一幕让她两腿发软。\n马路上随处都有晕倒的人，救护车来来往往，简直就像人间炼狱。\nHE病毒！！！她突然想起来了什么，赶紧回到房间，对蔡汶宾冷笑着说：”这个世界完蛋了，HE病毒无药可治”\n\n“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！快开门！！！再不开门我要撞开了！！”，门外那人粗暴地嚷嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。\n\n“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。\n\n“这些以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。\n\n潘琳珊上气不接下气的跟在蔡汶宾的身后。\n\n“我的车就停在前面，我们快上车”，蔡汶宾边说边不时回头看。\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/梦境小说.md","raw":"---\ntitle: 梦境小说\ndate: 2015-04-19 12:54:09\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: \n    - 小说\n---\n“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。\n所有人都胆战心惊的看着他和旁边那具已经腐烂的尸体，心里都明白再过不久眼前这个人也会变成这样。\n......\n在一个公寓里面，潘琳珊刚刚醒来。”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，仿若犯了一场大病。\n她走到阳台，想透透气，但是眼前这噩梦般的一幕让她两腿发软。\n马路上随处都有晕倒的人，救护车来来往往，简直就像人间炼狱。\nHE病毒！！！她突然想起来了什么，赶紧回到房间，对蔡汶宾冷笑着说：”这个世界完蛋了，HE病毒无药可治”\n\n“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！快开门！！！再不开门我要撞开了！！”，门外那人粗暴地嚷嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。\n\n“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。\n\n“这些以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。\n\n潘琳珊上气不接下气的跟在蔡汶宾的身后。\n\n“我的车就停在前面，我们快上车”，蔡汶宾边说边不时回头看。\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"梦境小说","published":1,"updated":"2019-04-07T05:53:13.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrti001gdrfdjuik4u3f","content":"<p>“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。<br>所有人都胆战心惊的看着他和旁边那具已经腐烂的尸体，心里都明白再过不久眼前这个人也会变成这样。<br>……<br>在一个公寓里面，潘琳珊刚刚醒来。”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，仿若犯了一场大病。<br>她走到阳台，想透透气，但是眼前这噩梦般的一幕让她两腿发软。<br>马路上随处都有晕倒的人，救护车来来往往，简直就像人间炼狱。<br>HE病毒！！！她突然想起来了什么，赶紧回到房间，对蔡汶宾冷笑着说：”这个世界完蛋了，HE病毒无药可治”</p>\n<p>“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！快开门！！！再不开门我要撞开了！！”，门外那人粗暴地嚷嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。</p>\n<p>“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。</p>\n<p>“这些以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。</p>\n<p>潘琳珊上气不接下气的跟在蔡汶宾的身后。</p>\n<p>“我的车就停在前面，我们快上车”，蔡汶宾边说边不时回头看。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"","more":"<p>“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。<br>所有人都胆战心惊的看着他和旁边那具已经腐烂的尸体，心里都明白再过不久眼前这个人也会变成这样。<br>……<br>在一个公寓里面，潘琳珊刚刚醒来。”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，仿若犯了一场大病。<br>她走到阳台，想透透气，但是眼前这噩梦般的一幕让她两腿发软。<br>马路上随处都有晕倒的人，救护车来来往往，简直就像人间炼狱。<br>HE病毒！！！她突然想起来了什么，赶紧回到房间，对蔡汶宾冷笑着说：”这个世界完蛋了，HE病毒无药可治”</p>\n<p>“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！快开门！！！再不开门我要撞开了！！”，门外那人粗暴地嚷嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。</p>\n<p>“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。</p>\n<p>“这些以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。</p>\n<p>潘琳珊上气不接下气的跟在蔡汶宾的身后。</p>\n<p>“我的车就停在前面，我们快上车”，蔡汶宾边说边不时回头看。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"流光飞舞","date":"2018-03-10T06:02:18.000Z","_content":"**[流光飞舞 - 陈淑桦][1]**\n\n**作词： 黄霑**\n**作曲： 雷颂德**\n**演唱： 陈淑桦**\n\n半冷半暖的秋\n静静烫贴身边\n\n默默看着流光飞舞\n晚风中几片红叶\n惹得身心酥软绵绵\n\n半醉半醒之间\n盈盈笑眼千千\n\n就让我像云端飘雪\n以冰清轻轻吻面\n带出一波一波缠绵\n\n留人间几回爱\n迎浮生千重变\n\n与有情人 做快乐事\n未问是劫是缘\n\n似柳也似春风\n伴着你过春天\n\n就让你埋首烟波里\n放出心底狂热\n抱一身春雨绵绵\n\n  [1]: https://music.163.com/song?id=92634&userid=45188587","source":"_posts/流光飞舞.md","raw":"---\ntitle: 流光飞舞\ndate: 2018-03-10 14:02:18\ntags:\n- 歌曲\n- 电影\ncategories: 音乐\n---\n**[流光飞舞 - 陈淑桦][1]**\n\n**作词： 黄霑**\n**作曲： 雷颂德**\n**演唱： 陈淑桦**\n\n半冷半暖的秋\n静静烫贴身边\n\n默默看着流光飞舞\n晚风中几片红叶\n惹得身心酥软绵绵\n\n半醉半醒之间\n盈盈笑眼千千\n\n就让我像云端飘雪\n以冰清轻轻吻面\n带出一波一波缠绵\n\n留人间几回爱\n迎浮生千重变\n\n与有情人 做快乐事\n未问是劫是缘\n\n似柳也似春风\n伴着你过春天\n\n就让你埋首烟波里\n放出心底狂热\n抱一身春雨绵绵\n\n  [1]: https://music.163.com/song?id=92634&userid=45188587","slug":"流光飞舞","published":1,"updated":"2019-04-07T05:53:13.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtk001kdrfdbwgdajv9","content":"<p><strong><a href=\"https://music.163.com/song?id=92634&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">流光飞舞 - 陈淑桦</a></strong></p>\n<p><strong>作词： 黄霑</strong><br><strong>作曲： 雷颂德</strong><br><strong>演唱： 陈淑桦</strong></p>\n<p>半冷半暖的秋<br>静静烫贴身边</p>\n<p>默默看着流光飞舞<br>晚风中几片红叶<br>惹得身心酥软绵绵</p>\n<p>半醉半醒之间<br>盈盈笑眼千千</p>\n<p>就让我像云端飘雪<br>以冰清轻轻吻面<br>带出一波一波缠绵</p>\n<p>留人间几回爱<br>迎浮生千重变</p>\n<p>与有情人 做快乐事<br>未问是劫是缘</p>\n<p>似柳也似春风<br>伴着你过春天</p>\n<p>就让你埋首烟波里<br>放出心底狂热<br>抱一身春雨绵绵</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong><a href=\"https://music.163.com/song?id=92634&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">流光飞舞 - 陈淑桦</a></strong></p>\n<p><strong>作词： 黄霑</strong><br><strong>作曲： 雷颂德</strong><br><strong>演唱： 陈淑桦</strong></p>\n<p>半冷半暖的秋<br>静静烫贴身边</p>\n<p>默默看着流光飞舞<br>晚风中几片红叶<br>惹得身心酥软绵绵</p>\n<p>半醉半醒之间<br>盈盈笑眼千千</p>\n<p>就让我像云端飘雪<br>以冰清轻轻吻面<br>带出一波一波缠绵</p>\n<p>留人间几回爱<br>迎浮生千重变</p>\n<p>与有情人 做快乐事<br>未问是劫是缘</p>\n<p>似柳也似春风<br>伴着你过春天</p>\n<p>就让你埋首烟波里<br>放出心底狂热<br>抱一身春雨绵绵</p>\n"},{"title":"深入理解react","date":"2018-11-25T03:52:01.000Z","_content":"\n最近在看react-lite源码，发觉以前对react的理解实在浮浅，这里基于对react-lite的理解记录了一些以前疏忽的点。\n## createElement和component\n在react里面，经过babel的解析后，jsx会变成createElement执行后的结果。\n```javascript\nconst Test = (props) => <h1>hello, {props.name}</h1>;\n<Test name=\"world\" />\n```\n`<Test name=\"world\" />`经过babel解析后会变为createElement(Test, {name: \"world})，这里的Test就是上面的Test方法，name就是Test方法里面接受的props中的name。\n实际上当我们从开始加载到渲染的时候做了下面几步：\n```javascript\n// 1. babel解析jsx\n<Test name=\"world\"> -> createElement(Test, {name: \"world\"})\n// 2. 对函数组件和class组件进行处理\nconst props = {name: world};\nconst newTest = new Component(props);\n// 3. 执行render方法（函数组件直接执行）\nnewTest.render();\n// Test(props);\n```\n## key\nreact中的diff会根据子组件的key来对比前后两次virtual dom（即使前后两次子组件顺序打乱，也能根据key来匹配到），所以这里的key最好使用不会变化的值，比如id之类的，最好别用index，如果有两个子组件互换了位置，那么index就会导致diff全部失效。\n<!-- more -->\n## cloneElement\n原来对cloneElement的理解就是类似cloneElement(App, {})这种写法，现在看了实现之后才理解。原来第一个参数应该是一个reactElement，而不是一个reactComponent，应该是`<App />`，而不是App，这个也确实是我没有好好看文档。\n## 短路操作符判断\n为什么布尔类型和null类型的值可以这么写，而数字类型却不行？\n```javascript\nshowLoading && <Loading />\n```\n如果showLoading是个数字0，那么最后渲染出来的居然是个0，但是showLoading是个false或者null，最后就什么都不渲染，这个是为什么？ 首先上述代码会被babel编译为如下格式：\n\n```javascript\nshowLoading && React.createElement(Loading, null)\n```\n而如果showLoading是false或者0的时候，就会短路掉后面的组件，最后渲染出来的应该是个showLoading。 但是react-lite在渲染子组件的时候（递归渲染虚拟dom），会判断当前是否为布尔类型和null，如果是布尔类型或者null，则会被直接过滤掉。\n\n```javascript\nfunction collectChild(child, children) {\n    if (child != null && typeof child !== 'boolean') {\n        if (!child.vtype) {\n            // convert immutablejs data\n            if (child.toJS) {\n                child = child.toJS()\n                if (_.isArr(child)) {\n                    _.flatEach(child, collectChild, children)\n                } else {\n                    collectChild(child, children)\n                }\n                return\n            }\n            child = '' + child\n        }\n        children[children.length] = child\n    }\n}\n```\n## setState\nreact里面setState后不会立即更新，但在某些场景下也会立即更新，下面这几种情况打印的值你都能回答的上来吗？\n```javascript\nclass App extends React.Component {\n    state = {\n        count: 0;\n    }\n    test() {\n        this.setState({\n            count: this.state.count + 1\n        }); \n        console.log(this.state.count); // 此时为0\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为0\n    }\n    test2() {\n        setTimeout(() => {\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为1\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为2\n        })\n    }\n    test3() {\n        Promise.resolve().then(() => {\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为1\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为2\n        })\n    }\n    test4() {\n        this.setState(prevState => {\n            console.log(prevState.count); // 0\n        return {\n            count: prevState.count + 1\n        };\n        });\n        this.setState(prevState => {\n            console.log(prevState.count); // 1\n            return {\n                count: prevState.count + 1\n            };\n        });\n    }\n    async test4() {\n        await 0;\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为1\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为2\n    }\n}\n```\n在react中为了防止多次setState导致多次渲染带来不必要的性能开销，所以会将待更新的state放到队列中，等到合适的时机（一般是组件第一次渲染或触发事件后）后进行batchUpdate，所以在setState后无法立即拿到更新后的state，很多人说setState是异步的，setState表现确实是异步，只是里面没有用异步代码实现。\n如果是给setState传入一个函数，这个函数是执行前一个setState后才被调用的，所以函数返回的参数可以拿到更新后的state。\n但是如果将setState在异步方法中（setTimeout、Promise等等）调用，由于方法是异步的，会导致组件pending结束后才执行异步方法中的setState，这个时候由于组件已经不处于pending状态了，会导致setState立即执行，这时通过this.state可以拿到最新的值。\n\n## ref\nref用到原生的标签上，可以直接在组件内部用this.refs.xxx的方法获取到真实DOM。\nref用到组件上，需要用ReactDOM.findDOMNode(this.refs.xxx)的方式来获取到这个组件对应的DOM节点。\n## shouldComponentUpdate\n当shouldComponentUpdate返回false的时候，组件没有重新渲染，但是更新后的state和props已经挂载到了组件上面，这个时候如果打印state和props，会发现拿到的已经是更新后的了。\n## 合成事件\nreact里面将可以冒泡的事件委托到了document上，通过向上遍历父节点模拟了冒泡的机制。\n比如当触发onClick事件时，会先执行target元素的onClick事件回调函数，如果回调函数里面阻止了冒泡，就不会继续向上查找父元素。否则，就会继续向上查找父元素，并执行其onClick的回调函数。\n当跳出循环的时候，就会开始进行组件的批量更新（如果没有收到新的props或者state队列为空就不会进行更新）。\n\n\n\n","source":"_posts/深入理解react.md","raw":"---\ntitle: 深入理解react\ndate: 2018-11-25 11:52:01\ncategories: [前端, react]\ntags:\n    - react\n    - 前端\n---\n\n最近在看react-lite源码，发觉以前对react的理解实在浮浅，这里基于对react-lite的理解记录了一些以前疏忽的点。\n## createElement和component\n在react里面，经过babel的解析后，jsx会变成createElement执行后的结果。\n```javascript\nconst Test = (props) => <h1>hello, {props.name}</h1>;\n<Test name=\"world\" />\n```\n`<Test name=\"world\" />`经过babel解析后会变为createElement(Test, {name: \"world})，这里的Test就是上面的Test方法，name就是Test方法里面接受的props中的name。\n实际上当我们从开始加载到渲染的时候做了下面几步：\n```javascript\n// 1. babel解析jsx\n<Test name=\"world\"> -> createElement(Test, {name: \"world\"})\n// 2. 对函数组件和class组件进行处理\nconst props = {name: world};\nconst newTest = new Component(props);\n// 3. 执行render方法（函数组件直接执行）\nnewTest.render();\n// Test(props);\n```\n## key\nreact中的diff会根据子组件的key来对比前后两次virtual dom（即使前后两次子组件顺序打乱，也能根据key来匹配到），所以这里的key最好使用不会变化的值，比如id之类的，最好别用index，如果有两个子组件互换了位置，那么index就会导致diff全部失效。\n<!-- more -->\n## cloneElement\n原来对cloneElement的理解就是类似cloneElement(App, {})这种写法，现在看了实现之后才理解。原来第一个参数应该是一个reactElement，而不是一个reactComponent，应该是`<App />`，而不是App，这个也确实是我没有好好看文档。\n## 短路操作符判断\n为什么布尔类型和null类型的值可以这么写，而数字类型却不行？\n```javascript\nshowLoading && <Loading />\n```\n如果showLoading是个数字0，那么最后渲染出来的居然是个0，但是showLoading是个false或者null，最后就什么都不渲染，这个是为什么？ 首先上述代码会被babel编译为如下格式：\n\n```javascript\nshowLoading && React.createElement(Loading, null)\n```\n而如果showLoading是false或者0的时候，就会短路掉后面的组件，最后渲染出来的应该是个showLoading。 但是react-lite在渲染子组件的时候（递归渲染虚拟dom），会判断当前是否为布尔类型和null，如果是布尔类型或者null，则会被直接过滤掉。\n\n```javascript\nfunction collectChild(child, children) {\n    if (child != null && typeof child !== 'boolean') {\n        if (!child.vtype) {\n            // convert immutablejs data\n            if (child.toJS) {\n                child = child.toJS()\n                if (_.isArr(child)) {\n                    _.flatEach(child, collectChild, children)\n                } else {\n                    collectChild(child, children)\n                }\n                return\n            }\n            child = '' + child\n        }\n        children[children.length] = child\n    }\n}\n```\n## setState\nreact里面setState后不会立即更新，但在某些场景下也会立即更新，下面这几种情况打印的值你都能回答的上来吗？\n```javascript\nclass App extends React.Component {\n    state = {\n        count: 0;\n    }\n    test() {\n        this.setState({\n            count: this.state.count + 1\n        }); \n        console.log(this.state.count); // 此时为0\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为0\n    }\n    test2() {\n        setTimeout(() => {\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为1\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为2\n        })\n    }\n    test3() {\n        Promise.resolve().then(() => {\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为1\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count); // 此时为2\n        })\n    }\n    test4() {\n        this.setState(prevState => {\n            console.log(prevState.count); // 0\n        return {\n            count: prevState.count + 1\n        };\n        });\n        this.setState(prevState => {\n            console.log(prevState.count); // 1\n            return {\n                count: prevState.count + 1\n            };\n        });\n    }\n    async test4() {\n        await 0;\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为1\n        this.setState({\n            count: this.state.count + 1\n        });\n        console.log(this.state.count); // 此时为2\n    }\n}\n```\n在react中为了防止多次setState导致多次渲染带来不必要的性能开销，所以会将待更新的state放到队列中，等到合适的时机（一般是组件第一次渲染或触发事件后）后进行batchUpdate，所以在setState后无法立即拿到更新后的state，很多人说setState是异步的，setState表现确实是异步，只是里面没有用异步代码实现。\n如果是给setState传入一个函数，这个函数是执行前一个setState后才被调用的，所以函数返回的参数可以拿到更新后的state。\n但是如果将setState在异步方法中（setTimeout、Promise等等）调用，由于方法是异步的，会导致组件pending结束后才执行异步方法中的setState，这个时候由于组件已经不处于pending状态了，会导致setState立即执行，这时通过this.state可以拿到最新的值。\n\n## ref\nref用到原生的标签上，可以直接在组件内部用this.refs.xxx的方法获取到真实DOM。\nref用到组件上，需要用ReactDOM.findDOMNode(this.refs.xxx)的方式来获取到这个组件对应的DOM节点。\n## shouldComponentUpdate\n当shouldComponentUpdate返回false的时候，组件没有重新渲染，但是更新后的state和props已经挂载到了组件上面，这个时候如果打印state和props，会发现拿到的已经是更新后的了。\n## 合成事件\nreact里面将可以冒泡的事件委托到了document上，通过向上遍历父节点模拟了冒泡的机制。\n比如当触发onClick事件时，会先执行target元素的onClick事件回调函数，如果回调函数里面阻止了冒泡，就不会继续向上查找父元素。否则，就会继续向上查找父元素，并执行其onClick的回调函数。\n当跳出循环的时候，就会开始进行组件的批量更新（如果没有收到新的props或者state队列为空就不会进行更新）。\n\n\n\n","slug":"深入理解react","published":1,"updated":"2019-04-07T05:53:13.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtm001ndrfdwqe46blu","content":"<p>最近在看react-lite源码，发觉以前对react的理解实在浮浅，这里基于对react-lite的理解记录了一些以前疏忽的点。</p>\n<h2 id=\"createElement和component\"><a href=\"#createElement和component\" class=\"headerlink\" title=\"createElement和component\"></a>createElement和component</h2><p>在react里面，经过babel的解析后，jsx会变成createElement执行后的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Test = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &lt;h1&gt;hello, &#123;props.name&#125;&lt;<span class=\"regexp\">/h1&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;Test name=\"world\" /</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;Test name=&quot;world&quot; /&gt;</code>经过babel解析后会变为createElement(Test, {name: “world})，这里的Test就是上面的Test方法，name就是Test方法里面接受的props中的name。<br>实际上当我们从开始加载到渲染的时候做了下面几步：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. babel解析jsx</span></span><br><span class=\"line\">&lt;Test name=<span class=\"string\">\"world\"</span>&gt; -&gt; createElement(Test, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"world\"</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 2. 对函数组件和class组件进行处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> props = &#123;<span class=\"attr\">name</span>: world&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newTest = <span class=\"keyword\">new</span> Component(props);</span><br><span class=\"line\"><span class=\"comment\">// 3. 执行render方法（函数组件直接执行）</span></span><br><span class=\"line\">newTest.render();</span><br><span class=\"line\"><span class=\"comment\">// Test(props);</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>react中的diff会根据子组件的key来对比前后两次virtual dom（即使前后两次子组件顺序打乱，也能根据key来匹配到），所以这里的key最好使用不会变化的值，比如id之类的，最好别用index，如果有两个子组件互换了位置，那么index就会导致diff全部失效。<br><a id=\"more\"></a></p>\n<h2 id=\"cloneElement\"><a href=\"#cloneElement\" class=\"headerlink\" title=\"cloneElement\"></a>cloneElement</h2><p>原来对cloneElement的理解就是类似cloneElement(App, {})这种写法，现在看了实现之后才理解。原来第一个参数应该是一个reactElement，而不是一个reactComponent，应该是<code>&lt;App /&gt;</code>，而不是App，这个也确实是我没有好好看文档。</p>\n<h2 id=\"短路操作符判断\"><a href=\"#短路操作符判断\" class=\"headerlink\" title=\"短路操作符判断\"></a>短路操作符判断</h2><p>为什么布尔类型和null类型的值可以这么写，而数字类型却不行？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showLoading &amp;&amp; &lt;Loading /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果showLoading是个数字0，那么最后渲染出来的居然是个0，但是showLoading是个false或者null，最后就什么都不渲染，这个是为什么？ 首先上述代码会被babel编译为如下格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showLoading &amp;&amp; React.createElement(Loading, <span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>而如果showLoading是false或者0的时候，就会短路掉后面的组件，最后渲染出来的应该是个showLoading。 但是react-lite在渲染子组件的时候（递归渲染虚拟dom），会判断当前是否为布尔类型和null，如果是布尔类型或者null，则会被直接过滤掉。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">collectChild</span>(<span class=\"params\">child, children</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span> child !== <span class=\"string\">'boolean'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!child.vtype) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// convert immutablejs data</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.toJS) &#123;</span><br><span class=\"line\">                child = child.toJS()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_.isArr(child)) &#123;</span><br><span class=\"line\">                    _.flatEach(child, collectChild, children)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    collectChild(child, children)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child = <span class=\"string\">''</span> + child</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        children[children.length] = child</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h2><p>react里面setState后不会立即更新，但在某些场景下也会立即更新，下面这几种情况打印的值你都能回答的上来吗？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        count: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;); </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为0</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test2() &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test3() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test4() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(prevState.count); <span class=\"comment\">// 0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            count: prevState.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(prevState.count); <span class=\"comment\">// 1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                count: prevState.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> test4() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在react中为了防止多次setState导致多次渲染带来不必要的性能开销，所以会将待更新的state放到队列中，等到合适的时机（一般是组件第一次渲染或触发事件后）后进行batchUpdate，所以在setState后无法立即拿到更新后的state，很多人说setState是异步的，setState表现确实是异步，只是里面没有用异步代码实现。<br>如果是给setState传入一个函数，这个函数是执行前一个setState后才被调用的，所以函数返回的参数可以拿到更新后的state。<br>但是如果将setState在异步方法中（setTimeout、Promise等等）调用，由于方法是异步的，会导致组件pending结束后才执行异步方法中的setState，这个时候由于组件已经不处于pending状态了，会导致setState立即执行，这时通过this.state可以拿到最新的值。</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>ref用到原生的标签上，可以直接在组件内部用this.refs.xxx的方法获取到真实DOM。<br>ref用到组件上，需要用ReactDOM.findDOMNode(this.refs.xxx)的方式来获取到这个组件对应的DOM节点。</p>\n<h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>当shouldComponentUpdate返回false的时候，组件没有重新渲染，但是更新后的state和props已经挂载到了组件上面，这个时候如果打印state和props，会发现拿到的已经是更新后的了。</p>\n<h2 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h2><p>react里面将可以冒泡的事件委托到了document上，通过向上遍历父节点模拟了冒泡的机制。<br>比如当触发onClick事件时，会先执行target元素的onClick事件回调函数，如果回调函数里面阻止了冒泡，就不会继续向上查找父元素。否则，就会继续向上查找父元素，并执行其onClick的回调函数。<br>当跳出循环的时候，就会开始进行组件的批量更新（如果没有收到新的props或者state队列为空就不会进行更新）。</p>\n","site":{"data":{}},"excerpt":"<p>最近在看react-lite源码，发觉以前对react的理解实在浮浅，这里基于对react-lite的理解记录了一些以前疏忽的点。</p>\n<h2 id=\"createElement和component\"><a href=\"#createElement和component\" class=\"headerlink\" title=\"createElement和component\"></a>createElement和component</h2><p>在react里面，经过babel的解析后，jsx会变成createElement执行后的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Test = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &lt;h1&gt;hello, &#123;props.name&#125;&lt;<span class=\"regexp\">/h1&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;Test name=\"world\" /</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;Test name=&quot;world&quot; /&gt;</code>经过babel解析后会变为createElement(Test, {name: “world})，这里的Test就是上面的Test方法，name就是Test方法里面接受的props中的name。<br>实际上当我们从开始加载到渲染的时候做了下面几步：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. babel解析jsx</span></span><br><span class=\"line\">&lt;Test name=<span class=\"string\">\"world\"</span>&gt; -&gt; createElement(Test, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"world\"</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 2. 对函数组件和class组件进行处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> props = &#123;<span class=\"attr\">name</span>: world&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newTest = <span class=\"keyword\">new</span> Component(props);</span><br><span class=\"line\"><span class=\"comment\">// 3. 执行render方法（函数组件直接执行）</span></span><br><span class=\"line\">newTest.render();</span><br><span class=\"line\"><span class=\"comment\">// Test(props);</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>react中的diff会根据子组件的key来对比前后两次virtual dom（即使前后两次子组件顺序打乱，也能根据key来匹配到），所以这里的key最好使用不会变化的值，比如id之类的，最好别用index，如果有两个子组件互换了位置，那么index就会导致diff全部失效。<br>","more":"</p>\n<h2 id=\"cloneElement\"><a href=\"#cloneElement\" class=\"headerlink\" title=\"cloneElement\"></a>cloneElement</h2><p>原来对cloneElement的理解就是类似cloneElement(App, {})这种写法，现在看了实现之后才理解。原来第一个参数应该是一个reactElement，而不是一个reactComponent，应该是<code>&lt;App /&gt;</code>，而不是App，这个也确实是我没有好好看文档。</p>\n<h2 id=\"短路操作符判断\"><a href=\"#短路操作符判断\" class=\"headerlink\" title=\"短路操作符判断\"></a>短路操作符判断</h2><p>为什么布尔类型和null类型的值可以这么写，而数字类型却不行？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showLoading &amp;&amp; &lt;Loading /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果showLoading是个数字0，那么最后渲染出来的居然是个0，但是showLoading是个false或者null，最后就什么都不渲染，这个是为什么？ 首先上述代码会被babel编译为如下格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showLoading &amp;&amp; React.createElement(Loading, <span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>而如果showLoading是false或者0的时候，就会短路掉后面的组件，最后渲染出来的应该是个showLoading。 但是react-lite在渲染子组件的时候（递归渲染虚拟dom），会判断当前是否为布尔类型和null，如果是布尔类型或者null，则会被直接过滤掉。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">collectChild</span>(<span class=\"params\">child, children</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span> child !== <span class=\"string\">'boolean'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!child.vtype) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// convert immutablejs data</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.toJS) &#123;</span><br><span class=\"line\">                child = child.toJS()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_.isArr(child)) &#123;</span><br><span class=\"line\">                    _.flatEach(child, collectChild, children)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    collectChild(child, children)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child = <span class=\"string\">''</span> + child</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        children[children.length] = child</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h2><p>react里面setState后不会立即更新，但在某些场景下也会立即更新，下面这几种情况打印的值你都能回答的上来吗？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        count: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;); </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为0</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test2() &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test3() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    test4() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(prevState.count); <span class=\"comment\">// 0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            count: prevState.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(prevState.count); <span class=\"comment\">// 1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                count: prevState.count + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> test4() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为1</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count); <span class=\"comment\">// 此时为2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在react中为了防止多次setState导致多次渲染带来不必要的性能开销，所以会将待更新的state放到队列中，等到合适的时机（一般是组件第一次渲染或触发事件后）后进行batchUpdate，所以在setState后无法立即拿到更新后的state，很多人说setState是异步的，setState表现确实是异步，只是里面没有用异步代码实现。<br>如果是给setState传入一个函数，这个函数是执行前一个setState后才被调用的，所以函数返回的参数可以拿到更新后的state。<br>但是如果将setState在异步方法中（setTimeout、Promise等等）调用，由于方法是异步的，会导致组件pending结束后才执行异步方法中的setState，这个时候由于组件已经不处于pending状态了，会导致setState立即执行，这时通过this.state可以拿到最新的值。</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>ref用到原生的标签上，可以直接在组件内部用this.refs.xxx的方法获取到真实DOM。<br>ref用到组件上，需要用ReactDOM.findDOMNode(this.refs.xxx)的方式来获取到这个组件对应的DOM节点。</p>\n<h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>当shouldComponentUpdate返回false的时候，组件没有重新渲染，但是更新后的state和props已经挂载到了组件上面，这个时候如果打印state和props，会发现拿到的已经是更新后的了。</p>\n<h2 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h2><p>react里面将可以冒泡的事件委托到了document上，通过向上遍历父节点模拟了冒泡的机制。<br>比如当触发onClick事件时，会先执行target元素的onClick事件回调函数，如果回调函数里面阻止了冒泡，就不会继续向上查找父元素。否则，就会继续向上查找父元素，并执行其onClick的回调函数。<br>当跳出循环的时候，就会开始进行组件的批量更新（如果没有收到新的props或者state队列为空就不会进行更新）。</p>"},{"title":"深夜思考","date":"2018-03-19T15:53:26.000Z","_content":"很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。\n\n人之所以不快乐，是因为能力配不上自己的欲望。\n\n最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。\n\n以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。\n\n还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。\n<!-- more -->\n那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。\n\n大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。\n\n学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。\n\n整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。\n\n可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？\n\n曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。\n\n当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。\n\n前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？\n\n我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？\n\n年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。\n\n我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？\n\n很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。\n\n哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。\n<head>    \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/深夜思考.md","raw":"---\ntitle: 深夜思考\ndate: 2018-03-19 23:53:26\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。\n\n人之所以不快乐，是因为能力配不上自己的欲望。\n\n最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。\n\n以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。\n\n还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。\n<!-- more -->\n那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。\n\n大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。\n\n学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。\n\n整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。\n\n可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？\n\n曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。\n\n当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。\n\n前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？\n\n我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？\n\n年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。\n\n我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？\n\n很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。\n\n哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。\n<head>    \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"深夜思考","published":1,"updated":"2019-04-07T05:53:13.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrto001qdrfdj54z4xn5","content":"<p>很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。</p>\n<p>人之所以不快乐，是因为能力配不上自己的欲望。</p>\n<p>最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。</p>\n<p>以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。</p>\n<p>还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。<br><a id=\"more\"></a><br>那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。</p>\n<p>大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。</p>\n<p>学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。</p>\n<p>整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。</p>\n<p>可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？</p>\n<p>曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。</p>\n<p>当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。</p>\n<p>前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？</p>\n<p>我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？</p>\n<p>年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。</p>\n<p>我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？</p>\n<p>很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。</p>\n<p>哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。</p>\n<p>人之所以不快乐，是因为能力配不上自己的欲望。</p>\n<p>最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。</p>\n<p>以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。</p>\n<p>还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。<br>","more":"<br>那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。</p>\n<p>大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。</p>\n<p>学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。</p>\n<p>整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。</p>\n<p>可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？</p>\n<p>曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。</p>\n<p>当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。</p>\n<p>前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？</p>\n<p>我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？</p>\n<p>年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。</p>\n<p>我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？</p>\n<p>很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。</p>\n<p>哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"牡丹亭外","date":"2018-04-18T02:22:48.000Z","_content":"**[牡丹亭外 - 陈升][1]**\n\n**作词： 陈升**\n**作曲： 陈升**\n**演唱： 陈升**\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n李郎一梦已过往\n风流人儿如今在何方\n\n从古到今说来话\n不过是情而已\n\n这人间苦什么\n怕不能遇见你\n\n这世界有点假\n可我莫名爱上她\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n牡丹亭外雨纷纷\n谁是归人说不准\n是归人啊你说分明\n你把我心放哪儿\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n可我最爱是天然\n风流人儿如今在何方\n\n不管是谁啊\n躲不过 还是情而已\n\n你问我怕什么\n怕不能遇见你\n\n是否你走过了我身边\n恍恍惑惑一瞬间\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人断了魂啊\n听歌的人最无情\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n  [1]: https://music.163.com/dj?id=1368759629&userid=45188587","source":"_posts/牡丹亭外.md","raw":"---\ntitle: 牡丹亭外\ndate: 2018-04-18 10:22:48\ntags:\n- 歌曲\n- 陈升\ncategories: 音乐\n---\n**[牡丹亭外 - 陈升][1]**\n\n**作词： 陈升**\n**作曲： 陈升**\n**演唱： 陈升**\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n李郎一梦已过往\n风流人儿如今在何方\n\n从古到今说来话\n不过是情而已\n\n这人间苦什么\n怕不能遇见你\n\n这世界有点假\n可我莫名爱上她\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n牡丹亭外雨纷纷\n谁是归人说不准\n是归人啊你说分明\n你把我心放哪儿\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n可我最爱是天然\n风流人儿如今在何方\n\n不管是谁啊\n躲不过 还是情而已\n\n你问我怕什么\n怕不能遇见你\n\n是否你走过了我身边\n恍恍惑惑一瞬间\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人断了魂啊\n听歌的人最无情\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n  [1]: https://music.163.com/dj?id=1368759629&userid=45188587","slug":"牡丹亭外","published":1,"updated":"2018-05-25T12:45:36.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtq001tdrfd0t2xed18","content":"<p><strong><a href=\"https://music.163.com/dj?id=1368759629&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">牡丹亭外 - 陈升</a></strong></p>\n<p><strong>作词： 陈升</strong><br><strong>作曲： 陈升</strong><br><strong>演唱： 陈升</strong></p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n<p>李郎一梦已过往<br>风流人儿如今在何方</p>\n<p>从古到今说来话<br>不过是情而已</p>\n<p>这人间苦什么<br>怕不能遇见你</p>\n<p>这世界有点假<br>可我莫名爱上她</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>牡丹亭外雨纷纷<br>谁是归人说不准<br>是归人啊你说分明<br>你把我心放哪儿</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>可我最爱是天然<br>风流人儿如今在何方</p>\n<p>不管是谁啊<br>躲不过 还是情而已</p>\n<p>你问我怕什么<br>怕不能遇见你</p>\n<p>是否你走过了我身边<br>恍恍惑惑一瞬间</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人断了魂啊<br>听歌的人最无情</p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong><a href=\"https://music.163.com/dj?id=1368759629&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">牡丹亭外 - 陈升</a></strong></p>\n<p><strong>作词： 陈升</strong><br><strong>作曲： 陈升</strong><br><strong>演唱： 陈升</strong></p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n<p>李郎一梦已过往<br>风流人儿如今在何方</p>\n<p>从古到今说来话<br>不过是情而已</p>\n<p>这人间苦什么<br>怕不能遇见你</p>\n<p>这世界有点假<br>可我莫名爱上她</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>牡丹亭外雨纷纷<br>谁是归人说不准<br>是归人啊你说分明<br>你把我心放哪儿</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>可我最爱是天然<br>风流人儿如今在何方</p>\n<p>不管是谁啊<br>躲不过 还是情而已</p>\n<p>你问我怕什么<br>怕不能遇见你</p>\n<p>是否你走过了我身边<br>恍恍惑惑一瞬间</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人断了魂啊<br>听歌的人最无情</p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n"},{"title":"蔡康永的说话之道","date":"2017-10-04T07:21:10.000Z","_content":"1. 在别人眼里的形象取决于你说的话。\n从现在开始做起，每周关心问候一下朋友试试看？\n一定要开心，阳光。\n\n2. 外表永远不是最重要的，是不是讨人喜欢才是最重要的。\n不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的\n\n3. 学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。\n\n4. 和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。\n遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。\n<!-- more -->\n5. 把对方看在眼里，放到心里。\n约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。\n6. 对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。\n\n7. 如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。\n\n8. 问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。\n    先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。\n\n    而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。\n\n    结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。\n9. 和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说\"我\"，而是多说\"你\",\"他\"，尽量让别人说，你倾听。\n10. 很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。\n所以不如根据想问的问题倒推回去三四步？比如直接问\"你今天怎么不开心\"，不如问\"你最近课多吗？\"，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。\n\n    如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。\n    比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。\n\n11. 说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和\n\n12. 谈话的时候不要踩地雷。\n地雷是指：\n+ 对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。\n+ 对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。\n\n13. 别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。\n\n14. 说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易\"撩\"到别人。\n说话适当有空当，可以让别人有时间去想你的话，体会你的感情。\n\n15. 练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。\n\n16. 有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。\n\n17. 讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。\n\n18. 不要不懂装懂，有时候不要抢答，说话要分清场合。\n\n19. 认真观察别人希望被赞赏的方面，然后进行赞赏。\n    用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。\n    比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。\n\n20. 自问自答，站在对方的角度上来考虑。\n尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？\n\n21. 不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。\n\n22. 尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。\n\n23. 有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。\n\n24. 当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已\n\n25. 找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。\n\n26. 当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。\n\n27. 有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。\n\n28. 别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。\n\n29. 擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。\n\n30. 招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。\n\n31. 传达感情，不仅仅要会说。\n    很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。\n    说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。\n    说的多不如说的准，做得到。\n","source":"_posts/蔡康永的说话之道.md","raw":"---\ntitle: 蔡康永的说话之道\ndate: 2017-10-04 15:21:10\ntags:\n- 读书笔记\n- 说话技巧\ncategories:\n- 生活\n---\n1. 在别人眼里的形象取决于你说的话。\n从现在开始做起，每周关心问候一下朋友试试看？\n一定要开心，阳光。\n\n2. 外表永远不是最重要的，是不是讨人喜欢才是最重要的。\n不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的\n\n3. 学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。\n\n4. 和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。\n遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。\n<!-- more -->\n5. 把对方看在眼里，放到心里。\n约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。\n6. 对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。\n\n7. 如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。\n\n8. 问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。\n    先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。\n\n    而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。\n\n    结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。\n9. 和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说\"我\"，而是多说\"你\",\"他\"，尽量让别人说，你倾听。\n10. 很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。\n所以不如根据想问的问题倒推回去三四步？比如直接问\"你今天怎么不开心\"，不如问\"你最近课多吗？\"，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。\n\n    如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。\n    比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。\n\n11. 说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和\n\n12. 谈话的时候不要踩地雷。\n地雷是指：\n+ 对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。\n+ 对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。\n\n13. 别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。\n\n14. 说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易\"撩\"到别人。\n说话适当有空当，可以让别人有时间去想你的话，体会你的感情。\n\n15. 练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。\n\n16. 有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。\n\n17. 讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。\n\n18. 不要不懂装懂，有时候不要抢答，说话要分清场合。\n\n19. 认真观察别人希望被赞赏的方面，然后进行赞赏。\n    用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。\n    比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。\n\n20. 自问自答，站在对方的角度上来考虑。\n尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？\n\n21. 不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。\n\n22. 尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。\n\n23. 有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。\n\n24. 当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已\n\n25. 找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。\n\n26. 当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。\n\n27. 有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。\n\n28. 别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。\n\n29. 擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。\n\n30. 招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。\n\n31. 传达感情，不仅仅要会说。\n    很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。\n    说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。\n    说的多不如说的准，做得到。\n","slug":"蔡康永的说话之道","published":1,"updated":"2019-04-07T05:53:13.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtt001ydrfdir3f132e","content":"<ol>\n<li><p>在别人眼里的形象取决于你说的话。<br>从现在开始做起，每周关心问候一下朋友试试看？<br>一定要开心，阳光。</p>\n</li>\n<li><p>外表永远不是最重要的，是不是讨人喜欢才是最重要的。<br>不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的</p>\n</li>\n<li><p>学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。</p>\n</li>\n<li><p>和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。<br>遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。</p>\n<a id=\"more\"></a></li>\n<li>把对方看在眼里，放到心里。<br>约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。</li>\n<li><p>对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。</p>\n</li>\n<li><p>如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。</p>\n</li>\n<li><p>问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。<br> 先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。</p>\n<p> 而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。</p>\n<p> 结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。</p>\n</li>\n<li>和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说”我”，而是多说”你”,”他”，尽量让别人说，你倾听。</li>\n<li><p>很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。<br>所以不如根据想问的问题倒推回去三四步？比如直接问”你今天怎么不开心”，不如问”你最近课多吗？”，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。</p>\n<p>如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。<br>比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。</p>\n</li>\n<li><p>说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和</p>\n</li>\n<li><p>谈话的时候不要踩地雷。<br>地雷是指：</p>\n</li>\n</ol>\n<ul>\n<li>对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。</li>\n<li>对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。</li>\n</ul>\n<ol start=\"13\">\n<li><p>别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。</p>\n</li>\n<li><p>说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易”撩”到别人。<br>说话适当有空当，可以让别人有时间去想你的话，体会你的感情。</p>\n</li>\n<li><p>练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。</p>\n</li>\n<li><p>有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。</p>\n</li>\n<li><p>讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。</p>\n</li>\n<li><p>不要不懂装懂，有时候不要抢答，说话要分清场合。</p>\n</li>\n<li><p>认真观察别人希望被赞赏的方面，然后进行赞赏。<br>用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。<br>比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。</p>\n</li>\n<li><p>自问自答，站在对方的角度上来考虑。<br>尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？</p>\n</li>\n<li><p>不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。</p>\n</li>\n<li><p>尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。</p>\n</li>\n<li><p>有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。</p>\n</li>\n<li><p>当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已</p>\n</li>\n<li><p>找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。</p>\n</li>\n<li><p>当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。</p>\n</li>\n<li><p>有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。</p>\n</li>\n<li><p>别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。</p>\n</li>\n<li><p>擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。</p>\n</li>\n<li><p>招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。</p>\n</li>\n<li><p>传达感情，不仅仅要会说。<br>很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。<br>说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。<br>说的多不如说的准，做得到。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>在别人眼里的形象取决于你说的话。<br>从现在开始做起，每周关心问候一下朋友试试看？<br>一定要开心，阳光。</p>\n</li>\n<li><p>外表永远不是最重要的，是不是讨人喜欢才是最重要的。<br>不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的</p>\n</li>\n<li><p>学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。</p>\n</li>\n<li><p>和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。<br>遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。</p>","more":"</li>\n<li>把对方看在眼里，放到心里。<br>约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。</li>\n<li><p>对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。</p>\n</li>\n<li><p>如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。</p>\n</li>\n<li><p>问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。<br> 先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。</p>\n<p> 而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。</p>\n<p> 结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。</p>\n</li>\n<li>和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说”我”，而是多说”你”,”他”，尽量让别人说，你倾听。</li>\n<li><p>很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。<br>所以不如根据想问的问题倒推回去三四步？比如直接问”你今天怎么不开心”，不如问”你最近课多吗？”，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。</p>\n<p>如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。<br>比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。</p>\n</li>\n<li><p>说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和</p>\n</li>\n<li><p>谈话的时候不要踩地雷。<br>地雷是指：</p>\n</li>\n</ol>\n<ul>\n<li>对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。</li>\n<li>对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。</li>\n</ul>\n<ol start=\"13\">\n<li><p>别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。</p>\n</li>\n<li><p>说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易”撩”到别人。<br>说话适当有空当，可以让别人有时间去想你的话，体会你的感情。</p>\n</li>\n<li><p>练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。</p>\n</li>\n<li><p>有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。</p>\n</li>\n<li><p>讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。</p>\n</li>\n<li><p>不要不懂装懂，有时候不要抢答，说话要分清场合。</p>\n</li>\n<li><p>认真观察别人希望被赞赏的方面，然后进行赞赏。<br>用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。<br>比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。</p>\n</li>\n<li><p>自问自答，站在对方的角度上来考虑。<br>尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？</p>\n</li>\n<li><p>不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。</p>\n</li>\n<li><p>尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。</p>\n</li>\n<li><p>有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。</p>\n</li>\n<li><p>当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已</p>\n</li>\n<li><p>找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。</p>\n</li>\n<li><p>当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。</p>\n</li>\n<li><p>有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。</p>\n</li>\n<li><p>别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。</p>\n</li>\n<li><p>擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。</p>\n</li>\n<li><p>招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。</p>\n</li>\n<li><p>传达感情，不仅仅要会说。<br>很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。<br>说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。<br>说的多不如说的准，做得到。</p>\n</li>\n</ol>"},{"title":"记一次社招面试","date":"2019-03-13T05:47:48.000Z","_content":"## 再惠\n### 一面\n\n 1. 自我介绍一下\n 2. 看到你用过mobx，说一下mobx的优势？实现原理呢？\n 3. 你工作以来，在项目中遇到的印象深刻的问题有哪些？有没有在项目实践过一些自己的想法和新技术？\n 4. 说说TS和ES的区别，以及TS带来的好处？\n 5. 你说你学习能力强，那你毕业这一年多来，你都是怎么熟悉业务和项目的？有系统的看完过哪本书？\n 6. 对小程序有了解吗？（我只写过demo）\n 7. 对打包工具有了解吗？\n 8. 除了react，你还用过哪些框架？\n 9. 求契波那切数列的第N项\n 10. 获取到契波那切数列的前N项\n 11. 求一个对象的层级数（我写完后，又问如果不用递归，只用循环实现呢）\n  <!-- more -->\n 12. 实现下面这道题中的machine函数\n ![image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png-113.5kB][1]\n\n### 二面\n\n 1. 介绍一下你们那边的业务？那你们业务都是在app里面吗？（安卓、IOS、H5甚至小程序和快应用都有，基本上都是webview套h5做的）\n 2. 你最近有比较感兴趣的、主要研究的技术吗？为什么感兴趣？\n 3. 我看了你的github，上面star了一个react.backbone，这个是什么？\n 4. 我看你的github里面有个mobx-jquery，这个是做什么的？\n 5. 这个mobx-jquery里面的observer你是怎么实现的？（封装的autorun）那么autorun的原理是什么？\n 6. 你对团队的要求是怎么样的？你毕业这一年多收获最大的是什么？\n 7. 看到你写了TS，那么TS的优势是什么呢？你说修改字段后其他还用原字段的地方会报错，那么是怎么跟踪到是否修改的呢？vscode里面是怎么实现根据类型文件来给一个方法添加类型的呢？\n 8. 看到你的简历里面写着维护一个老项目，这个lizard是什么框架？（基于backbone封装的一个Hybrid框架xxxxx）\n 9. 那来做道题吧。实现一个函数，可以按顺序获取到一个DOM节点下面所有的文本。\n 10. 你有什么想问我的吗？（你平时在公司的一天都是在做什么呢？）\n\n### 总结\n\n感觉技术栈和这家可能不是很匹配，他们主要做h5和小程序，h5也以vue居多，所以这些问题基本上都没怎么深入。\n面试除了mobx，也没问过我react相关的技术，也没问过app开发方面的东西，他们唯一感兴趣的就是TS，可惜我TS写的不多。\n但是面试体验还不错，我属于比较紧张的人。面试官让现场写代码，可以查资料，可以现场调试，甚至有不懂的还可以问一下他，我觉得这个挺好的。听他们描述，感觉团队技术氛围不错，和HR聊了一下，觉得福利还算不错。\n只是谈薪资的时候，他们可能觉得我要的太高了，一直没给出明确答复，说是等CTO回来后让他定夺。\n\n最后，附上那道题的答案。\n![image_1d5onkg3r1vq1kqe8dlcv81hnl13.png-138.3kB][2]\n\n  [1]: http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\n  [2]: http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png","source":"_posts/记一次社招面试.md","raw":"---\ntitle: 记一次社招面试\ndate: 2019-03-13 13:47:48\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n## 再惠\n### 一面\n\n 1. 自我介绍一下\n 2. 看到你用过mobx，说一下mobx的优势？实现原理呢？\n 3. 你工作以来，在项目中遇到的印象深刻的问题有哪些？有没有在项目实践过一些自己的想法和新技术？\n 4. 说说TS和ES的区别，以及TS带来的好处？\n 5. 你说你学习能力强，那你毕业这一年多来，你都是怎么熟悉业务和项目的？有系统的看完过哪本书？\n 6. 对小程序有了解吗？（我只写过demo）\n 7. 对打包工具有了解吗？\n 8. 除了react，你还用过哪些框架？\n 9. 求契波那切数列的第N项\n 10. 获取到契波那切数列的前N项\n 11. 求一个对象的层级数（我写完后，又问如果不用递归，只用循环实现呢）\n  <!-- more -->\n 12. 实现下面这道题中的machine函数\n ![image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png-113.5kB][1]\n\n### 二面\n\n 1. 介绍一下你们那边的业务？那你们业务都是在app里面吗？（安卓、IOS、H5甚至小程序和快应用都有，基本上都是webview套h5做的）\n 2. 你最近有比较感兴趣的、主要研究的技术吗？为什么感兴趣？\n 3. 我看了你的github，上面star了一个react.backbone，这个是什么？\n 4. 我看你的github里面有个mobx-jquery，这个是做什么的？\n 5. 这个mobx-jquery里面的observer你是怎么实现的？（封装的autorun）那么autorun的原理是什么？\n 6. 你对团队的要求是怎么样的？你毕业这一年多收获最大的是什么？\n 7. 看到你写了TS，那么TS的优势是什么呢？你说修改字段后其他还用原字段的地方会报错，那么是怎么跟踪到是否修改的呢？vscode里面是怎么实现根据类型文件来给一个方法添加类型的呢？\n 8. 看到你的简历里面写着维护一个老项目，这个lizard是什么框架？（基于backbone封装的一个Hybrid框架xxxxx）\n 9. 那来做道题吧。实现一个函数，可以按顺序获取到一个DOM节点下面所有的文本。\n 10. 你有什么想问我的吗？（你平时在公司的一天都是在做什么呢？）\n\n### 总结\n\n感觉技术栈和这家可能不是很匹配，他们主要做h5和小程序，h5也以vue居多，所以这些问题基本上都没怎么深入。\n面试除了mobx，也没问过我react相关的技术，也没问过app开发方面的东西，他们唯一感兴趣的就是TS，可惜我TS写的不多。\n但是面试体验还不错，我属于比较紧张的人。面试官让现场写代码，可以查资料，可以现场调试，甚至有不懂的还可以问一下他，我觉得这个挺好的。听他们描述，感觉团队技术氛围不错，和HR聊了一下，觉得福利还算不错。\n只是谈薪资的时候，他们可能觉得我要的太高了，一直没给出明确答复，说是等CTO回来后让他定夺。\n\n最后，附上那道题的答案。\n![image_1d5onkg3r1vq1kqe8dlcv81hnl13.png-138.3kB][2]\n\n  [1]: http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\n  [2]: http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png","slug":"记一次社招面试","published":1,"updated":"2019-04-07T05:53:13.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtv0021drfdhna3fwzu","content":"<h2 id=\"再惠\"><a href=\"#再惠\" class=\"headerlink\" title=\"再惠\"></a>再惠</h2><h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><ol>\n<li>自我介绍一下</li>\n<li>看到你用过mobx，说一下mobx的优势？实现原理呢？</li>\n<li>你工作以来，在项目中遇到的印象深刻的问题有哪些？有没有在项目实践过一些自己的想法和新技术？</li>\n<li>说说TS和ES的区别，以及TS带来的好处？</li>\n<li>你说你学习能力强，那你毕业这一年多来，你都是怎么熟悉业务和项目的？有系统的看完过哪本书？</li>\n<li>对小程序有了解吗？（我只写过demo）</li>\n<li>对打包工具有了解吗？</li>\n<li>除了react，你还用过哪些框架？</li>\n<li>求契波那切数列的第N项</li>\n<li>获取到契波那切数列的前N项</li>\n<li>求一个对象的层级数（我写完后，又问如果不用递归，只用循环实现呢）<a id=\"more\"></a></li>\n<li>实现下面这道题中的machine函数<br><img src=\"http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\" alt=\"image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png-113.5kB\"></li>\n</ol>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><ol>\n<li>介绍一下你们那边的业务？那你们业务都是在app里面吗？（安卓、IOS、H5甚至小程序和快应用都有，基本上都是webview套h5做的）</li>\n<li>你最近有比较感兴趣的、主要研究的技术吗？为什么感兴趣？</li>\n<li>我看了你的github，上面star了一个react.backbone，这个是什么？</li>\n<li>我看你的github里面有个mobx-jquery，这个是做什么的？</li>\n<li>这个mobx-jquery里面的observer你是怎么实现的？（封装的autorun）那么autorun的原理是什么？</li>\n<li>你对团队的要求是怎么样的？你毕业这一年多收获最大的是什么？</li>\n<li>看到你写了TS，那么TS的优势是什么呢？你说修改字段后其他还用原字段的地方会报错，那么是怎么跟踪到是否修改的呢？vscode里面是怎么实现根据类型文件来给一个方法添加类型的呢？</li>\n<li>看到你的简历里面写着维护一个老项目，这个lizard是什么框架？（基于backbone封装的一个Hybrid框架xxxxx）</li>\n<li>那来做道题吧。实现一个函数，可以按顺序获取到一个DOM节点下面所有的文本。</li>\n<li>你有什么想问我的吗？（你平时在公司的一天都是在做什么呢？）</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>感觉技术栈和这家可能不是很匹配，他们主要做h5和小程序，h5也以vue居多，所以这些问题基本上都没怎么深入。<br>面试除了mobx，也没问过我react相关的技术，也没问过app开发方面的东西，他们唯一感兴趣的就是TS，可惜我TS写的不多。<br>但是面试体验还不错，我属于比较紧张的人。面试官让现场写代码，可以查资料，可以现场调试，甚至有不懂的还可以问一下他，我觉得这个挺好的。听他们描述，感觉团队技术氛围不错，和HR聊了一下，觉得福利还算不错。<br>只是谈薪资的时候，他们可能觉得我要的太高了，一直没给出明确答复，说是等CTO回来后让他定夺。</p>\n<p>最后，附上那道题的答案。<br><img src=\"http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png\" alt=\"image_1d5onkg3r1vq1kqe8dlcv81hnl13.png-138.3kB\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"再惠\"><a href=\"#再惠\" class=\"headerlink\" title=\"再惠\"></a>再惠</h2><h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><ol>\n<li>自我介绍一下</li>\n<li>看到你用过mobx，说一下mobx的优势？实现原理呢？</li>\n<li>你工作以来，在项目中遇到的印象深刻的问题有哪些？有没有在项目实践过一些自己的想法和新技术？</li>\n<li>说说TS和ES的区别，以及TS带来的好处？</li>\n<li>你说你学习能力强，那你毕业这一年多来，你都是怎么熟悉业务和项目的？有系统的看完过哪本书？</li>\n<li>对小程序有了解吗？（我只写过demo）</li>\n<li>对打包工具有了解吗？</li>\n<li>除了react，你还用过哪些框架？</li>\n<li>求契波那切数列的第N项</li>\n<li>获取到契波那切数列的前N项</li>\n<li>求一个对象的层级数（我写完后，又问如果不用递归，只用循环实现呢）","more":"</li>\n<li>实现下面这道题中的machine函数<br><img src=\"http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\" alt=\"image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png-113.5kB\"></li>\n</ol>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><ol>\n<li>介绍一下你们那边的业务？那你们业务都是在app里面吗？（安卓、IOS、H5甚至小程序和快应用都有，基本上都是webview套h5做的）</li>\n<li>你最近有比较感兴趣的、主要研究的技术吗？为什么感兴趣？</li>\n<li>我看了你的github，上面star了一个react.backbone，这个是什么？</li>\n<li>我看你的github里面有个mobx-jquery，这个是做什么的？</li>\n<li>这个mobx-jquery里面的observer你是怎么实现的？（封装的autorun）那么autorun的原理是什么？</li>\n<li>你对团队的要求是怎么样的？你毕业这一年多收获最大的是什么？</li>\n<li>看到你写了TS，那么TS的优势是什么呢？你说修改字段后其他还用原字段的地方会报错，那么是怎么跟踪到是否修改的呢？vscode里面是怎么实现根据类型文件来给一个方法添加类型的呢？</li>\n<li>看到你的简历里面写着维护一个老项目，这个lizard是什么框架？（基于backbone封装的一个Hybrid框架xxxxx）</li>\n<li>那来做道题吧。实现一个函数，可以按顺序获取到一个DOM节点下面所有的文本。</li>\n<li>你有什么想问我的吗？（你平时在公司的一天都是在做什么呢？）</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>感觉技术栈和这家可能不是很匹配，他们主要做h5和小程序，h5也以vue居多，所以这些问题基本上都没怎么深入。<br>面试除了mobx，也没问过我react相关的技术，也没问过app开发方面的东西，他们唯一感兴趣的就是TS，可惜我TS写的不多。<br>但是面试体验还不错，我属于比较紧张的人。面试官让现场写代码，可以查资料，可以现场调试，甚至有不懂的还可以问一下他，我觉得这个挺好的。听他们描述，感觉团队技术氛围不错，和HR聊了一下，觉得福利还算不错。<br>只是谈薪资的时候，他们可能觉得我要的太高了，一直没给出明确答复，说是等CTO回来后让他定夺。</p>\n<p>最后，附上那道题的答案。<br><img src=\"http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png\" alt=\"image_1d5onkg3r1vq1kqe8dlcv81hnl13.png-138.3kB\"></p>"},{"title":"记一次社招面试（二）","date":"2019-03-15T05:49:25.000Z","_content":"## 达达-京东到家\n面试过去的时候，先让做了一张试卷，主要是考察http、css和js的。\n### 笔试题（只记得这几道http相关的）\n\n 1. http2.0的新特性有哪些？（选项是多路复用、头部压缩、设置优先级、服务端推送、二进制传输）\n 2. DNS的作用有哪些？（选项是域名解析、防火墙、负载均衡、控制流量还有一个我不记得了）\n 3. 以下哪些协议是可靠的？（选项是TCP、UDP、FTP、HTTP还有一个我不记得了）\n 4. 以下关于POST请求说法正确的是？（POST请求只能通过body带参数、服务器一定能够收到POST请求发送的数据、POST请求发送了两个数据包、POST请求可以被缓存）\n\n<!-- more -->\n### 一面\n\n 1. 什么是BFC？垂直margin重叠是为什么？怎么解决这个问题？\n 2. CSS里面有哪些相对单位？都是相对什么的？\n 3. fixed是相对于谁定位的？如果加上transform会出现问题吗？\n 4. 什么是XSS攻击？怎么解决？\n 5. innerHTML有什么问题？有什么简单的办法可以避免插入文本被XSS攻击吗？\n 6. 为什么不推荐用style内联元素？内联元素有什么缺点？（css文件可以缓存）\n 7. 什么是原型链？原型链的终点指向什么？\n 8. cookie、sessionStorage、localStorage的区别和作用是？\n 9. http状态码有哪些？301和302的区别是什么？304是指什么？\n 10. 什么是闭包？使用场景有哪些？闭包会引起什么问题？\n 11. 什么是浅拷贝和深拷贝？怎么实现一个深拷贝？\n 12. lodash和ramda的区别是什么？\n 13. HTML中attribute和property的区别是什么？\n 14. 怎么解决跨域？\n 15. 字符串和new String出来的字符串有啥区别？\n\n### 二面\n\n 1. 解释一下react中setState？（说说setState的表现和原理实现）\n 2. 如果我需要上传一个文件，前端展示进度条，用setState会导致合并更新，你有什么好办法？（Promise封装setState、利用setState底层特性，使用异步函数（setTimeout、async）包裹）\n 3. 有状态组件和无状态组件，有人说有状态的更好复用，有人说无状态的更好复用，你平时写的时候是怎么分的？（这个还是要看业务场景）\n 4. 如果有个react项目，你该管理组件状态？（从local state、global state和global store三个方向来解释）\n 5. react中组件是怎么响应数据的变化从而更新的呢？\n 6. react中的生命周期分为哪几个阶段？react16废弃了哪几个生命周期api？\n 7. 虚拟DOM相比真实DOM，为什么会带来性能上的优化？\n 8. diff算法是怎么比较新旧节点并更新的？\n 9. 如果我这里有一个文本组件，我修改了里面的文本，那么会影响到其他的组件吗？（所以这个还是要看场景）\n 10. 如果store中有一个cityList字段，我们需要在用户刷新后保持原来的样子，做缓存，如果这个时候上方下达了一个命令，需要关闭某个城市的物流配送，这个时候需要将该城市移除，用户不刷新浏览器的情况下，如何做到？（这道题说实话我没理解，我说更新store和缓存，但被面试官否定了，后来只能说不知道，也忘了问他答案是什么了）\n 11. 对webpack有了解吗？chunk、bundle和module有什么区别？\n 12. 说说hash、chunkhash和contenthash的区别？\n 13. TypeScript有哪些好处？\n 14. 浏览器页面渲染的流程是什么？\n 15. css会阻塞页面渲染吗？该怎么解决？怎么做到只加载首页的css？\n 16. 你觉得你最擅长的技术是哪一块呢？\n\n### 综合面（综合+HR+部门leader）\n\n 1. 从你的项目中随便找一个，说一说这个项目解决了哪方面的问题，业务或者技术上的都行。\n 2. 这个项目中你的角色是什么？你做了哪些？哪里又能够体现你的能力呢？\n 3. 为什么只在携程呆了一年多就出来找工作了？你现在的职级是多少？\n 4. 你最近有看过什么书？最近在研究的技术是什么？\n 5. 用过vue吗？感觉和react的区别是什么？如果让你做vue项目，你能接受吗？\n 6. 这边是一个vue重构到react的项目，最近招人来做这块的内容，包括webpack之类的都是重新搭，你觉得你能hold住吗？\n 7. 打算在上海定居吗？是打算啥时候回二线？\n 8. 你未来3-5年的职业规划是什么？\n\n### 总结\n\n二面的时候，面试官问我有什么想问的吗？我说，对于我这种刚毕业1-2年的人来说，我对webpack和node接触比较少，在公司也很少用到，感觉更像是个螺丝钉的角色，我接下来该往哪方面发展呢？\n\n面试官说，你不是已经找到答案了吗？你之前说自己为什么离职的时候已经说的很清楚了。我觉得对于毕业1-3年的人来说，如果能够做到独立去带一个项目和小团队，这是非常可贵的。\n\n部门leader面的时候，问了我很多项目方面的问题，不少正中我要害，因为我以前在公司扮演了螺丝钉的角色，很难有机会和资源去带项目或者团队。在技术也不够突出的情况下，似乎很难说哪里能够体现出自己的能力。确实，一年多的经验很尴尬，如果能多呆半年，肯定就会有不一样的回答。\n\nHR面的时候，这个HR对携程的薪资待遇、职称等等可以说非常了解了，问了很多深入和细节的问题，也和我聊了很多，导致我非常尴尬和紧张。（事实上我觉得这些问题我可以整理一下，便于应对之后的面试）\n\n这个面试可以说是我面过的最久一次了，前后面了一共五轮，关键是面完就让我回家了。不过，还算是一次愉快的面试，至少让我积累了一大笔很宝贵的面试经验。\n\n  [1]: http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\n  [2]: http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png","source":"_posts/记一次社招面试（二）.md","raw":"---\ntitle: 记一次社招面试（二）\ndate: 2019-03-15 13:49:25\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n## 达达-京东到家\n面试过去的时候，先让做了一张试卷，主要是考察http、css和js的。\n### 笔试题（只记得这几道http相关的）\n\n 1. http2.0的新特性有哪些？（选项是多路复用、头部压缩、设置优先级、服务端推送、二进制传输）\n 2. DNS的作用有哪些？（选项是域名解析、防火墙、负载均衡、控制流量还有一个我不记得了）\n 3. 以下哪些协议是可靠的？（选项是TCP、UDP、FTP、HTTP还有一个我不记得了）\n 4. 以下关于POST请求说法正确的是？（POST请求只能通过body带参数、服务器一定能够收到POST请求发送的数据、POST请求发送了两个数据包、POST请求可以被缓存）\n\n<!-- more -->\n### 一面\n\n 1. 什么是BFC？垂直margin重叠是为什么？怎么解决这个问题？\n 2. CSS里面有哪些相对单位？都是相对什么的？\n 3. fixed是相对于谁定位的？如果加上transform会出现问题吗？\n 4. 什么是XSS攻击？怎么解决？\n 5. innerHTML有什么问题？有什么简单的办法可以避免插入文本被XSS攻击吗？\n 6. 为什么不推荐用style内联元素？内联元素有什么缺点？（css文件可以缓存）\n 7. 什么是原型链？原型链的终点指向什么？\n 8. cookie、sessionStorage、localStorage的区别和作用是？\n 9. http状态码有哪些？301和302的区别是什么？304是指什么？\n 10. 什么是闭包？使用场景有哪些？闭包会引起什么问题？\n 11. 什么是浅拷贝和深拷贝？怎么实现一个深拷贝？\n 12. lodash和ramda的区别是什么？\n 13. HTML中attribute和property的区别是什么？\n 14. 怎么解决跨域？\n 15. 字符串和new String出来的字符串有啥区别？\n\n### 二面\n\n 1. 解释一下react中setState？（说说setState的表现和原理实现）\n 2. 如果我需要上传一个文件，前端展示进度条，用setState会导致合并更新，你有什么好办法？（Promise封装setState、利用setState底层特性，使用异步函数（setTimeout、async）包裹）\n 3. 有状态组件和无状态组件，有人说有状态的更好复用，有人说无状态的更好复用，你平时写的时候是怎么分的？（这个还是要看业务场景）\n 4. 如果有个react项目，你该管理组件状态？（从local state、global state和global store三个方向来解释）\n 5. react中组件是怎么响应数据的变化从而更新的呢？\n 6. react中的生命周期分为哪几个阶段？react16废弃了哪几个生命周期api？\n 7. 虚拟DOM相比真实DOM，为什么会带来性能上的优化？\n 8. diff算法是怎么比较新旧节点并更新的？\n 9. 如果我这里有一个文本组件，我修改了里面的文本，那么会影响到其他的组件吗？（所以这个还是要看场景）\n 10. 如果store中有一个cityList字段，我们需要在用户刷新后保持原来的样子，做缓存，如果这个时候上方下达了一个命令，需要关闭某个城市的物流配送，这个时候需要将该城市移除，用户不刷新浏览器的情况下，如何做到？（这道题说实话我没理解，我说更新store和缓存，但被面试官否定了，后来只能说不知道，也忘了问他答案是什么了）\n 11. 对webpack有了解吗？chunk、bundle和module有什么区别？\n 12. 说说hash、chunkhash和contenthash的区别？\n 13. TypeScript有哪些好处？\n 14. 浏览器页面渲染的流程是什么？\n 15. css会阻塞页面渲染吗？该怎么解决？怎么做到只加载首页的css？\n 16. 你觉得你最擅长的技术是哪一块呢？\n\n### 综合面（综合+HR+部门leader）\n\n 1. 从你的项目中随便找一个，说一说这个项目解决了哪方面的问题，业务或者技术上的都行。\n 2. 这个项目中你的角色是什么？你做了哪些？哪里又能够体现你的能力呢？\n 3. 为什么只在携程呆了一年多就出来找工作了？你现在的职级是多少？\n 4. 你最近有看过什么书？最近在研究的技术是什么？\n 5. 用过vue吗？感觉和react的区别是什么？如果让你做vue项目，你能接受吗？\n 6. 这边是一个vue重构到react的项目，最近招人来做这块的内容，包括webpack之类的都是重新搭，你觉得你能hold住吗？\n 7. 打算在上海定居吗？是打算啥时候回二线？\n 8. 你未来3-5年的职业规划是什么？\n\n### 总结\n\n二面的时候，面试官问我有什么想问的吗？我说，对于我这种刚毕业1-2年的人来说，我对webpack和node接触比较少，在公司也很少用到，感觉更像是个螺丝钉的角色，我接下来该往哪方面发展呢？\n\n面试官说，你不是已经找到答案了吗？你之前说自己为什么离职的时候已经说的很清楚了。我觉得对于毕业1-3年的人来说，如果能够做到独立去带一个项目和小团队，这是非常可贵的。\n\n部门leader面的时候，问了我很多项目方面的问题，不少正中我要害，因为我以前在公司扮演了螺丝钉的角色，很难有机会和资源去带项目或者团队。在技术也不够突出的情况下，似乎很难说哪里能够体现出自己的能力。确实，一年多的经验很尴尬，如果能多呆半年，肯定就会有不一样的回答。\n\nHR面的时候，这个HR对携程的薪资待遇、职称等等可以说非常了解了，问了很多深入和细节的问题，也和我聊了很多，导致我非常尴尬和紧张。（事实上我觉得这些问题我可以整理一下，便于应对之后的面试）\n\n这个面试可以说是我面过的最久一次了，前后面了一共五轮，关键是面完就让我回家了。不过，还算是一次愉快的面试，至少让我积累了一大笔很宝贵的面试经验。\n\n  [1]: http://static.zybuluo.com/gyyin/zdkiki625uog8plbna2j71e6/image_1d5oivtp41p1a1r3v1ne4qdmr9mm.png\n  [2]: http://static.zybuluo.com/gyyin/b8g8n4z6v7hlrrp2y33mbywy/image_1d5onkg3r1vq1kqe8dlcv81hnl13.png","slug":"记一次社招面试（二）","published":1,"updated":"2019-04-07T05:53:13.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhrtx0026drfd2x6xmaqn","content":"<h2 id=\"达达-京东到家\"><a href=\"#达达-京东到家\" class=\"headerlink\" title=\"达达-京东到家\"></a>达达-京东到家</h2><p>面试过去的时候，先让做了一张试卷，主要是考察http、css和js的。</p>\n<h3 id=\"笔试题（只记得这几道http相关的）\"><a href=\"#笔试题（只记得这几道http相关的）\" class=\"headerlink\" title=\"笔试题（只记得这几道http相关的）\"></a>笔试题（只记得这几道http相关的）</h3><ol>\n<li>http2.0的新特性有哪些？（选项是多路复用、头部压缩、设置优先级、服务端推送、二进制传输）</li>\n<li>DNS的作用有哪些？（选项是域名解析、防火墙、负载均衡、控制流量还有一个我不记得了）</li>\n<li>以下哪些协议是可靠的？（选项是TCP、UDP、FTP、HTTP还有一个我不记得了）</li>\n<li>以下关于POST请求说法正确的是？（POST请求只能通过body带参数、服务器一定能够收到POST请求发送的数据、POST请求发送了两个数据包、POST请求可以被缓存）</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><ol>\n<li>什么是BFC？垂直margin重叠是为什么？怎么解决这个问题？</li>\n<li>CSS里面有哪些相对单位？都是相对什么的？</li>\n<li>fixed是相对于谁定位的？如果加上transform会出现问题吗？</li>\n<li>什么是XSS攻击？怎么解决？</li>\n<li>innerHTML有什么问题？有什么简单的办法可以避免插入文本被XSS攻击吗？</li>\n<li>为什么不推荐用style内联元素？内联元素有什么缺点？（css文件可以缓存）</li>\n<li>什么是原型链？原型链的终点指向什么？</li>\n<li>cookie、sessionStorage、localStorage的区别和作用是？</li>\n<li>http状态码有哪些？301和302的区别是什么？304是指什么？</li>\n<li>什么是闭包？使用场景有哪些？闭包会引起什么问题？</li>\n<li>什么是浅拷贝和深拷贝？怎么实现一个深拷贝？</li>\n<li>lodash和ramda的区别是什么？</li>\n<li>HTML中attribute和property的区别是什么？</li>\n<li>怎么解决跨域？</li>\n<li>字符串和new String出来的字符串有啥区别？</li>\n</ol>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><ol>\n<li>解释一下react中setState？（说说setState的表现和原理实现）</li>\n<li>如果我需要上传一个文件，前端展示进度条，用setState会导致合并更新，你有什么好办法？（Promise封装setState、利用setState底层特性，使用异步函数（setTimeout、async）包裹）</li>\n<li>有状态组件和无状态组件，有人说有状态的更好复用，有人说无状态的更好复用，你平时写的时候是怎么分的？（这个还是要看业务场景）</li>\n<li>如果有个react项目，你该管理组件状态？（从local state、global state和global store三个方向来解释）</li>\n<li>react中组件是怎么响应数据的变化从而更新的呢？</li>\n<li>react中的生命周期分为哪几个阶段？react16废弃了哪几个生命周期api？</li>\n<li>虚拟DOM相比真实DOM，为什么会带来性能上的优化？</li>\n<li>diff算法是怎么比较新旧节点并更新的？</li>\n<li>如果我这里有一个文本组件，我修改了里面的文本，那么会影响到其他的组件吗？（所以这个还是要看场景）</li>\n<li>如果store中有一个cityList字段，我们需要在用户刷新后保持原来的样子，做缓存，如果这个时候上方下达了一个命令，需要关闭某个城市的物流配送，这个时候需要将该城市移除，用户不刷新浏览器的情况下，如何做到？（这道题说实话我没理解，我说更新store和缓存，但被面试官否定了，后来只能说不知道，也忘了问他答案是什么了）</li>\n<li>对webpack有了解吗？chunk、bundle和module有什么区别？</li>\n<li>说说hash、chunkhash和contenthash的区别？</li>\n<li>TypeScript有哪些好处？</li>\n<li>浏览器页面渲染的流程是什么？</li>\n<li>css会阻塞页面渲染吗？该怎么解决？怎么做到只加载首页的css？</li>\n<li>你觉得你最擅长的技术是哪一块呢？</li>\n</ol>\n<h3 id=\"综合面（综合-HR-部门leader）\"><a href=\"#综合面（综合-HR-部门leader）\" class=\"headerlink\" title=\"综合面（综合+HR+部门leader）\"></a>综合面（综合+HR+部门leader）</h3><ol>\n<li>从你的项目中随便找一个，说一说这个项目解决了哪方面的问题，业务或者技术上的都行。</li>\n<li>这个项目中你的角色是什么？你做了哪些？哪里又能够体现你的能力呢？</li>\n<li>为什么只在携程呆了一年多就出来找工作了？你现在的职级是多少？</li>\n<li>你最近有看过什么书？最近在研究的技术是什么？</li>\n<li>用过vue吗？感觉和react的区别是什么？如果让你做vue项目，你能接受吗？</li>\n<li>这边是一个vue重构到react的项目，最近招人来做这块的内容，包括webpack之类的都是重新搭，你觉得你能hold住吗？</li>\n<li>打算在上海定居吗？是打算啥时候回二线？</li>\n<li>你未来3-5年的职业规划是什么？</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>二面的时候，面试官问我有什么想问的吗？我说，对于我这种刚毕业1-2年的人来说，我对webpack和node接触比较少，在公司也很少用到，感觉更像是个螺丝钉的角色，我接下来该往哪方面发展呢？</p>\n<p>面试官说，你不是已经找到答案了吗？你之前说自己为什么离职的时候已经说的很清楚了。我觉得对于毕业1-3年的人来说，如果能够做到独立去带一个项目和小团队，这是非常可贵的。</p>\n<p>部门leader面的时候，问了我很多项目方面的问题，不少正中我要害，因为我以前在公司扮演了螺丝钉的角色，很难有机会和资源去带项目或者团队。在技术也不够突出的情况下，似乎很难说哪里能够体现出自己的能力。确实，一年多的经验很尴尬，如果能多呆半年，肯定就会有不一样的回答。</p>\n<p>HR面的时候，这个HR对携程的薪资待遇、职称等等可以说非常了解了，问了很多深入和细节的问题，也和我聊了很多，导致我非常尴尬和紧张。（事实上我觉得这些问题我可以整理一下，便于应对之后的面试）</p>\n<p>这个面试可以说是我面过的最久一次了，前后面了一共五轮，关键是面完就让我回家了。不过，还算是一次愉快的面试，至少让我积累了一大笔很宝贵的面试经验。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"达达-京东到家\"><a href=\"#达达-京东到家\" class=\"headerlink\" title=\"达达-京东到家\"></a>达达-京东到家</h2><p>面试过去的时候，先让做了一张试卷，主要是考察http、css和js的。</p>\n<h3 id=\"笔试题（只记得这几道http相关的）\"><a href=\"#笔试题（只记得这几道http相关的）\" class=\"headerlink\" title=\"笔试题（只记得这几道http相关的）\"></a>笔试题（只记得这几道http相关的）</h3><ol>\n<li>http2.0的新特性有哪些？（选项是多路复用、头部压缩、设置优先级、服务端推送、二进制传输）</li>\n<li>DNS的作用有哪些？（选项是域名解析、防火墙、负载均衡、控制流量还有一个我不记得了）</li>\n<li>以下哪些协议是可靠的？（选项是TCP、UDP、FTP、HTTP还有一个我不记得了）</li>\n<li>以下关于POST请求说法正确的是？（POST请求只能通过body带参数、服务器一定能够收到POST请求发送的数据、POST请求发送了两个数据包、POST请求可以被缓存）</li>\n</ol>","more":"<h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><ol>\n<li>什么是BFC？垂直margin重叠是为什么？怎么解决这个问题？</li>\n<li>CSS里面有哪些相对单位？都是相对什么的？</li>\n<li>fixed是相对于谁定位的？如果加上transform会出现问题吗？</li>\n<li>什么是XSS攻击？怎么解决？</li>\n<li>innerHTML有什么问题？有什么简单的办法可以避免插入文本被XSS攻击吗？</li>\n<li>为什么不推荐用style内联元素？内联元素有什么缺点？（css文件可以缓存）</li>\n<li>什么是原型链？原型链的终点指向什么？</li>\n<li>cookie、sessionStorage、localStorage的区别和作用是？</li>\n<li>http状态码有哪些？301和302的区别是什么？304是指什么？</li>\n<li>什么是闭包？使用场景有哪些？闭包会引起什么问题？</li>\n<li>什么是浅拷贝和深拷贝？怎么实现一个深拷贝？</li>\n<li>lodash和ramda的区别是什么？</li>\n<li>HTML中attribute和property的区别是什么？</li>\n<li>怎么解决跨域？</li>\n<li>字符串和new String出来的字符串有啥区别？</li>\n</ol>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><ol>\n<li>解释一下react中setState？（说说setState的表现和原理实现）</li>\n<li>如果我需要上传一个文件，前端展示进度条，用setState会导致合并更新，你有什么好办法？（Promise封装setState、利用setState底层特性，使用异步函数（setTimeout、async）包裹）</li>\n<li>有状态组件和无状态组件，有人说有状态的更好复用，有人说无状态的更好复用，你平时写的时候是怎么分的？（这个还是要看业务场景）</li>\n<li>如果有个react项目，你该管理组件状态？（从local state、global state和global store三个方向来解释）</li>\n<li>react中组件是怎么响应数据的变化从而更新的呢？</li>\n<li>react中的生命周期分为哪几个阶段？react16废弃了哪几个生命周期api？</li>\n<li>虚拟DOM相比真实DOM，为什么会带来性能上的优化？</li>\n<li>diff算法是怎么比较新旧节点并更新的？</li>\n<li>如果我这里有一个文本组件，我修改了里面的文本，那么会影响到其他的组件吗？（所以这个还是要看场景）</li>\n<li>如果store中有一个cityList字段，我们需要在用户刷新后保持原来的样子，做缓存，如果这个时候上方下达了一个命令，需要关闭某个城市的物流配送，这个时候需要将该城市移除，用户不刷新浏览器的情况下，如何做到？（这道题说实话我没理解，我说更新store和缓存，但被面试官否定了，后来只能说不知道，也忘了问他答案是什么了）</li>\n<li>对webpack有了解吗？chunk、bundle和module有什么区别？</li>\n<li>说说hash、chunkhash和contenthash的区别？</li>\n<li>TypeScript有哪些好处？</li>\n<li>浏览器页面渲染的流程是什么？</li>\n<li>css会阻塞页面渲染吗？该怎么解决？怎么做到只加载首页的css？</li>\n<li>你觉得你最擅长的技术是哪一块呢？</li>\n</ol>\n<h3 id=\"综合面（综合-HR-部门leader）\"><a href=\"#综合面（综合-HR-部门leader）\" class=\"headerlink\" title=\"综合面（综合+HR+部门leader）\"></a>综合面（综合+HR+部门leader）</h3><ol>\n<li>从你的项目中随便找一个，说一说这个项目解决了哪方面的问题，业务或者技术上的都行。</li>\n<li>这个项目中你的角色是什么？你做了哪些？哪里又能够体现你的能力呢？</li>\n<li>为什么只在携程呆了一年多就出来找工作了？你现在的职级是多少？</li>\n<li>你最近有看过什么书？最近在研究的技术是什么？</li>\n<li>用过vue吗？感觉和react的区别是什么？如果让你做vue项目，你能接受吗？</li>\n<li>这边是一个vue重构到react的项目，最近招人来做这块的内容，包括webpack之类的都是重新搭，你觉得你能hold住吗？</li>\n<li>打算在上海定居吗？是打算啥时候回二线？</li>\n<li>你未来3-5年的职业规划是什么？</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>二面的时候，面试官问我有什么想问的吗？我说，对于我这种刚毕业1-2年的人来说，我对webpack和node接触比较少，在公司也很少用到，感觉更像是个螺丝钉的角色，我接下来该往哪方面发展呢？</p>\n<p>面试官说，你不是已经找到答案了吗？你之前说自己为什么离职的时候已经说的很清楚了。我觉得对于毕业1-3年的人来说，如果能够做到独立去带一个项目和小团队，这是非常可贵的。</p>\n<p>部门leader面的时候，问了我很多项目方面的问题，不少正中我要害，因为我以前在公司扮演了螺丝钉的角色，很难有机会和资源去带项目或者团队。在技术也不够突出的情况下，似乎很难说哪里能够体现出自己的能力。确实，一年多的经验很尴尬，如果能多呆半年，肯定就会有不一样的回答。</p>\n<p>HR面的时候，这个HR对携程的薪资待遇、职称等等可以说非常了解了，问了很多深入和细节的问题，也和我聊了很多，导致我非常尴尬和紧张。（事实上我觉得这些问题我可以整理一下，便于应对之后的面试）</p>\n<p>这个面试可以说是我面过的最久一次了，前后面了一共五轮，关键是面完就让我回家了。不过，还算是一次愉快的面试，至少让我积累了一大笔很宝贵的面试经验。</p>"},{"title":"JS函数柯里化","date":"2018-05-09T10:13:05.000Z","_content":"## js函数柯里化\n\n&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。\n### 概念\n&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。\n### 实例\n&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：\n### 柯里化求和函数\n```\n    // 普通方式\n    var add1 = function(a, b, c){\n        return a + b + c;\n    }\n    // 柯里化\n    var add2 = function(a) {\n        return function(b) {\n            return function(c) {\n                return a + b + c;\n            }\n        }\n    }\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。\n<!-- more -->\n```\nvar add = function() {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return _args.reduce(function(a, b) {\n                return a + b;\n            })\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar sum = add();\nsum(100, 200)(300);\nsum(400);\nsum(); // 1000\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。\n\n### 通用柯里化函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？\n```\nvar curry = function(fn) {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return fn.apply(fn, _args);\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar multi = function() {\n    return [].reduce.call(arguments, function(a, b) {\n        return a + b;\n    })\n}\nvar add = curry(multi);\nadd(100, 200, 300)(400);\nadd(1000);\nadd(); // 2000\n\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。\n&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？\n```\nvar curry = function(fn) {\n\tvar len = fn.length,\n\t\targs = [];\n\treturn function() {\n\t\tArray.prototype.push.apply(args, arguments)\n\t\tvar argsLen = args.length;\n\t\tif(argsLen < len) {\n\t\t\treturn arguments.callee;\n\t\t}\n\t\treturn fn.apply(fn, args);\n\t}\n}\nvar add = function(a, b, c) {\n\treturn a + b + c;\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。\n&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。\n```\n// 简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。\n```\nadd(1)(2)(3)(2);\nadd(1, 2, 3, 4, 5);\n```\n&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。\n```\nvar num = function() {\n}\nnum.toString = num.valueOf = function() {\n\treturn 10;\n}\nvar anonymousNum = (function() { // 10\n\treturn num;\n}())\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。\n```\nvar curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\nvar add = function() {\n\treturn [].reduce.call(arguments, function(a, b) {\n\t\treturn a + b;\n\t})\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？\n#### 预加载\n&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。\n```\nvar match = curry(function(what, str) {\n  return str.match(what);\n});\n\nmatch(/\\s+/g, \"hello world\");\n// [ ' ' ]\n\nmatch(/\\s+/g)(\"hello world\");\n// [ ' ' ]\n\nvar hasSpaces = match(/\\s+/g);\n// function(x) { return x.match(/\\s+/g) }\n\nhasSpaces(\"hello world\");\n// [ ' ' ]\n\nhasSpaces(\"spaceless\");\n// null\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。\n#### 动态创建函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。\n```\n var addEvent = function(el, type, fn, capture) {\n     if (window.addEventListener) {\n         el.addEventListener(type, function(e) {\n             fn.call(el, e);\n         }, capture);\n     } else if (window.attachEvent) {\n         el.attachEvent(\"on\" + type, function(e) {\n             fn.call(el, e);\n         });\n     } \n };\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。\n```\nvar addEventHandler = function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\nvar addEvent = addEventHandler();\naddEvent(document.body, \"click\", function() {}, false);\naddEvent(document.getElementById(\"test\"), \"click\", function() {}, false);\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。\n```\nvar addEvent = function(el, sType, fn, capture){\n    if (window.addEventListener) {\n        addEvent =  function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        addEvent = function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。\n#### React\n&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？\n```\n    var curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\n\nvar hoc = function(WrappedComponent) {\n\treturn function() {\n\t\tvar len = arguments.length;\n\t\tvar NewComponent = WrappedComponent;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tNewComponent = arguments[i](NewComponent)\n\t\t}\n\t\treturn NewComponent;\n\t}\n}\nvar MyComponent = hoc(PageList);\ncurry(MyComponent)(addStyle)(addLoading)\n```\n这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。\n```\nvar enhance = compose(addLoading, addStyle);\nenhance(MyComponent)\n```\n### 总结\n&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。","source":"_posts/JS函数柯里化.md","raw":"---\ntitle: JS函数柯里化\ndate: 2018-05-09 18:13:05\ntags:\n    - 前端\n    - 函数式编程\n    - javascript\ncategories:\n    - 函数式编程\n---\n## js函数柯里化\n\n&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。\n### 概念\n&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。\n### 实例\n&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：\n### 柯里化求和函数\n```\n    // 普通方式\n    var add1 = function(a, b, c){\n        return a + b + c;\n    }\n    // 柯里化\n    var add2 = function(a) {\n        return function(b) {\n            return function(c) {\n                return a + b + c;\n            }\n        }\n    }\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。\n<!-- more -->\n```\nvar add = function() {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return _args.reduce(function(a, b) {\n                return a + b;\n            })\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar sum = add();\nsum(100, 200)(300);\nsum(400);\nsum(); // 1000\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。\n\n### 通用柯里化函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？\n```\nvar curry = function(fn) {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return fn.apply(fn, _args);\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar multi = function() {\n    return [].reduce.call(arguments, function(a, b) {\n        return a + b;\n    })\n}\nvar add = curry(multi);\nadd(100, 200, 300)(400);\nadd(1000);\nadd(); // 2000\n\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。\n&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？\n```\nvar curry = function(fn) {\n\tvar len = fn.length,\n\t\targs = [];\n\treturn function() {\n\t\tArray.prototype.push.apply(args, arguments)\n\t\tvar argsLen = args.length;\n\t\tif(argsLen < len) {\n\t\t\treturn arguments.callee;\n\t\t}\n\t\treturn fn.apply(fn, args);\n\t}\n}\nvar add = function(a, b, c) {\n\treturn a + b + c;\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。\n&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。\n```\n// 简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。\n```\nadd(1)(2)(3)(2);\nadd(1, 2, 3, 4, 5);\n```\n&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。\n```\nvar num = function() {\n}\nnum.toString = num.valueOf = function() {\n\treturn 10;\n}\nvar anonymousNum = (function() { // 10\n\treturn num;\n}())\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。\n```\nvar curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\nvar add = function() {\n\treturn [].reduce.call(arguments, function(a, b) {\n\t\treturn a + b;\n\t})\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？\n#### 预加载\n&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。\n```\nvar match = curry(function(what, str) {\n  return str.match(what);\n});\n\nmatch(/\\s+/g, \"hello world\");\n// [ ' ' ]\n\nmatch(/\\s+/g)(\"hello world\");\n// [ ' ' ]\n\nvar hasSpaces = match(/\\s+/g);\n// function(x) { return x.match(/\\s+/g) }\n\nhasSpaces(\"hello world\");\n// [ ' ' ]\n\nhasSpaces(\"spaceless\");\n// null\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。\n#### 动态创建函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。\n```\n var addEvent = function(el, type, fn, capture) {\n     if (window.addEventListener) {\n         el.addEventListener(type, function(e) {\n             fn.call(el, e);\n         }, capture);\n     } else if (window.attachEvent) {\n         el.attachEvent(\"on\" + type, function(e) {\n             fn.call(el, e);\n         });\n     } \n };\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。\n```\nvar addEventHandler = function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\nvar addEvent = addEventHandler();\naddEvent(document.body, \"click\", function() {}, false);\naddEvent(document.getElementById(\"test\"), \"click\", function() {}, false);\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。\n```\nvar addEvent = function(el, sType, fn, capture){\n    if (window.addEventListener) {\n        addEvent =  function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        addEvent = function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。\n#### React\n&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？\n```\n    var curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\n\nvar hoc = function(WrappedComponent) {\n\treturn function() {\n\t\tvar len = arguments.length;\n\t\tvar NewComponent = WrappedComponent;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tNewComponent = arguments[i](NewComponent)\n\t\t}\n\t\treturn NewComponent;\n\t}\n}\nvar MyComponent = hoc(PageList);\ncurry(MyComponent)(addStyle)(addLoading)\n```\n这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。\n```\nvar enhance = compose(addLoading, addStyle);\nenhance(MyComponent)\n```\n### 总结\n&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。","slug":"JS函数柯里化","published":1,"updated":"2019-04-07T05:53:12.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs5e005vdrfd9ey6q1x5","content":"<h2 id=\"js函数柯里化\"><a href=\"#js函数柯里化\" class=\"headerlink\" title=\"js函数柯里化\"></a>js函数柯里化</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：</p>\n<h3 id=\"柯里化求和函数\"><a href=\"#柯里化求和函数\" class=\"headerlink\" title=\"柯里化求和函数\"></a>柯里化求和函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通方式</span><br><span class=\"line\">var add1 = function(a, b, c)&#123;</span><br><span class=\"line\">    return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 柯里化</span><br><span class=\"line\">var add2 = function(a) &#123;</span><br><span class=\"line\">    return function(b) &#123;</span><br><span class=\"line\">        return function(c) &#123;</span><br><span class=\"line\">            return a + b + c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。<br>&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return _args.reduce(function(a, b) &#123;</span><br><span class=\"line\">                return a + b;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum = add();</span><br><span class=\"line\">sum(100, 200)(300);</span><br><span class=\"line\">sum(400);</span><br><span class=\"line\">sum(); // 1000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。</p>\n<h3 id=\"通用柯里化函数\"><a href=\"#通用柯里化函数\" class=\"headerlink\" title=\"通用柯里化函数\"></a>通用柯里化函数</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return fn.apply(fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var multi = function() &#123;</span><br><span class=\"line\">    return [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = curry(multi);</span><br><span class=\"line\">add(100, 200, 300)(400);</span><br><span class=\"line\">add(1000);</span><br><span class=\"line\">add(); // 2000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。<br>&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar len = fn.length,</span><br><span class=\"line\">\t\targs = [];</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tArray.prototype.push.apply(args, arguments)</span><br><span class=\"line\">\t\tvar argsLen = args.length;</span><br><span class=\"line\">\t\tif(argsLen &lt; len) &#123;</span><br><span class=\"line\">\t\t\treturn arguments.callee;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn fn.apply(fn, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function(a, b, c) &#123;</span><br><span class=\"line\">\treturn a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。<br>&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 简单实现，参数只能从右到左传递</span><br><span class=\"line\">function createCurry(func, args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var arity = func.length;</span><br><span class=\"line\">    var args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var _args = [].slice.call(arguments);</span><br><span class=\"line\">        [].push.apply(_args, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class=\"line\">        if (_args.length &lt; arity) &#123;</span><br><span class=\"line\">            return createCurry.call(this, func, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 参数收集完毕，则执行func</span><br><span class=\"line\">        return func.apply(this, _args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1)(2)(3)(2);</span><br><span class=\"line\">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">num.toString = num.valueOf = function() &#123;</span><br><span class=\"line\">\treturn 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var anonymousNum = (function() &#123; // 10</span><br><span class=\"line\">\treturn num;</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">\treturn [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">\t\treturn a + b;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？</p>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var match = curry(function(what, str) &#123;</span><br><span class=\"line\">  return str.match(what);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g, &quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g)(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var hasSpaces = match(/\\s+/g);</span><br><span class=\"line\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;spaceless&quot;);</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。</p>\n<h4 id=\"动态创建函数\"><a href=\"#动态创建函数\" class=\"headerlink\" title=\"动态创建函数\"></a>动态创建函数</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, type, fn, capture) &#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        el.addEventListener(type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;, capture);</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        el.attachEvent(&quot;on&quot; + type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEventHandler = function()&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var addEvent = addEventHandler();</span><br><span class=\"line\">addEvent(document.body, &quot;click&quot;, function() &#123;&#125;, false);</span><br><span class=\"line\">addEvent(document.getElementById(&quot;test&quot;), &quot;click&quot;, function() &#123;&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, sType, fn, capture)&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        addEvent =  function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        addEvent = function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hoc = function(WrappedComponent) &#123;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tvar len = arguments.length;</span><br><span class=\"line\">\t\tvar NewComponent = WrappedComponent;</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\tNewComponent = arguments[i](NewComponent)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn NewComponent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var MyComponent = hoc(PageList);</span><br><span class=\"line\">curry(MyComponent)(addStyle)(addLoading)</span><br></pre></td></tr></table></figure></p>\n<p>这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhance = compose(addLoading, addStyle);</span><br><span class=\"line\">enhance(MyComponent)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"js函数柯里化\"><a href=\"#js函数柯里化\" class=\"headerlink\" title=\"js函数柯里化\"></a>js函数柯里化</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：</p>\n<h3 id=\"柯里化求和函数\"><a href=\"#柯里化求和函数\" class=\"headerlink\" title=\"柯里化求和函数\"></a>柯里化求和函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通方式</span><br><span class=\"line\">var add1 = function(a, b, c)&#123;</span><br><span class=\"line\">    return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 柯里化</span><br><span class=\"line\">var add2 = function(a) &#123;</span><br><span class=\"line\">    return function(b) &#123;</span><br><span class=\"line\">        return function(c) &#123;</span><br><span class=\"line\">            return a + b + c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。<br>&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return _args.reduce(function(a, b) &#123;</span><br><span class=\"line\">                return a + b;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum = add();</span><br><span class=\"line\">sum(100, 200)(300);</span><br><span class=\"line\">sum(400);</span><br><span class=\"line\">sum(); // 1000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。</p>\n<h3 id=\"通用柯里化函数\"><a href=\"#通用柯里化函数\" class=\"headerlink\" title=\"通用柯里化函数\"></a>通用柯里化函数</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return fn.apply(fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var multi = function() &#123;</span><br><span class=\"line\">    return [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = curry(multi);</span><br><span class=\"line\">add(100, 200, 300)(400);</span><br><span class=\"line\">add(1000);</span><br><span class=\"line\">add(); // 2000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。<br>&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar len = fn.length,</span><br><span class=\"line\">\t\targs = [];</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tArray.prototype.push.apply(args, arguments)</span><br><span class=\"line\">\t\tvar argsLen = args.length;</span><br><span class=\"line\">\t\tif(argsLen &lt; len) &#123;</span><br><span class=\"line\">\t\t\treturn arguments.callee;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn fn.apply(fn, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function(a, b, c) &#123;</span><br><span class=\"line\">\treturn a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。<br>&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 简单实现，参数只能从右到左传递</span><br><span class=\"line\">function createCurry(func, args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var arity = func.length;</span><br><span class=\"line\">    var args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var _args = [].slice.call(arguments);</span><br><span class=\"line\">        [].push.apply(_args, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class=\"line\">        if (_args.length &lt; arity) &#123;</span><br><span class=\"line\">            return createCurry.call(this, func, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 参数收集完毕，则执行func</span><br><span class=\"line\">        return func.apply(this, _args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1)(2)(3)(2);</span><br><span class=\"line\">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">num.toString = num.valueOf = function() &#123;</span><br><span class=\"line\">\treturn 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var anonymousNum = (function() &#123; // 10</span><br><span class=\"line\">\treturn num;</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">\treturn [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">\t\treturn a + b;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？</p>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var match = curry(function(what, str) &#123;</span><br><span class=\"line\">  return str.match(what);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g, &quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g)(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var hasSpaces = match(/\\s+/g);</span><br><span class=\"line\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;spaceless&quot;);</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。</p>\n<h4 id=\"动态创建函数\"><a href=\"#动态创建函数\" class=\"headerlink\" title=\"动态创建函数\"></a>动态创建函数</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, type, fn, capture) &#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        el.addEventListener(type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;, capture);</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        el.attachEvent(&quot;on&quot; + type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEventHandler = function()&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var addEvent = addEventHandler();</span><br><span class=\"line\">addEvent(document.body, &quot;click&quot;, function() &#123;&#125;, false);</span><br><span class=\"line\">addEvent(document.getElementById(&quot;test&quot;), &quot;click&quot;, function() &#123;&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, sType, fn, capture)&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        addEvent =  function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        addEvent = function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hoc = function(WrappedComponent) &#123;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tvar len = arguments.length;</span><br><span class=\"line\">\t\tvar NewComponent = WrappedComponent;</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\tNewComponent = arguments[i](NewComponent)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn NewComponent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var MyComponent = hoc(PageList);</span><br><span class=\"line\">curry(MyComponent)(addStyle)(addLoading)</span><br></pre></td></tr></table></figure></p>\n<p>这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhance = compose(addLoading, addStyle);</span><br><span class=\"line\">enhance(MyComponent)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。</p>"},{"title":"redux源码分析","date":"2018-07-25T15:46:14.000Z","_content":"前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。\n<!-- more -->\n## createStore\nredux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。\n\n![redux入口.png-41.8kB][1]\n\n从返回参数来看，createStore函数主要返回了这四个我们常用的函数。\n![createStore.png-251.1kB][2]\n\n进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。\n## combineReducers\n删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：\n![combineReducers.png-309.2kB][3]\n\n参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。\n这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。\n这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。\n并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。\n## applyMiddleware\nMiddleware这个概念是Redux从其他框架借鉴过来的，本意如下：\n\n> middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware\n> 可以完成添加 CORS headers、记录日志、内容压缩等工作。\n\n而在Redux中：\n\n> middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer\n> 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。\n\n看完了combineReducers函数，我们继续分析applyMiddleware函数：\n\n![applyMi.png-172kB][4]\n\napplyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。\nredux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。\n## compose\n![compose.png-80.9kB][5]\n\n这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。\n## dispatch\n再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：\n![dispatch.png-152.4kB][6]\n首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。\ndispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。\n## subscribe\n这里我们看一下subscribe函数：\n![subscribe.png-128kB][7]\n\nsubscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。\n这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。\n## 重写\n这里是自己重写的简练版redux：\n```\n/// 这里需要对参数为0或1的情况进行判断\nconst compose = (...funcs) => {\n    if (!funcs) {\n        return args => args\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((f1, f2) => (...args) => f1(f2(...args)))\n}\n\nconst bindActionCreator = (action, dispatch) => {\n    return (...args) => dispatch(action(...args))\n}\n\nconst createStore = (reducer, initState, enhancer) => {\n    if (!enhancer && typeof initState === \"function\") {\n        enhancer = initState\n        initState = null\n    }\n    if (enhancer && typeof enhancer === \"function\") {\n        return enhancer(createStore)(reducer, initState)\n    }\n    let store = initState, \n        listeners = [],\n        isDispatch = false;\n    const getState = () => store\n    const dispatch = (action) => {\n        if (isDispatch) return action\n        // dispatch必须一个个来\n        isDispatch = true\n        store = reducer(store, action)\n        isDispatch = false\n        listeners.forEach(listener => listener())\n        return action\n    }\n    const subscribe = (listener) => {\n        if (typeof listener === \"function\") {\n            listeners.push(listener)\n        }\n        return () => unsubscribe(listener)\n    }\n    const unsubscribe = (listener) => {\n        const index = listeners.indexOf(listener)\n        listeners.splice(index, 1)\n    }\n    return {\n        getState,\n        dispatch,\n        subscribe,\n        unsubscribe\n    }\n}\n\nconst applyMiddleware = (...middlewares) => {\n    return (createStore) => (reducer, initState, enhancer) => {\n        const store = createStore(reducer, initState, enhancer)\n        let chain = middlewares.map(middleware => middleware(store))\n        store.dispatch = compose(...chain)(store.dispatch)\n        return {\n          ...store\n        }\n      }\n}\n\nconst combineReducers = reducers => {\n    const finalReducers = {},\n        nativeKeys = Object.keys\n    nativeKeys(reducers).forEach(reducerKey => {\n        if(typeof reducers[reducerKey] === \"function\") {\n            finalReducers[reducerKey] = reducers[reducerKey]\n        }\n    })\n    return (state, action) => {\n        const store = {}\n        nativeKeys(finalReducers).forEach(key => {\n            const reducer = finalReducers[key]\n            const nextState = reducer(state[key], action)\n            store[key] = nextState\n        })\n        return store\n    }\n}\n```\n## 总结\nredux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。\n\n  [1]: http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\n  [2]: http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\n  [3]: http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\n  [4]: http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\n  [5]: http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\n  [6]: http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\n  [7]: http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png","source":"_posts/redux源码分析.md","raw":"---\ntitle: redux源码分析\ndate: 2018-07-25 23:46:14\ncategories: [前端, react]\ntags:\n    - redux\n    - react\n    - 前端\n---\n前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。\n<!-- more -->\n## createStore\nredux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。\n\n![redux入口.png-41.8kB][1]\n\n从返回参数来看，createStore函数主要返回了这四个我们常用的函数。\n![createStore.png-251.1kB][2]\n\n进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。\n## combineReducers\n删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：\n![combineReducers.png-309.2kB][3]\n\n参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。\n这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。\n这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。\n并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。\n## applyMiddleware\nMiddleware这个概念是Redux从其他框架借鉴过来的，本意如下：\n\n> middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware\n> 可以完成添加 CORS headers、记录日志、内容压缩等工作。\n\n而在Redux中：\n\n> middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer\n> 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。\n\n看完了combineReducers函数，我们继续分析applyMiddleware函数：\n\n![applyMi.png-172kB][4]\n\napplyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。\nredux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。\n## compose\n![compose.png-80.9kB][5]\n\n这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。\n## dispatch\n再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：\n![dispatch.png-152.4kB][6]\n首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。\ndispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。\n## subscribe\n这里我们看一下subscribe函数：\n![subscribe.png-128kB][7]\n\nsubscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。\n这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。\n## 重写\n这里是自己重写的简练版redux：\n```\n/// 这里需要对参数为0或1的情况进行判断\nconst compose = (...funcs) => {\n    if (!funcs) {\n        return args => args\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((f1, f2) => (...args) => f1(f2(...args)))\n}\n\nconst bindActionCreator = (action, dispatch) => {\n    return (...args) => dispatch(action(...args))\n}\n\nconst createStore = (reducer, initState, enhancer) => {\n    if (!enhancer && typeof initState === \"function\") {\n        enhancer = initState\n        initState = null\n    }\n    if (enhancer && typeof enhancer === \"function\") {\n        return enhancer(createStore)(reducer, initState)\n    }\n    let store = initState, \n        listeners = [],\n        isDispatch = false;\n    const getState = () => store\n    const dispatch = (action) => {\n        if (isDispatch) return action\n        // dispatch必须一个个来\n        isDispatch = true\n        store = reducer(store, action)\n        isDispatch = false\n        listeners.forEach(listener => listener())\n        return action\n    }\n    const subscribe = (listener) => {\n        if (typeof listener === \"function\") {\n            listeners.push(listener)\n        }\n        return () => unsubscribe(listener)\n    }\n    const unsubscribe = (listener) => {\n        const index = listeners.indexOf(listener)\n        listeners.splice(index, 1)\n    }\n    return {\n        getState,\n        dispatch,\n        subscribe,\n        unsubscribe\n    }\n}\n\nconst applyMiddleware = (...middlewares) => {\n    return (createStore) => (reducer, initState, enhancer) => {\n        const store = createStore(reducer, initState, enhancer)\n        let chain = middlewares.map(middleware => middleware(store))\n        store.dispatch = compose(...chain)(store.dispatch)\n        return {\n          ...store\n        }\n      }\n}\n\nconst combineReducers = reducers => {\n    const finalReducers = {},\n        nativeKeys = Object.keys\n    nativeKeys(reducers).forEach(reducerKey => {\n        if(typeof reducers[reducerKey] === \"function\") {\n            finalReducers[reducerKey] = reducers[reducerKey]\n        }\n    })\n    return (state, action) => {\n        const store = {}\n        nativeKeys(finalReducers).forEach(key => {\n            const reducer = finalReducers[key]\n            const nextState = reducer(state[key], action)\n            store[key] = nextState\n        })\n        return store\n    }\n}\n```\n## 总结\nredux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。\n\n  [1]: http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\n  [2]: http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\n  [3]: http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\n  [4]: http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\n  [5]: http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\n  [6]: http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\n  [7]: http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png","slug":"redux源码分析","published":1,"updated":"2019-04-07T05:53:12.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs5l005wdrfdqalk11ij","content":"<p>前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。<br><a id=\"more\"></a></p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>redux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\" alt=\"redux入口.png-41.8kB\"></p>\n<p>从返回参数来看，createStore函数主要返回了这四个我们常用的函数。<br><img src=\"http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\" alt=\"createStore.png-251.1kB\"></p>\n<p>进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：<br><img src=\"http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\" alt=\"combineReducers.png-309.2kB\"></p>\n<p>参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。<br>这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。<br>这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。<br>并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>Middleware这个概念是Redux从其他框架借鉴过来的，本意如下：</p>\n<blockquote>\n<p>middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware<br>可以完成添加 CORS headers、记录日志、内容压缩等工作。</p>\n</blockquote>\n<p>而在Redux中：</p>\n<blockquote>\n<p>middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer<br>之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>\n</blockquote>\n<p>看完了combineReducers函数，我们继续分析applyMiddleware函数：</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\" alt=\"applyMi.png-172kB\"></p>\n<p>applyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。<br>redux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p><img src=\"http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\" alt=\"compose.png-80.9kB\"></p>\n<p>这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。</p>\n<h2 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h2><p>再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：<br><img src=\"http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\" alt=\"dispatch.png-152.4kB\"><br>首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。<br>dispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。</p>\n<h2 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h2><p>这里我们看一下subscribe函数：<br><img src=\"http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png\" alt=\"subscribe.png-128kB\"></p>\n<p>subscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。<br>这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。</p>\n<h2 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h2><p>这里是自己重写的简练版redux：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 这里需要对参数为0或1的情况进行判断</span><br><span class=\"line\">const compose = (...funcs) =&gt; &#123;</span><br><span class=\"line\">    if (!funcs) &#123;</span><br><span class=\"line\">        return args =&gt; args</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (funcs.length === 1) &#123;</span><br><span class=\"line\">        return funcs[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return funcs.reduce((f1, f2) =&gt; (...args) =&gt; f1(f2(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bindActionCreator = (action, dispatch) =&gt; &#123;</span><br><span class=\"line\">    return (...args) =&gt; dispatch(action(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const createStore = (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    if (!enhancer &amp;&amp; typeof initState === &quot;function&quot;) &#123;</span><br><span class=\"line\">        enhancer = initState</span><br><span class=\"line\">        initState = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (enhancer &amp;&amp; typeof enhancer === &quot;function&quot;) &#123;</span><br><span class=\"line\">        return enhancer(createStore)(reducer, initState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let store = initState, </span><br><span class=\"line\">        listeners = [],</span><br><span class=\"line\">        isDispatch = false;</span><br><span class=\"line\">    const getState = () =&gt; store</span><br><span class=\"line\">    const dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">        if (isDispatch) return action</span><br><span class=\"line\">        // dispatch必须一个个来</span><br><span class=\"line\">        isDispatch = true</span><br><span class=\"line\">        store = reducer(store, action)</span><br><span class=\"line\">        isDispatch = false</span><br><span class=\"line\">        listeners.forEach(listener =&gt; listener())</span><br><span class=\"line\">        return action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        if (typeof listener === &quot;function&quot;) &#123;</span><br><span class=\"line\">            listeners.push(listener)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return () =&gt; unsubscribe(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const unsubscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        const index = listeners.indexOf(listener)</span><br><span class=\"line\">        listeners.splice(index, 1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        getState,</span><br><span class=\"line\">        dispatch,</span><br><span class=\"line\">        subscribe,</span><br><span class=\"line\">        unsubscribe</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const applyMiddleware = (...middlewares) =&gt; &#123;</span><br><span class=\"line\">    return (createStore) =&gt; (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">        const store = createStore(reducer, initState, enhancer)</span><br><span class=\"line\">        let chain = middlewares.map(middleware =&gt; middleware(store))</span><br><span class=\"line\">        store.dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">          ...store</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const combineReducers = reducers =&gt; &#123;</span><br><span class=\"line\">    const finalReducers = &#123;&#125;,</span><br><span class=\"line\">        nativeKeys = Object.keys</span><br><span class=\"line\">    nativeKeys(reducers).forEach(reducerKey =&gt; &#123;</span><br><span class=\"line\">        if(typeof reducers[reducerKey] === &quot;function&quot;) &#123;</span><br><span class=\"line\">            finalReducers[reducerKey] = reducers[reducerKey]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return (state, action) =&gt; &#123;</span><br><span class=\"line\">        const store = &#123;&#125;</span><br><span class=\"line\">        nativeKeys(finalReducers).forEach(key =&gt; &#123;</span><br><span class=\"line\">            const reducer = finalReducers[key]</span><br><span class=\"line\">            const nextState = reducer(state[key], action)</span><br><span class=\"line\">            store[key] = nextState</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。</p>\n","site":{"data":{}},"excerpt":"<p>前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。<br>","more":"</p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>redux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\" alt=\"redux入口.png-41.8kB\"></p>\n<p>从返回参数来看，createStore函数主要返回了这四个我们常用的函数。<br><img src=\"http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\" alt=\"createStore.png-251.1kB\"></p>\n<p>进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：<br><img src=\"http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\" alt=\"combineReducers.png-309.2kB\"></p>\n<p>参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。<br>这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。<br>这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。<br>并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>Middleware这个概念是Redux从其他框架借鉴过来的，本意如下：</p>\n<blockquote>\n<p>middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware<br>可以完成添加 CORS headers、记录日志、内容压缩等工作。</p>\n</blockquote>\n<p>而在Redux中：</p>\n<blockquote>\n<p>middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer<br>之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>\n</blockquote>\n<p>看完了combineReducers函数，我们继续分析applyMiddleware函数：</p>\n<p><img src=\"http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\" alt=\"applyMi.png-172kB\"></p>\n<p>applyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。<br>redux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p><img src=\"http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\" alt=\"compose.png-80.9kB\"></p>\n<p>这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。</p>\n<h2 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h2><p>再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：<br><img src=\"http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\" alt=\"dispatch.png-152.4kB\"><br>首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。<br>dispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。</p>\n<h2 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h2><p>这里我们看一下subscribe函数：<br><img src=\"http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png\" alt=\"subscribe.png-128kB\"></p>\n<p>subscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。<br>这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。</p>\n<h2 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h2><p>这里是自己重写的简练版redux：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 这里需要对参数为0或1的情况进行判断</span><br><span class=\"line\">const compose = (...funcs) =&gt; &#123;</span><br><span class=\"line\">    if (!funcs) &#123;</span><br><span class=\"line\">        return args =&gt; args</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (funcs.length === 1) &#123;</span><br><span class=\"line\">        return funcs[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return funcs.reduce((f1, f2) =&gt; (...args) =&gt; f1(f2(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bindActionCreator = (action, dispatch) =&gt; &#123;</span><br><span class=\"line\">    return (...args) =&gt; dispatch(action(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const createStore = (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    if (!enhancer &amp;&amp; typeof initState === &quot;function&quot;) &#123;</span><br><span class=\"line\">        enhancer = initState</span><br><span class=\"line\">        initState = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (enhancer &amp;&amp; typeof enhancer === &quot;function&quot;) &#123;</span><br><span class=\"line\">        return enhancer(createStore)(reducer, initState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let store = initState, </span><br><span class=\"line\">        listeners = [],</span><br><span class=\"line\">        isDispatch = false;</span><br><span class=\"line\">    const getState = () =&gt; store</span><br><span class=\"line\">    const dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">        if (isDispatch) return action</span><br><span class=\"line\">        // dispatch必须一个个来</span><br><span class=\"line\">        isDispatch = true</span><br><span class=\"line\">        store = reducer(store, action)</span><br><span class=\"line\">        isDispatch = false</span><br><span class=\"line\">        listeners.forEach(listener =&gt; listener())</span><br><span class=\"line\">        return action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        if (typeof listener === &quot;function&quot;) &#123;</span><br><span class=\"line\">            listeners.push(listener)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return () =&gt; unsubscribe(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const unsubscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        const index = listeners.indexOf(listener)</span><br><span class=\"line\">        listeners.splice(index, 1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        getState,</span><br><span class=\"line\">        dispatch,</span><br><span class=\"line\">        subscribe,</span><br><span class=\"line\">        unsubscribe</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const applyMiddleware = (...middlewares) =&gt; &#123;</span><br><span class=\"line\">    return (createStore) =&gt; (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">        const store = createStore(reducer, initState, enhancer)</span><br><span class=\"line\">        let chain = middlewares.map(middleware =&gt; middleware(store))</span><br><span class=\"line\">        store.dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">          ...store</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const combineReducers = reducers =&gt; &#123;</span><br><span class=\"line\">    const finalReducers = &#123;&#125;,</span><br><span class=\"line\">        nativeKeys = Object.keys</span><br><span class=\"line\">    nativeKeys(reducers).forEach(reducerKey =&gt; &#123;</span><br><span class=\"line\">        if(typeof reducers[reducerKey] === &quot;function&quot;) &#123;</span><br><span class=\"line\">            finalReducers[reducerKey] = reducers[reducerKey]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return (state, action) =&gt; &#123;</span><br><span class=\"line\">        const store = &#123;&#125;</span><br><span class=\"line\">        nativeKeys(finalReducers).forEach(key =&gt; &#123;</span><br><span class=\"line\">            const reducer = finalReducers[key]</span><br><span class=\"line\">            const nextState = reducer(state[key], action)</span><br><span class=\"line\">            store[key] = nextState</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。</p>"},{"title":"underscore查找索引函数分析","date":"2018-03-25T14:16:51.000Z","_content":"这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。\n## find ##\n```\n// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context\n_.find = _.detect = function (obj, predicate, context) {\n    var key;\n    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key\n    if (isArrayLike(obj)) {\n    \tkey = _.findIndex(obj, predicate, context);\n    } else {\n    \tkey = _.findKey(obj, predicate, context);\n    }\n    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）\n    // 所以这里对没有查找到的情况做了判断\n    if (key !== void 0 && key !== -1) return obj[key];\n};\n```\nfindKey和findIndex方法的实现也都比较简单。\n```\n_.findKey = function (obj, predicate, context) {\n\tpredicate = cb(predicate, context);\n\tvar keys = _.keys(obj), key;\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tkey = keys[i];\n\t\t// 直接return出key意味着只返回第一个通过predicate检测的值\n\t\tif (predicate(obj[key], key, obj)) return key;\n\t}\n};\n// 根据传入dir的正负来判断是findIndex还是findLastIndex\nfunction createPredicateIndexFinder(dir) {\n\treturn function (array, predicate, context) {\n\t    // cb中对predicate绑定作用域\n\t\tpredicate = cb(predicate, context);\n\t\tvar length = getLength(array);\n        // 根据dir判断是从头遍历还是从尾遍历\n\t\tvar index = dir > 0 ? 0 : length - 1;\n\t\t// 这里需要判断两个临界条件\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值\n\t\t\tif (predicate(array[index], index, array)) return index;\n\t\t}\n\t\t// 查找不到就返回-1\n\t\treturn -1;\n\t};\n}\n\n// Returns the first index on an array-like that passes a predicate test\n_.findIndex = createPredicateIndexFinder(1);\n_.findLastIndex = createPredicateIndexFinder(-1);\n```\n<!-- more -->\n## sortedIndex二分查找 ##\nsortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）\n```\nvar arr = [10, 20, 30, 40]\n_.sortedIndex(arr, 25) // 返回2\n```\n由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。\n这里是维基百科对二分查找的定义：\n> 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval\n> search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n```\n// 二分法，可以理解为以中间元素为基准，将数组分成两个\n// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小\n// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段\n// 反过来，就是在数组左半段\n_.sortedIndex = function (array, obj, iteratee, context) {\n    // 不理解cb函数的建议去看我之前的文章\n\titeratee = cb(iteratee, context, 1);\n\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值\n\t// 如果obj是{age: 20, name: \"ygy\"}，iteratee是age，那么这个就是根据age来获取到index的\n\tvar value = iteratee(obj);\n\tvar low = 0, high = getLength(array);\n\t// 通过while循环来不断重复上述过程，直到找到obj的位置\n\twhile (low < high) {\n\t\tvar mid = Math.floor((low + high) / 2);\n\t\tif (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n\t}\n\treturn low;\n};\n```\n## indexOf ##\nindexOf函数接收array、value和isSorted三个参数。\nindexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。\n使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。\nlastIndexOf接收array、value和fromIndex三个参数。\nlastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。\n给下面返回值编上号，以便后面可以直接拿来讲。\n```\nvar arr = [1, 2, 3, 2, 4, 5]\nvar index1 = _.indexOf(arr, 2) // 1\n// 如果传了索引值为2，那就是从索引为2的地方开始搜索\n// 如果不传第三个参数，可以理解为默认是从0开始搜索\nvar index2 = _.indexOf(arr, 2, 2) // 3\n// 从索引为-1的地方查找意思就是从length-2的索引开始查找\nvar index3 = _.indexOf(arr, 2, -1)\n\n// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值\nvar index4 = _.lastIndexOf(arr, 2) // 3\n\n// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分\n// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值\n// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4\n// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3\n//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）\nvar index5 = _.lastIndexOf(arr, 2, 4) // 3\n\n// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索\nvar index6 = _.lastIndexOf(arr, 2, -1)\n```\n![图示][1]\n可能上面有点绕，这里我们再看一下源码：\n```\n_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\nfunction createIndexFinder(dir, predicateFind, sortedIndex) {\n    // idx有可能是布尔类型（isSorted）和数字类型\n\treturn function (array, item, idx) {\n\t\tvar i = 0, length = getLength(array);\n\t\t// 如果idx是数字类型，那就是从某个索引开始搜索\n\t\tif (typeof idx == 'number') {\n\t\t    // dir大于0的时候是从左到右查询（indexOf）\n\t\t\tif (dir > 0) {\n\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算\n\t\t\t\t// idx为负数对应上面的index3的情况\n\t\t\t\ti = idx >= 0 ? idx : Math.max(idx + length, i);\n\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）\n\t\t\t} else {\n\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度\n\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）\n\t\t\t\tlength = idx >= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);\n\t\t\t}\n\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找\n\t\t} else if (sortedIndex && idx && length) {\n\t\t\t// 使用二分法来查找\n\t\t\tidx = sortedIndex(array, item);\n\t\t\treturn array[idx] === item ? idx : -1;\n\t\t}\n\t\t// 如果item是NaN\n\t\tif (item !== item) {\n\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测\n\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了\n\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);\n\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，\n\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数\n\t\t\treturn idx >= 0 ? idx + i : -1;\n\t\t}\n\t\t// 根据上面计算出来的i和length来进行循环\n\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的\n\t\tfor (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n\t\t\tif (array[idx] === item) return idx;\n\t\t}\n\t\treturn -1;\n\t};\n}\n```\n原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。\n这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。\n\n[1]: http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore查找索引函数分析.md","raw":"---\ntitle: underscore查找索引函数分析\ndate: 2018-03-25 22:16:51\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。\n## find ##\n```\n// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context\n_.find = _.detect = function (obj, predicate, context) {\n    var key;\n    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key\n    if (isArrayLike(obj)) {\n    \tkey = _.findIndex(obj, predicate, context);\n    } else {\n    \tkey = _.findKey(obj, predicate, context);\n    }\n    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）\n    // 所以这里对没有查找到的情况做了判断\n    if (key !== void 0 && key !== -1) return obj[key];\n};\n```\nfindKey和findIndex方法的实现也都比较简单。\n```\n_.findKey = function (obj, predicate, context) {\n\tpredicate = cb(predicate, context);\n\tvar keys = _.keys(obj), key;\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tkey = keys[i];\n\t\t// 直接return出key意味着只返回第一个通过predicate检测的值\n\t\tif (predicate(obj[key], key, obj)) return key;\n\t}\n};\n// 根据传入dir的正负来判断是findIndex还是findLastIndex\nfunction createPredicateIndexFinder(dir) {\n\treturn function (array, predicate, context) {\n\t    // cb中对predicate绑定作用域\n\t\tpredicate = cb(predicate, context);\n\t\tvar length = getLength(array);\n        // 根据dir判断是从头遍历还是从尾遍历\n\t\tvar index = dir > 0 ? 0 : length - 1;\n\t\t// 这里需要判断两个临界条件\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值\n\t\t\tif (predicate(array[index], index, array)) return index;\n\t\t}\n\t\t// 查找不到就返回-1\n\t\treturn -1;\n\t};\n}\n\n// Returns the first index on an array-like that passes a predicate test\n_.findIndex = createPredicateIndexFinder(1);\n_.findLastIndex = createPredicateIndexFinder(-1);\n```\n<!-- more -->\n## sortedIndex二分查找 ##\nsortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）\n```\nvar arr = [10, 20, 30, 40]\n_.sortedIndex(arr, 25) // 返回2\n```\n由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。\n这里是维基百科对二分查找的定义：\n> 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval\n> search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n```\n// 二分法，可以理解为以中间元素为基准，将数组分成两个\n// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小\n// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段\n// 反过来，就是在数组左半段\n_.sortedIndex = function (array, obj, iteratee, context) {\n    // 不理解cb函数的建议去看我之前的文章\n\titeratee = cb(iteratee, context, 1);\n\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值\n\t// 如果obj是{age: 20, name: \"ygy\"}，iteratee是age，那么这个就是根据age来获取到index的\n\tvar value = iteratee(obj);\n\tvar low = 0, high = getLength(array);\n\t// 通过while循环来不断重复上述过程，直到找到obj的位置\n\twhile (low < high) {\n\t\tvar mid = Math.floor((low + high) / 2);\n\t\tif (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n\t}\n\treturn low;\n};\n```\n## indexOf ##\nindexOf函数接收array、value和isSorted三个参数。\nindexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。\n使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。\nlastIndexOf接收array、value和fromIndex三个参数。\nlastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。\n给下面返回值编上号，以便后面可以直接拿来讲。\n```\nvar arr = [1, 2, 3, 2, 4, 5]\nvar index1 = _.indexOf(arr, 2) // 1\n// 如果传了索引值为2，那就是从索引为2的地方开始搜索\n// 如果不传第三个参数，可以理解为默认是从0开始搜索\nvar index2 = _.indexOf(arr, 2, 2) // 3\n// 从索引为-1的地方查找意思就是从length-2的索引开始查找\nvar index3 = _.indexOf(arr, 2, -1)\n\n// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值\nvar index4 = _.lastIndexOf(arr, 2) // 3\n\n// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分\n// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值\n// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4\n// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3\n//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）\nvar index5 = _.lastIndexOf(arr, 2, 4) // 3\n\n// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索\nvar index6 = _.lastIndexOf(arr, 2, -1)\n```\n![图示][1]\n可能上面有点绕，这里我们再看一下源码：\n```\n_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\nfunction createIndexFinder(dir, predicateFind, sortedIndex) {\n    // idx有可能是布尔类型（isSorted）和数字类型\n\treturn function (array, item, idx) {\n\t\tvar i = 0, length = getLength(array);\n\t\t// 如果idx是数字类型，那就是从某个索引开始搜索\n\t\tif (typeof idx == 'number') {\n\t\t    // dir大于0的时候是从左到右查询（indexOf）\n\t\t\tif (dir > 0) {\n\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算\n\t\t\t\t// idx为负数对应上面的index3的情况\n\t\t\t\ti = idx >= 0 ? idx : Math.max(idx + length, i);\n\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）\n\t\t\t} else {\n\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度\n\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）\n\t\t\t\tlength = idx >= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);\n\t\t\t}\n\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找\n\t\t} else if (sortedIndex && idx && length) {\n\t\t\t// 使用二分法来查找\n\t\t\tidx = sortedIndex(array, item);\n\t\t\treturn array[idx] === item ? idx : -1;\n\t\t}\n\t\t// 如果item是NaN\n\t\tif (item !== item) {\n\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测\n\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了\n\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);\n\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，\n\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数\n\t\t\treturn idx >= 0 ? idx + i : -1;\n\t\t}\n\t\t// 根据上面计算出来的i和length来进行循环\n\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的\n\t\tfor (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n\t\t\tif (array[idx] === item) return idx;\n\t\t}\n\t\treturn -1;\n\t};\n}\n```\n原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。\n这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。\n\n[1]: http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore查找索引函数分析","published":1,"updated":"2019-04-07T05:53:12.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs5p005zdrfdozvy8q6c","content":"<p>这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context</span><br><span class=\"line\">_.find = _.detect = function (obj, predicate, context) &#123;</span><br><span class=\"line\">    var key;</span><br><span class=\"line\">    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">    \tkey = _.findIndex(obj, predicate, context);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">    \tkey = _.findKey(obj, predicate, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）</span><br><span class=\"line\">    // 所以这里对没有查找到的情况做了判断</span><br><span class=\"line\">    if (key !== void 0 &amp;&amp; key !== -1) return obj[key];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>findKey和findIndex方法的实现也都比较简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.findKey = function (obj, predicate, context) &#123;</span><br><span class=\"line\">\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\tvar keys = _.keys(obj), key;</span><br><span class=\"line\">\tfor (var i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tkey = keys[i];</span><br><span class=\"line\">\t\t// 直接return出key意味着只返回第一个通过predicate检测的值</span><br><span class=\"line\">\t\tif (predicate(obj[key], key, obj)) return key;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 根据传入dir的正负来判断是findIndex还是findLastIndex</span><br><span class=\"line\">function createPredicateIndexFinder(dir) &#123;</span><br><span class=\"line\">\treturn function (array, predicate, context) &#123;</span><br><span class=\"line\">\t    // cb中对predicate绑定作用域</span><br><span class=\"line\">\t\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\t\tvar length = getLength(array);</span><br><span class=\"line\">        // 根据dir判断是从头遍历还是从尾遍历</span><br><span class=\"line\">\t\tvar index = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 这里需要判断两个临界条件</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值</span><br><span class=\"line\">\t\t\tif (predicate(array[index], index, array)) return index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 查找不到就返回-1</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the first index on an array-like that passes a predicate test</span><br><span class=\"line\">_.findIndex = createPredicateIndexFinder(1);</span><br><span class=\"line\">_.findLastIndex = createPredicateIndexFinder(-1);</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"sortedIndex二分查找\"><a href=\"#sortedIndex二分查找\" class=\"headerlink\" title=\"sortedIndex二分查找\"></a>sortedIndex二分查找</h2><p>sortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 30, 40]</span><br><span class=\"line\">_.sortedIndex(arr, 25) // 返回2</span><br></pre></td></tr></table></figure></p>\n<p>由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。<br>这里是维基百科对二分查找的定义：</p>\n<blockquote>\n<p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval<br>search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 二分法，可以理解为以中间元素为基准，将数组分成两个</span><br><span class=\"line\">// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小</span><br><span class=\"line\">// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段</span><br><span class=\"line\">// 反过来，就是在数组左半段</span><br><span class=\"line\">_.sortedIndex = function (array, obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 不理解cb函数的建议去看我之前的文章</span><br><span class=\"line\">\titeratee = cb(iteratee, context, 1);</span><br><span class=\"line\">\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值</span><br><span class=\"line\">\t// 如果obj是&#123;age: 20, name: &quot;ygy&quot;&#125;，iteratee是age，那么这个就是根据age来获取到index的</span><br><span class=\"line\">\tvar value = iteratee(obj);</span><br><span class=\"line\">\tvar low = 0, high = getLength(array);</span><br><span class=\"line\">\t// 通过while循环来不断重复上述过程，直到找到obj的位置</span><br><span class=\"line\">\twhile (low &lt; high) &#123;</span><br><span class=\"line\">\t\tvar mid = Math.floor((low + high) / 2);</span><br><span class=\"line\">\t\tif (iteratee(array[mid]) &lt; value) low = mid + 1; else high = mid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn low;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><p>indexOf函数接收array、value和isSorted三个参数。<br>indexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。<br>使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。<br>lastIndexOf接收array、value和fromIndex三个参数。<br>lastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。<br>给下面返回值编上号，以便后面可以直接拿来讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 2, 4, 5]</span><br><span class=\"line\">var index1 = _.indexOf(arr, 2) // 1</span><br><span class=\"line\">// 如果传了索引值为2，那就是从索引为2的地方开始搜索</span><br><span class=\"line\">// 如果不传第三个参数，可以理解为默认是从0开始搜索</span><br><span class=\"line\">var index2 = _.indexOf(arr, 2, 2) // 3</span><br><span class=\"line\">// 从索引为-1的地方查找意思就是从length-2的索引开始查找</span><br><span class=\"line\">var index3 = _.indexOf(arr, 2, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">var index4 = _.lastIndexOf(arr, 2) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分</span><br><span class=\"line\">// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4</span><br><span class=\"line\">// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3</span><br><span class=\"line\">//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）</span><br><span class=\"line\">var index5 = _.lastIndexOf(arr, 2, 4) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索</span><br><span class=\"line\">var index6 = _.lastIndexOf(arr, 2, -1)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\" alt=\"图示\"><br>可能上面有点绕，这里我们再看一下源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);</span><br><span class=\"line\">_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);</span><br><span class=\"line\">function createIndexFinder(dir, predicateFind, sortedIndex) &#123;</span><br><span class=\"line\">    // idx有可能是布尔类型（isSorted）和数字类型</span><br><span class=\"line\">\treturn function (array, item, idx) &#123;</span><br><span class=\"line\">\t\tvar i = 0, length = getLength(array);</span><br><span class=\"line\">\t\t// 如果idx是数字类型，那就是从某个索引开始搜索</span><br><span class=\"line\">\t\tif (typeof idx == &apos;number&apos;) &#123;</span><br><span class=\"line\">\t\t    // dir大于0的时候是从左到右查询（indexOf）</span><br><span class=\"line\">\t\t\tif (dir &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算</span><br><span class=\"line\">\t\t\t\t// idx为负数对应上面的index3的情况</span><br><span class=\"line\">\t\t\t\ti = idx &gt;= 0 ? idx : Math.max(idx + length, i);</span><br><span class=\"line\">\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度</span><br><span class=\"line\">\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）</span><br><span class=\"line\">\t\t\t\tlength = idx &gt;= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找</span><br><span class=\"line\">\t\t&#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123;</span><br><span class=\"line\">\t\t\t// 使用二分法来查找</span><br><span class=\"line\">\t\t\tidx = sortedIndex(array, item);</span><br><span class=\"line\">\t\t\treturn array[idx] === item ? idx : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 如果item是NaN</span><br><span class=\"line\">\t\tif (item !== item) &#123;</span><br><span class=\"line\">\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测</span><br><span class=\"line\">\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了</span><br><span class=\"line\">\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);</span><br><span class=\"line\">\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，</span><br><span class=\"line\">\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数</span><br><span class=\"line\">\t\t\treturn idx &gt;= 0 ? idx + i : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 根据上面计算出来的i和length来进行循环</span><br><span class=\"line\">\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的</span><br><span class=\"line\">\t\tfor (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123;</span><br><span class=\"line\">\t\t\tif (array[idx] === item) return idx;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。<br>这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context</span><br><span class=\"line\">_.find = _.detect = function (obj, predicate, context) &#123;</span><br><span class=\"line\">    var key;</span><br><span class=\"line\">    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">    \tkey = _.findIndex(obj, predicate, context);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">    \tkey = _.findKey(obj, predicate, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）</span><br><span class=\"line\">    // 所以这里对没有查找到的情况做了判断</span><br><span class=\"line\">    if (key !== void 0 &amp;&amp; key !== -1) return obj[key];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>findKey和findIndex方法的实现也都比较简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.findKey = function (obj, predicate, context) &#123;</span><br><span class=\"line\">\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\tvar keys = _.keys(obj), key;</span><br><span class=\"line\">\tfor (var i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tkey = keys[i];</span><br><span class=\"line\">\t\t// 直接return出key意味着只返回第一个通过predicate检测的值</span><br><span class=\"line\">\t\tif (predicate(obj[key], key, obj)) return key;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 根据传入dir的正负来判断是findIndex还是findLastIndex</span><br><span class=\"line\">function createPredicateIndexFinder(dir) &#123;</span><br><span class=\"line\">\treturn function (array, predicate, context) &#123;</span><br><span class=\"line\">\t    // cb中对predicate绑定作用域</span><br><span class=\"line\">\t\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\t\tvar length = getLength(array);</span><br><span class=\"line\">        // 根据dir判断是从头遍历还是从尾遍历</span><br><span class=\"line\">\t\tvar index = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 这里需要判断两个临界条件</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值</span><br><span class=\"line\">\t\t\tif (predicate(array[index], index, array)) return index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 查找不到就返回-1</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the first index on an array-like that passes a predicate test</span><br><span class=\"line\">_.findIndex = createPredicateIndexFinder(1);</span><br><span class=\"line\">_.findLastIndex = createPredicateIndexFinder(-1);</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"sortedIndex二分查找\"><a href=\"#sortedIndex二分查找\" class=\"headerlink\" title=\"sortedIndex二分查找\"></a>sortedIndex二分查找</h2><p>sortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 30, 40]</span><br><span class=\"line\">_.sortedIndex(arr, 25) // 返回2</span><br></pre></td></tr></table></figure></p>\n<p>由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。<br>这里是维基百科对二分查找的定义：</p>\n<blockquote>\n<p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval<br>search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 二分法，可以理解为以中间元素为基准，将数组分成两个</span><br><span class=\"line\">// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小</span><br><span class=\"line\">// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段</span><br><span class=\"line\">// 反过来，就是在数组左半段</span><br><span class=\"line\">_.sortedIndex = function (array, obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 不理解cb函数的建议去看我之前的文章</span><br><span class=\"line\">\titeratee = cb(iteratee, context, 1);</span><br><span class=\"line\">\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值</span><br><span class=\"line\">\t// 如果obj是&#123;age: 20, name: &quot;ygy&quot;&#125;，iteratee是age，那么这个就是根据age来获取到index的</span><br><span class=\"line\">\tvar value = iteratee(obj);</span><br><span class=\"line\">\tvar low = 0, high = getLength(array);</span><br><span class=\"line\">\t// 通过while循环来不断重复上述过程，直到找到obj的位置</span><br><span class=\"line\">\twhile (low &lt; high) &#123;</span><br><span class=\"line\">\t\tvar mid = Math.floor((low + high) / 2);</span><br><span class=\"line\">\t\tif (iteratee(array[mid]) &lt; value) low = mid + 1; else high = mid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn low;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><p>indexOf函数接收array、value和isSorted三个参数。<br>indexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。<br>使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。<br>lastIndexOf接收array、value和fromIndex三个参数。<br>lastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。<br>给下面返回值编上号，以便后面可以直接拿来讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 2, 4, 5]</span><br><span class=\"line\">var index1 = _.indexOf(arr, 2) // 1</span><br><span class=\"line\">// 如果传了索引值为2，那就是从索引为2的地方开始搜索</span><br><span class=\"line\">// 如果不传第三个参数，可以理解为默认是从0开始搜索</span><br><span class=\"line\">var index2 = _.indexOf(arr, 2, 2) // 3</span><br><span class=\"line\">// 从索引为-1的地方查找意思就是从length-2的索引开始查找</span><br><span class=\"line\">var index3 = _.indexOf(arr, 2, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">var index4 = _.lastIndexOf(arr, 2) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分</span><br><span class=\"line\">// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4</span><br><span class=\"line\">// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3</span><br><span class=\"line\">//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）</span><br><span class=\"line\">var index5 = _.lastIndexOf(arr, 2, 4) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索</span><br><span class=\"line\">var index6 = _.lastIndexOf(arr, 2, -1)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\" alt=\"图示\"><br>可能上面有点绕，这里我们再看一下源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);</span><br><span class=\"line\">_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);</span><br><span class=\"line\">function createIndexFinder(dir, predicateFind, sortedIndex) &#123;</span><br><span class=\"line\">    // idx有可能是布尔类型（isSorted）和数字类型</span><br><span class=\"line\">\treturn function (array, item, idx) &#123;</span><br><span class=\"line\">\t\tvar i = 0, length = getLength(array);</span><br><span class=\"line\">\t\t// 如果idx是数字类型，那就是从某个索引开始搜索</span><br><span class=\"line\">\t\tif (typeof idx == &apos;number&apos;) &#123;</span><br><span class=\"line\">\t\t    // dir大于0的时候是从左到右查询（indexOf）</span><br><span class=\"line\">\t\t\tif (dir &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算</span><br><span class=\"line\">\t\t\t\t// idx为负数对应上面的index3的情况</span><br><span class=\"line\">\t\t\t\ti = idx &gt;= 0 ? idx : Math.max(idx + length, i);</span><br><span class=\"line\">\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度</span><br><span class=\"line\">\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）</span><br><span class=\"line\">\t\t\t\tlength = idx &gt;= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找</span><br><span class=\"line\">\t\t&#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123;</span><br><span class=\"line\">\t\t\t// 使用二分法来查找</span><br><span class=\"line\">\t\t\tidx = sortedIndex(array, item);</span><br><span class=\"line\">\t\t\treturn array[idx] === item ? idx : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 如果item是NaN</span><br><span class=\"line\">\t\tif (item !== item) &#123;</span><br><span class=\"line\">\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测</span><br><span class=\"line\">\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了</span><br><span class=\"line\">\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);</span><br><span class=\"line\">\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，</span><br><span class=\"line\">\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数</span><br><span class=\"line\">\t\t\treturn idx &gt;= 0 ? idx + i : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 根据上面计算出来的i和length来进行循环</span><br><span class=\"line\">\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的</span><br><span class=\"line\">\t\tfor (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123;</span><br><span class=\"line\">\t\t\tif (array[idx] === item) return idx;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。<br>这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"layout":"underscore","title":"underscore throttle节流函数分析","date":"2018-03-22T14:14:47.000Z","_content":"这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。\n## throttle节流函数 ##\n\nJavascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。\n比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。\n这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。\n我们可以先尝试着自己实现一个节流函数：\n```\n  // 自己实现的简单节流函数\nfunction throttle (func, time) {\n\tvar timeout = null,\n\t\tcontext = null,\n\t\targs = null\n\treturn function() {\n\t    context = this\n\t\targs = arguments\n\t\t// 只要timeout函数存在，所有调用都无视\n\t\tif(timeout) return;\n\t\ttimeout = setTimeout(function() {\n\t\t\tfunc.apply(context, args)\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = null\n\t\t}, time||500)\n\t}\n}\n```\n我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。\n<!-- more -->\n```\n// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用\n// 如果options.trailing为false，则是禁用第一次执行\n_.throttle = function (func, wait, options) {\n\t\t// 一些初始化操作\n\t\tvar context, args, result;\n\t\tvar timeout = null;\n\t\tvar previous = 0;\n\t\tif (!options) options = {};\n\t\tvar later = function () {\n\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳\n\t\t\tprevious = options.leading === false ? 0 : _.now();\n\t\t\t// 解除引用\n\t\t\ttimeout = null;\n\t\t\tresult = func.apply(context, args);\n\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout\n\t\t\tif (!timeout) context = args = null;\n\t\t};\n\t\treturn function () {\n\t\t    // 获取当前调用时的时间（ms）\n\t\t\tvar now = _.now();\n\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间\n\t\t\t// 这里用全等来避免undefined的情况\n\t\t\tif (!previous && options.leading === false) previous = now;\n\t\t\t// 还要wait时间才会触发下一次func\n\t\t\tvar remaining = wait - (now - previous);\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间\n\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait\n\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况\n\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now\n\t\t\tif (remaining <= 0 || remaining > wait) {\n\t\t\t\tif (timeout) {\n\t\t\t\t    // 清除定时器\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\ttimeout = null;\n\t\t\t\t}\n\t\t\t\t// previous保存当前触发的时间戳\n\t\t\t\tprevious = now;\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tif (!timeout) context = args = null;\n\t\t\t// 如果timeout不存在（当前定时器还存在）\n\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数\n\t\t\t} else if (!timeout && options.trailing !== false) {\n\t\t\t\ttimeout = setTimeout(later, remaining);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t};\n\n```\n这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。\n\n### 没有传leading和trailing ###\n\n 1. 第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳\n 2. 第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func\n 3. 之后每次触发都会重复走2的流程\n\n### options.leading: false ###\n这种情况和上面情况类似，不过区别在于第一次触发的时候。\n由于满足!previous && options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程\n\n### options.trailing: false ###\n\n 1. 由于没有设置leading为false，所以第一次触发就会立即执行一次func\n 2. 第二次触发的时候，由于previous保存了上次时间戳，所以remaining <= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次\n 3. 之后重复步骤2\n\n### trailing和leading都为false ###\n最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。\n\n\n不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？\n这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。\n请直接看第一个回答以及下面的评论区：[关于underscore源码中throttle函数的疑惑？][1]\n## leading带来的不同表现 ##\nGDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    console.log(`函数${++i}在${new Date().getTime() - _now}调用`)\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    // 如果超过了wait时间，那么就立即执行\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\nvar i = 0\nvar test = throttle(() => {\n  console.log(`函数${i}在${new Date().getTime() - _now}执行`)\n}, 1000, {leading: false})\n\nsetInterval(test, 3000)\n```\n我将传入leading和没传入leading的情况作了以下比较。\nleading为false时：\n![leading为false][6]\n没有传入leading时：\n![leading为true][7]\n当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback => wait => callback\n\n一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。\n\n## 为什么是禁用最后一次调用 ##\ntrailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\nvar context, args, result;\nvar timeout = null;\nvar previous = 0;\nif (!options) options = {};\nvar later = function() {\nprevious = options.leading === false ? 0 : new Date().getTime();\ntimeout = null;\nresult = func.apply(context, args);\nif (!timeout) context = args = null;\n};\nreturn function() {\nconsole.log(`函数${++i}在${new Date().getTime() - _now}调用`)\nvar now = new Date().getTime();\nif (!previous && options.leading === false) previous = now;\nvar remaining = wait - (now - previous);\ncontext = this;\nargs = arguments;\n// 如果超过了wait时间，那么就立即执行\nif (remaining <= 0 || remaining > wait) {\n  if (timeout) {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  previous = now;\n  result = func.apply(context, args);\n  if (!timeout) context = args = null;\n} else if (!timeout && options.trailing !== false) {\n  timeout = setTimeout(later, remaining);\n}\nreturn result;\n};\n};\nvar i = 0\nvar test = throttle(() => {\nconsole.log(函数${i}在${new Date().getTime() - _now}执行)\n}, 1000, {trailing: false})\nwindow.addEventListener(\"scroll\", test)\n```\ntrailing为false时：\n![trailing为false][8]\n\n没有设置trailing时：\n![没有设置trailing][9]\n\n这两张图很明显的不同就是设置了trailing的时候，最后一次总是\"执行\"，而未设置trailing最后一次总是\"调用\"，少了一次执行。\n\n我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。\n如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。\n如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。\n\n## 总结 ##\n很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。\n我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。\n本文有错误和不足之处，也希望大家能够指出。\n\n## 参考链接：##\n\n 1. [关于underscore源码中throttle函数的疑惑？][2]\n 2. [ underscore 函数节流的实现][3]\n 3. [ Underscore之throttle函数源码分析以及使用注意事项\n][4]\n 4. [浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异][5]\n\n \n\n\n  [1]: https://segmentfault.com/q/1010000013899949\n  [2]: https://segmentfault.com/q/1010000013899949?_ea=3493310\n  [3]: https://github.com/hanzichi/underscore-analysis/issues/22\n  [4]: http://www.easyui.info/archives/1853.html\n  [5]: https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\n  [6]: http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\n  [7]: http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\n  [8]: http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\n  [9]: http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\n\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore throttle节流函数分析.md","raw":"---\nlayout: underscore\ntitle: underscore throttle节流函数分析\ndate: 2018-03-22 22:14:47\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。\n## throttle节流函数 ##\n\nJavascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。\n比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。\n这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。\n我们可以先尝试着自己实现一个节流函数：\n```\n  // 自己实现的简单节流函数\nfunction throttle (func, time) {\n\tvar timeout = null,\n\t\tcontext = null,\n\t\targs = null\n\treturn function() {\n\t    context = this\n\t\targs = arguments\n\t\t// 只要timeout函数存在，所有调用都无视\n\t\tif(timeout) return;\n\t\ttimeout = setTimeout(function() {\n\t\t\tfunc.apply(context, args)\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = null\n\t\t}, time||500)\n\t}\n}\n```\n我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。\n<!-- more -->\n```\n// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用\n// 如果options.trailing为false，则是禁用第一次执行\n_.throttle = function (func, wait, options) {\n\t\t// 一些初始化操作\n\t\tvar context, args, result;\n\t\tvar timeout = null;\n\t\tvar previous = 0;\n\t\tif (!options) options = {};\n\t\tvar later = function () {\n\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳\n\t\t\tprevious = options.leading === false ? 0 : _.now();\n\t\t\t// 解除引用\n\t\t\ttimeout = null;\n\t\t\tresult = func.apply(context, args);\n\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout\n\t\t\tif (!timeout) context = args = null;\n\t\t};\n\t\treturn function () {\n\t\t    // 获取当前调用时的时间（ms）\n\t\t\tvar now = _.now();\n\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间\n\t\t\t// 这里用全等来避免undefined的情况\n\t\t\tif (!previous && options.leading === false) previous = now;\n\t\t\t// 还要wait时间才会触发下一次func\n\t\t\tvar remaining = wait - (now - previous);\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间\n\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait\n\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况\n\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now\n\t\t\tif (remaining <= 0 || remaining > wait) {\n\t\t\t\tif (timeout) {\n\t\t\t\t    // 清除定时器\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\ttimeout = null;\n\t\t\t\t}\n\t\t\t\t// previous保存当前触发的时间戳\n\t\t\t\tprevious = now;\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tif (!timeout) context = args = null;\n\t\t\t// 如果timeout不存在（当前定时器还存在）\n\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数\n\t\t\t} else if (!timeout && options.trailing !== false) {\n\t\t\t\ttimeout = setTimeout(later, remaining);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t};\n\n```\n这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。\n\n### 没有传leading和trailing ###\n\n 1. 第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳\n 2. 第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func\n 3. 之后每次触发都会重复走2的流程\n\n### options.leading: false ###\n这种情况和上面情况类似，不过区别在于第一次触发的时候。\n由于满足!previous && options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程\n\n### options.trailing: false ###\n\n 1. 由于没有设置leading为false，所以第一次触发就会立即执行一次func\n 2. 第二次触发的时候，由于previous保存了上次时间戳，所以remaining <= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次\n 3. 之后重复步骤2\n\n### trailing和leading都为false ###\n最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。\n\n\n不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？\n这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。\n请直接看第一个回答以及下面的评论区：[关于underscore源码中throttle函数的疑惑？][1]\n## leading带来的不同表现 ##\nGDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    console.log(`函数${++i}在${new Date().getTime() - _now}调用`)\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    // 如果超过了wait时间，那么就立即执行\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\nvar i = 0\nvar test = throttle(() => {\n  console.log(`函数${i}在${new Date().getTime() - _now}执行`)\n}, 1000, {leading: false})\n\nsetInterval(test, 3000)\n```\n我将传入leading和没传入leading的情况作了以下比较。\nleading为false时：\n![leading为false][6]\n没有传入leading时：\n![leading为true][7]\n当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback => wait => callback\n\n一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。\n\n## 为什么是禁用最后一次调用 ##\ntrailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\nvar context, args, result;\nvar timeout = null;\nvar previous = 0;\nif (!options) options = {};\nvar later = function() {\nprevious = options.leading === false ? 0 : new Date().getTime();\ntimeout = null;\nresult = func.apply(context, args);\nif (!timeout) context = args = null;\n};\nreturn function() {\nconsole.log(`函数${++i}在${new Date().getTime() - _now}调用`)\nvar now = new Date().getTime();\nif (!previous && options.leading === false) previous = now;\nvar remaining = wait - (now - previous);\ncontext = this;\nargs = arguments;\n// 如果超过了wait时间，那么就立即执行\nif (remaining <= 0 || remaining > wait) {\n  if (timeout) {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  previous = now;\n  result = func.apply(context, args);\n  if (!timeout) context = args = null;\n} else if (!timeout && options.trailing !== false) {\n  timeout = setTimeout(later, remaining);\n}\nreturn result;\n};\n};\nvar i = 0\nvar test = throttle(() => {\nconsole.log(函数${i}在${new Date().getTime() - _now}执行)\n}, 1000, {trailing: false})\nwindow.addEventListener(\"scroll\", test)\n```\ntrailing为false时：\n![trailing为false][8]\n\n没有设置trailing时：\n![没有设置trailing][9]\n\n这两张图很明显的不同就是设置了trailing的时候，最后一次总是\"执行\"，而未设置trailing最后一次总是\"调用\"，少了一次执行。\n\n我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。\n如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。\n如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。\n\n## 总结 ##\n很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。\n我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。\n本文有错误和不足之处，也希望大家能够指出。\n\n## 参考链接：##\n\n 1. [关于underscore源码中throttle函数的疑惑？][2]\n 2. [ underscore 函数节流的实现][3]\n 3. [ Underscore之throttle函数源码分析以及使用注意事项\n][4]\n 4. [浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异][5]\n\n \n\n\n  [1]: https://segmentfault.com/q/1010000013899949\n  [2]: https://segmentfault.com/q/1010000013899949?_ea=3493310\n  [3]: https://github.com/hanzichi/underscore-analysis/issues/22\n  [4]: http://www.easyui.info/archives/1853.html\n  [5]: https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\n  [6]: http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\n  [7]: http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\n  [8]: http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\n  [9]: http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\n\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore throttle节流函数分析","published":1,"updated":"2019-04-07T05:53:12.961Z","comments":1,"photos":[],"link":"","_id":"cju6jhs600061drfdzjewvj3p","content":"<p>这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。</p>\n<h2 id=\"throttle节流函数\"><a href=\"#throttle节流函数\" class=\"headerlink\" title=\"throttle节流函数\"></a>throttle节流函数</h2><p>Javascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。<br>比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。<br>这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。<br>我们可以先尝试着自己实现一个节流函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // 自己实现的简单节流函数</span><br><span class=\"line\">function throttle (func, time) &#123;</span><br><span class=\"line\">\tvar timeout = null,</span><br><span class=\"line\">\t\tcontext = null,</span><br><span class=\"line\">\t\targs = null</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t    context = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 只要timeout函数存在，所有调用都无视</span><br><span class=\"line\">\t\tif(timeout) return;</span><br><span class=\"line\">\t\ttimeout = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t\ttimeout = null</span><br><span class=\"line\">\t\t&#125;, time||500)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用</span><br><span class=\"line\">// 如果options.trailing为false，则是禁用第一次执行</span><br><span class=\"line\">_.throttle = function (func, wait, options) &#123;</span><br><span class=\"line\">\t\t// 一些初始化操作</span><br><span class=\"line\">\t\tvar context, args, result;</span><br><span class=\"line\">\t\tvar timeout = null;</span><br><span class=\"line\">\t\tvar previous = 0;</span><br><span class=\"line\">\t\tif (!options) options = &#123;&#125;;</span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳</span><br><span class=\"line\">\t\t\tprevious = options.leading === false ? 0 : _.now();</span><br><span class=\"line\">\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout</span><br><span class=\"line\">\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t    // 获取当前调用时的时间（ms）</span><br><span class=\"line\">\t\t\tvar now = _.now();</span><br><span class=\"line\">\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间</span><br><span class=\"line\">\t\t\t// 这里用全等来避免undefined的情况</span><br><span class=\"line\">\t\t\tif (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">\t\t\t// 还要wait时间才会触发下一次func</span><br><span class=\"line\">\t\t\tvar remaining = wait - (now - previous);</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间</span><br><span class=\"line\">\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait</span><br><span class=\"line\">\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况</span><br><span class=\"line\">\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now</span><br><span class=\"line\">\t\t\tif (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">\t\t\t\tif (timeout) &#123;</span><br><span class=\"line\">\t\t\t\t    // 清除定时器</span><br><span class=\"line\">\t\t\t\t\tclearTimeout(timeout);</span><br><span class=\"line\">\t\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t// previous保存当前触发的时间戳</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t// 如果timeout不存在（当前定时器还存在）</span><br><span class=\"line\">\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数</span><br><span class=\"line\">\t\t\t&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, remaining);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。</p>\n<h3 id=\"没有传leading和trailing\"><a href=\"#没有传leading和trailing\" class=\"headerlink\" title=\"没有传leading和trailing\"></a>没有传leading和trailing</h3><ol>\n<li>第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳</li>\n<li>第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func</li>\n<li>之后每次触发都会重复走2的流程</li>\n</ol>\n<h3 id=\"options-leading-false\"><a href=\"#options-leading-false\" class=\"headerlink\" title=\"options.leading: false\"></a>options.leading: false</h3><p>这种情况和上面情况类似，不过区别在于第一次触发的时候。<br>由于满足!previous &amp;&amp; options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程</p>\n<h3 id=\"options-trailing-false\"><a href=\"#options-trailing-false\" class=\"headerlink\" title=\"options.trailing: false\"></a>options.trailing: false</h3><ol>\n<li>由于没有设置leading为false，所以第一次触发就会立即执行一次func</li>\n<li>第二次触发的时候，由于previous保存了上次时间戳，所以remaining &lt;= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次</li>\n<li>之后重复步骤2</li>\n</ol>\n<h3 id=\"trailing和leading都为false\"><a href=\"#trailing和leading都为false\" class=\"headerlink\" title=\"trailing和leading都为false\"></a>trailing和leading都为false</h3><p>最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。</p>\n<p>不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？<br>这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。<br>请直接看第一个回答以及下面的评论区：<a href=\"https://segmentfault.com/q/1010000013899949\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></p>\n<h2 id=\"leading带来的不同表现\"><a href=\"#leading带来的不同表现\" class=\"headerlink\" title=\"leading带来的不同表现\"></a>leading带来的不同表现</h2><p>GDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">  var context, args, result;</span><br><span class=\"line\">  var timeout = null;</span><br><span class=\"line\">  var previous = 0;</span><br><span class=\"line\">  if (!options) options = &#123;&#125;;</span><br><span class=\"line\">  var later = function() &#123;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    if (!timeout) context = args = null;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">    var now = new Date().getTime();</span><br><span class=\"line\">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">    var remaining = wait - (now - previous);</span><br><span class=\"line\">    context = this;</span><br><span class=\"line\">    args = arguments;</span><br><span class=\"line\">    // 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">      if (timeout) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      if (!timeout) context = args = null;</span><br><span class=\"line\">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">      timeout = setTimeout(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">  console.log(`函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行`)</span><br><span class=\"line\">&#125;, 1000, &#123;leading: false&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(test, 3000)</span><br></pre></td></tr></table></figure></p>\n<p>我将传入leading和没传入leading的情况作了以下比较。<br>leading为false时：<br><img src=\"http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\" alt=\"leading为false\"><br>没有传入leading时：<br><img src=\"http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\" alt=\"leading为true\"><br>当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback =&gt; wait =&gt; callback</p>\n<p>一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。</p>\n<h2 id=\"为什么是禁用最后一次调用\"><a href=\"#为什么是禁用最后一次调用\" class=\"headerlink\" title=\"为什么是禁用最后一次调用\"></a>为什么是禁用最后一次调用</h2><p>trailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">var context, args, result;</span><br><span class=\"line\">var timeout = null;</span><br><span class=\"line\">var previous = 0;</span><br><span class=\"line\">if (!options) options = &#123;&#125;;</span><br><span class=\"line\">var later = function() &#123;</span><br><span class=\"line\">previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">timeout = null;</span><br><span class=\"line\">result = func.apply(context, args);</span><br><span class=\"line\">if (!timeout) context = args = null;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return function() &#123;</span><br><span class=\"line\">console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">var now = new Date().getTime();</span><br><span class=\"line\">if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">var remaining = wait - (now - previous);</span><br><span class=\"line\">context = this;</span><br><span class=\"line\">args = arguments;</span><br><span class=\"line\">// 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">  if (timeout) &#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  previous = now;</span><br><span class=\"line\">  result = func.apply(context, args);</span><br><span class=\"line\">  if (!timeout) context = args = null;</span><br><span class=\"line\">&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">  timeout = setTimeout(later, remaining);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">console.log(函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行)</span><br><span class=\"line\">&#125;, 1000, &#123;trailing: false&#125;)</span><br><span class=\"line\">window.addEventListener(&quot;scroll&quot;, test)</span><br></pre></td></tr></table></figure></p>\n<p>trailing为false时：<br><img src=\"http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\" alt=\"trailing为false\"></p>\n<p>没有设置trailing时：<br><img src=\"http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\" alt=\"没有设置trailing\"></p>\n<p>这两张图很明显的不同就是设置了trailing的时候，最后一次总是”执行”，而未设置trailing最后一次总是”调用”，少了一次执行。</p>\n<p>我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。<br>如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。<br>如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。<br>我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。<br>本文有错误和不足之处，也希望大家能够指出。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><ol>\n<li><a href=\"https://segmentfault.com/q/1010000013899949?_ea=3493310\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></li>\n<li><a href=\"https://github.com/hanzichi/underscore-analysis/issues/22\" target=\"_blank\" rel=\"noopener\"> underscore 函数节流的实现</a></li>\n<li><a href=\"http://www.easyui.info/archives/1853.html\" target=\"_blank\" rel=\"noopener\"> Underscore之throttle函数源码分析以及使用注意事项\n</a></li>\n<li><a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\" target=\"_blank\" rel=\"noopener\">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a></li>\n</ol>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。</p>\n<h2 id=\"throttle节流函数\"><a href=\"#throttle节流函数\" class=\"headerlink\" title=\"throttle节流函数\"></a>throttle节流函数</h2><p>Javascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。<br>比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。<br>这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。<br>我们可以先尝试着自己实现一个节流函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // 自己实现的简单节流函数</span><br><span class=\"line\">function throttle (func, time) &#123;</span><br><span class=\"line\">\tvar timeout = null,</span><br><span class=\"line\">\t\tcontext = null,</span><br><span class=\"line\">\t\targs = null</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t    context = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 只要timeout函数存在，所有调用都无视</span><br><span class=\"line\">\t\tif(timeout) return;</span><br><span class=\"line\">\t\ttimeout = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t\ttimeout = null</span><br><span class=\"line\">\t\t&#125;, time||500)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用</span><br><span class=\"line\">// 如果options.trailing为false，则是禁用第一次执行</span><br><span class=\"line\">_.throttle = function (func, wait, options) &#123;</span><br><span class=\"line\">\t\t// 一些初始化操作</span><br><span class=\"line\">\t\tvar context, args, result;</span><br><span class=\"line\">\t\tvar timeout = null;</span><br><span class=\"line\">\t\tvar previous = 0;</span><br><span class=\"line\">\t\tif (!options) options = &#123;&#125;;</span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳</span><br><span class=\"line\">\t\t\tprevious = options.leading === false ? 0 : _.now();</span><br><span class=\"line\">\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout</span><br><span class=\"line\">\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t    // 获取当前调用时的时间（ms）</span><br><span class=\"line\">\t\t\tvar now = _.now();</span><br><span class=\"line\">\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间</span><br><span class=\"line\">\t\t\t// 这里用全等来避免undefined的情况</span><br><span class=\"line\">\t\t\tif (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">\t\t\t// 还要wait时间才会触发下一次func</span><br><span class=\"line\">\t\t\tvar remaining = wait - (now - previous);</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间</span><br><span class=\"line\">\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait</span><br><span class=\"line\">\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况</span><br><span class=\"line\">\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now</span><br><span class=\"line\">\t\t\tif (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">\t\t\t\tif (timeout) &#123;</span><br><span class=\"line\">\t\t\t\t    // 清除定时器</span><br><span class=\"line\">\t\t\t\t\tclearTimeout(timeout);</span><br><span class=\"line\">\t\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t// previous保存当前触发的时间戳</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t// 如果timeout不存在（当前定时器还存在）</span><br><span class=\"line\">\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数</span><br><span class=\"line\">\t\t\t&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, remaining);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。</p>\n<h3 id=\"没有传leading和trailing\"><a href=\"#没有传leading和trailing\" class=\"headerlink\" title=\"没有传leading和trailing\"></a>没有传leading和trailing</h3><ol>\n<li>第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳</li>\n<li>第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func</li>\n<li>之后每次触发都会重复走2的流程</li>\n</ol>\n<h3 id=\"options-leading-false\"><a href=\"#options-leading-false\" class=\"headerlink\" title=\"options.leading: false\"></a>options.leading: false</h3><p>这种情况和上面情况类似，不过区别在于第一次触发的时候。<br>由于满足!previous &amp;&amp; options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程</p>\n<h3 id=\"options-trailing-false\"><a href=\"#options-trailing-false\" class=\"headerlink\" title=\"options.trailing: false\"></a>options.trailing: false</h3><ol>\n<li>由于没有设置leading为false，所以第一次触发就会立即执行一次func</li>\n<li>第二次触发的时候，由于previous保存了上次时间戳，所以remaining &lt;= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次</li>\n<li>之后重复步骤2</li>\n</ol>\n<h3 id=\"trailing和leading都为false\"><a href=\"#trailing和leading都为false\" class=\"headerlink\" title=\"trailing和leading都为false\"></a>trailing和leading都为false</h3><p>最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。</p>\n<p>不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？<br>这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。<br>请直接看第一个回答以及下面的评论区：<a href=\"https://segmentfault.com/q/1010000013899949\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></p>\n<h2 id=\"leading带来的不同表现\"><a href=\"#leading带来的不同表现\" class=\"headerlink\" title=\"leading带来的不同表现\"></a>leading带来的不同表现</h2><p>GDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">  var context, args, result;</span><br><span class=\"line\">  var timeout = null;</span><br><span class=\"line\">  var previous = 0;</span><br><span class=\"line\">  if (!options) options = &#123;&#125;;</span><br><span class=\"line\">  var later = function() &#123;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    if (!timeout) context = args = null;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">    var now = new Date().getTime();</span><br><span class=\"line\">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">    var remaining = wait - (now - previous);</span><br><span class=\"line\">    context = this;</span><br><span class=\"line\">    args = arguments;</span><br><span class=\"line\">    // 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">      if (timeout) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      if (!timeout) context = args = null;</span><br><span class=\"line\">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">      timeout = setTimeout(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">  console.log(`函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行`)</span><br><span class=\"line\">&#125;, 1000, &#123;leading: false&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(test, 3000)</span><br></pre></td></tr></table></figure></p>\n<p>我将传入leading和没传入leading的情况作了以下比较。<br>leading为false时：<br><img src=\"http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\" alt=\"leading为false\"><br>没有传入leading时：<br><img src=\"http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\" alt=\"leading为true\"><br>当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback =&gt; wait =&gt; callback</p>\n<p>一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。</p>\n<h2 id=\"为什么是禁用最后一次调用\"><a href=\"#为什么是禁用最后一次调用\" class=\"headerlink\" title=\"为什么是禁用最后一次调用\"></a>为什么是禁用最后一次调用</h2><p>trailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">var context, args, result;</span><br><span class=\"line\">var timeout = null;</span><br><span class=\"line\">var previous = 0;</span><br><span class=\"line\">if (!options) options = &#123;&#125;;</span><br><span class=\"line\">var later = function() &#123;</span><br><span class=\"line\">previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">timeout = null;</span><br><span class=\"line\">result = func.apply(context, args);</span><br><span class=\"line\">if (!timeout) context = args = null;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return function() &#123;</span><br><span class=\"line\">console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">var now = new Date().getTime();</span><br><span class=\"line\">if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">var remaining = wait - (now - previous);</span><br><span class=\"line\">context = this;</span><br><span class=\"line\">args = arguments;</span><br><span class=\"line\">// 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">  if (timeout) &#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  previous = now;</span><br><span class=\"line\">  result = func.apply(context, args);</span><br><span class=\"line\">  if (!timeout) context = args = null;</span><br><span class=\"line\">&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">  timeout = setTimeout(later, remaining);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">console.log(函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行)</span><br><span class=\"line\">&#125;, 1000, &#123;trailing: false&#125;)</span><br><span class=\"line\">window.addEventListener(&quot;scroll&quot;, test)</span><br></pre></td></tr></table></figure></p>\n<p>trailing为false时：<br><img src=\"http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\" alt=\"trailing为false\"></p>\n<p>没有设置trailing时：<br><img src=\"http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\" alt=\"没有设置trailing\"></p>\n<p>这两张图很明显的不同就是设置了trailing的时候，最后一次总是”执行”，而未设置trailing最后一次总是”调用”，少了一次执行。</p>\n<p>我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。<br>如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。<br>如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。<br>我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。<br>本文有错误和不足之处，也希望大家能够指出。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><ol>\n<li><a href=\"https://segmentfault.com/q/1010000013899949?_ea=3493310\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></li>\n<li><a href=\"https://github.com/hanzichi/underscore-analysis/issues/22\" target=\"_blank\" rel=\"noopener\"> underscore 函数节流的实现</a></li>\n<li><a href=\"http://www.easyui.info/archives/1853.html\" target=\"_blank\" rel=\"noopener\"> Underscore之throttle函数源码分析以及使用注意事项\n</a></li>\n<li><a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\" target=\"_blank\" rel=\"noopener\">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a></li>\n</ol>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之数组遍历函数分析（一）","date":"2018-03-19T14:11:23.000Z","_content":"这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。\n\n\n## **each** ##\n\n在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。\n```\n// iteratee函数有三个参数，分别是item、index、array或者value、key、obj\n_.each = _.forEach = function(obj, iteratee, context) {\n    // 如果不传context，那么each方法里面的this就会指向window\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等\n    if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n            iteratee(obj[i], i, obj);\n        }\n    // 一般是指对象\n    } else {\n        var keys = _.keys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n            iteratee(obj[keys[i]], keys[i], obj);\n        }\n    }\n    return obj;\n};\n```\neach函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数\n<!-- more -->\n不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。\n### optimizeCb ###\n```\n    // 这个函数主要是给传进来的func函数绑定context作用域。\n\tvar optimizeCb = function (func, context, argCount) {\n\t    // 如果没有传context，那就直接返回func函数\n\t\tif (context === void 0) return func;\n\t\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数\n\t\tswitch (argCount == null ? 3 : argCount) {\n\t\t\tcase 1: return function (value) {\n\t\t\t\treturn func.call(context, value);\n\t\t\t};\n\t\t\tcase 2: return function (value, other) {\n\t\t\t\treturn func.call(context, value, other);\n\t\t\t};\n\t\t\t// 一般是each、map等\n\t\t\tcase 3: return function (value, index, collection) {\n\t\t\t\treturn func.call(context, value, index, collection);\n\t\t\t};\n\t\t\t// 一般是reduce等\n\t\t\tcase 4: return function (accumulator, value, index, collection) {\n\t\t\t\treturn func.call(context, accumulator, value, index, collection);\n\t\t\t};\n\t\t}\n\t\t// 如果参数数量大于4\n\t\treturn function () {\n\t\t\treturn func.apply(context, arguments);\n\t\t};\n\t};\n```\n其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。\n这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？\n原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：[call和apply][1]\n\n### isArrayLike ###\n关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）\n```\n// 一个高阶函数，返回对象上某个具体属性的值\nvar property = function (key) {\n\treturn function (obj) {\n\t\treturn obj == null ? void 0 : obj[key];\n\t};\n};\n\n// 这里有个ios8上面的bug，会导致类似var pbj = {1: \"a\", 2: \"b\", 3: \"c\"}这种对象的obj.length = 4; jQuery中也有这个bug。\n// https://github.com/jashkenas/underscore/issues/2081 \n// https://github.com/jquery/jquery/issues/2145\n// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).\n// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// 据说用obj[\"length\"]就可以解决？我没有ios8的环境，有兴趣的可以试试\nvar getLength = property('length');\n\n// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组\nvar isArrayLike = function (collection) {\n\tvar length = getLength(collection);\n\treturn typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n};\n```\n在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。\n我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。\n```\nfunction isArrayLike(obj) {\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType(obj);\n\t// 排除了obj为function和全局中有length变量的情况\n\tif (isFunction(obj) || isWindow(obj)) {\n\t\treturn false;\n\t}\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n```\njQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。\n\n最后的三个判断分别是：\n\n 1. 如果obj的类型是数组，那么返回true\n 2. 如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。\n 3. 最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length>0和length===\"number\"的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。\n## map ##\n说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。\n```\nvar arr = [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result1 = _.map(arr); // [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result2 = _.map(arr, {name: 'Daisy'}) // [false, true]\n```\n所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。\n```\n_.map = _.collect = function (obj, iteratee, context) {\n\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。\n\t\titeratee = cb(iteratee, context);\n\t\t// 如果不是类数组（是对象），则获取到keys\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn results;\n\t};\n```\n### cb ###\n我们来看看map函数中这个cb函数到底是什么来历？\n```\n_.identity = function (value) {\n\treturn value;\n};\nvar cb = function (value, context, argCount) {\n    // 如果value不存在\n\tif (value == null) return _.identity;\n\t// 如果传入的是个函数\n\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\t// 如果传入的是个对象\n\tif (_.isObject(value)) return _.matcher(value);\n\treturn _.property(value);\n};\n```\ncb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。\n 1. 如果value不存在，那就对应上面的_.map(obj)的情况，map中的iteratee就是_.identity函数，他会将后面接收到的obj[currentKey]直接返回。\n 2. 如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的\n 3. 如果value是个对象，对应_.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用_.matcher函数\n 4. 这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：[iteratee函数][2]\n### matcher ###\n那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。\n```\n_.matcher = _.matches = function (attrs) {\n    // 将attrs和{}合并为一个对象（避免attrs为undefined）\n\tattrs = _.extendOwn({}, attrs);\n\treturn function (obj) {\n\t\treturn _.isMatch(obj, attrs);\n\t};\n};\n// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项\n_.isMatch = function (object, attrs) {\n\tvar keys = _.keys(attrs), length = keys.length;\n\t// 如果object和attr都是空，那么返回true，否则object为空时返回false\n\tif (object == null) return !length;\n\t// 这一步没懂是为了做什么？\n\tvar obj = Object(object);\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;\n\t}\n\treturn true;\n};\n```\nmatcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。\n这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。\n所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。\n这也就是为什么_.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); 会返回 [false, true]。\n### 重写each ###\neach和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each\n```\n_.each = _.forEach = function (obj, iteratee, context) {\n\t\titeratee = optimizeCb(iteratee, context);\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\titeratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn obj;\n\t};\n```\n## filter、every、some、reject ##\n这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。\n\n  [1]: https://segmentfault.com/q/1010000007894513\n  [2]: http://www.bootcss.com/p/underscore/#iteratee\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之数组遍历函数分析（一）.md","raw":"---\ntitle: underscore源码剖析之数组遍历函数分析（一）\ndate: 2018-03-19 22:11:23\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。\n\n\n## **each** ##\n\n在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。\n```\n// iteratee函数有三个参数，分别是item、index、array或者value、key、obj\n_.each = _.forEach = function(obj, iteratee, context) {\n    // 如果不传context，那么each方法里面的this就会指向window\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等\n    if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n            iteratee(obj[i], i, obj);\n        }\n    // 一般是指对象\n    } else {\n        var keys = _.keys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n            iteratee(obj[keys[i]], keys[i], obj);\n        }\n    }\n    return obj;\n};\n```\neach函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数\n<!-- more -->\n不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。\n### optimizeCb ###\n```\n    // 这个函数主要是给传进来的func函数绑定context作用域。\n\tvar optimizeCb = function (func, context, argCount) {\n\t    // 如果没有传context，那就直接返回func函数\n\t\tif (context === void 0) return func;\n\t\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数\n\t\tswitch (argCount == null ? 3 : argCount) {\n\t\t\tcase 1: return function (value) {\n\t\t\t\treturn func.call(context, value);\n\t\t\t};\n\t\t\tcase 2: return function (value, other) {\n\t\t\t\treturn func.call(context, value, other);\n\t\t\t};\n\t\t\t// 一般是each、map等\n\t\t\tcase 3: return function (value, index, collection) {\n\t\t\t\treturn func.call(context, value, index, collection);\n\t\t\t};\n\t\t\t// 一般是reduce等\n\t\t\tcase 4: return function (accumulator, value, index, collection) {\n\t\t\t\treturn func.call(context, accumulator, value, index, collection);\n\t\t\t};\n\t\t}\n\t\t// 如果参数数量大于4\n\t\treturn function () {\n\t\t\treturn func.apply(context, arguments);\n\t\t};\n\t};\n```\n其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。\n这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？\n原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：[call和apply][1]\n\n### isArrayLike ###\n关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）\n```\n// 一个高阶函数，返回对象上某个具体属性的值\nvar property = function (key) {\n\treturn function (obj) {\n\t\treturn obj == null ? void 0 : obj[key];\n\t};\n};\n\n// 这里有个ios8上面的bug，会导致类似var pbj = {1: \"a\", 2: \"b\", 3: \"c\"}这种对象的obj.length = 4; jQuery中也有这个bug。\n// https://github.com/jashkenas/underscore/issues/2081 \n// https://github.com/jquery/jquery/issues/2145\n// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).\n// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// 据说用obj[\"length\"]就可以解决？我没有ios8的环境，有兴趣的可以试试\nvar getLength = property('length');\n\n// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组\nvar isArrayLike = function (collection) {\n\tvar length = getLength(collection);\n\treturn typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n};\n```\n在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。\n我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。\n```\nfunction isArrayLike(obj) {\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType(obj);\n\t// 排除了obj为function和全局中有length变量的情况\n\tif (isFunction(obj) || isWindow(obj)) {\n\t\treturn false;\n\t}\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n```\njQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。\n\n最后的三个判断分别是：\n\n 1. 如果obj的类型是数组，那么返回true\n 2. 如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。\n 3. 最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length>0和length===\"number\"的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。\n## map ##\n说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。\n```\nvar arr = [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result1 = _.map(arr); // [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result2 = _.map(arr, {name: 'Daisy'}) // [false, true]\n```\n所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。\n```\n_.map = _.collect = function (obj, iteratee, context) {\n\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。\n\t\titeratee = cb(iteratee, context);\n\t\t// 如果不是类数组（是对象），则获取到keys\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn results;\n\t};\n```\n### cb ###\n我们来看看map函数中这个cb函数到底是什么来历？\n```\n_.identity = function (value) {\n\treturn value;\n};\nvar cb = function (value, context, argCount) {\n    // 如果value不存在\n\tif (value == null) return _.identity;\n\t// 如果传入的是个函数\n\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\t// 如果传入的是个对象\n\tif (_.isObject(value)) return _.matcher(value);\n\treturn _.property(value);\n};\n```\ncb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。\n 1. 如果value不存在，那就对应上面的_.map(obj)的情况，map中的iteratee就是_.identity函数，他会将后面接收到的obj[currentKey]直接返回。\n 2. 如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的\n 3. 如果value是个对象，对应_.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用_.matcher函数\n 4. 这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：[iteratee函数][2]\n### matcher ###\n那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。\n```\n_.matcher = _.matches = function (attrs) {\n    // 将attrs和{}合并为一个对象（避免attrs为undefined）\n\tattrs = _.extendOwn({}, attrs);\n\treturn function (obj) {\n\t\treturn _.isMatch(obj, attrs);\n\t};\n};\n// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项\n_.isMatch = function (object, attrs) {\n\tvar keys = _.keys(attrs), length = keys.length;\n\t// 如果object和attr都是空，那么返回true，否则object为空时返回false\n\tif (object == null) return !length;\n\t// 这一步没懂是为了做什么？\n\tvar obj = Object(object);\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;\n\t}\n\treturn true;\n};\n```\nmatcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。\n这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。\n所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。\n这也就是为什么_.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); 会返回 [false, true]。\n### 重写each ###\neach和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each\n```\n_.each = _.forEach = function (obj, iteratee, context) {\n\t\titeratee = optimizeCb(iteratee, context);\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\titeratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn obj;\n\t};\n```\n## filter、every、some、reject ##\n这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。\n\n  [1]: https://segmentfault.com/q/1010000007894513\n  [2]: http://www.bootcss.com/p/underscore/#iteratee\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之数组遍历函数分析（一）","published":1,"updated":"2019-04-07T05:53:12.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs630063drfd025cdpab","content":"<p>这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。</p>\n<h2 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"each\"></a><strong>each</strong></h2><p>在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iteratee函数有三个参数，分别是item、index、array或者value、key、obj</span><br><span class=\"line\">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 如果不传context，那么each方法里面的this就会指向window</span><br><span class=\"line\">    iteratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">    var i, length;</span><br><span class=\"line\">    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">        for (i = 0, length = obj.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[i], i, obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    // 一般是指对象</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var keys = _.keys(obj);</span><br><span class=\"line\">        for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[keys[i]], keys[i], obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>each函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数<br><a id=\"more\"></a><br>不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。</p>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // 这个函数主要是给传进来的func函数绑定context作用域。</span><br><span class=\"line\">var optimizeCb = function (func, context, argCount) &#123;</span><br><span class=\"line\">    // 如果没有传context，那就直接返回func函数</span><br><span class=\"line\">\tif (context === void 0) return func;</span><br><span class=\"line\">\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数</span><br><span class=\"line\">\tswitch (argCount == null ? 3 : argCount) &#123;</span><br><span class=\"line\">\t\tcase 1: return function (value) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tcase 2: return function (value, other) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, other);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是each、map等</span><br><span class=\"line\">\t\tcase 3: return function (value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是reduce等</span><br><span class=\"line\">\t\tcase 4: return function (accumulator, value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 如果参数数量大于4</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\treturn func.apply(context, arguments);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。<br>这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？<br>原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：<a href=\"https://segmentfault.com/q/1010000007894513\" target=\"_blank\" rel=\"noopener\">call和apply</a></p>\n<h3 id=\"isArrayLike\"><a href=\"#isArrayLike\" class=\"headerlink\" title=\"isArrayLike\"></a>isArrayLike</h3><p>关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个高阶函数，返回对象上某个具体属性的值</span><br><span class=\"line\">var property = function (key) &#123;</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn obj == null ? void 0 : obj[key];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里有个ios8上面的bug，会导致类似var pbj = &#123;1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;&#125;这种对象的obj.length = 4; jQuery中也有这个bug。</span><br><span class=\"line\">// https://github.com/jashkenas/underscore/issues/2081 </span><br><span class=\"line\">// https://github.com/jquery/jquery/issues/2145</span><br><span class=\"line\">// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).</span><br><span class=\"line\">// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer</span><br><span class=\"line\">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 据说用obj[&quot;length&quot;]就可以解决？我没有ios8的环境，有兴趣的可以试试</span><br><span class=\"line\">var getLength = property(&apos;length&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组</span><br><span class=\"line\">var isArrayLike = function (collection) &#123;</span><br><span class=\"line\">\tvar length = getLength(collection);</span><br><span class=\"line\">\treturn typeof length == &apos;number&apos; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。<br>我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArrayLike(obj) &#123;</span><br><span class=\"line\">\t// Support: real iOS 8.2 only (not reproducible in simulator)</span><br><span class=\"line\">\t// `in` check used to prevent JIT error (gh-2145)</span><br><span class=\"line\">\t// hasOwn isn&apos;t used here due to false negatives</span><br><span class=\"line\">\t// regarding Nodelist length in IE</span><br><span class=\"line\">\tvar length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class=\"line\">\t\ttype = toType(obj);</span><br><span class=\"line\">\t// 排除了obj为function和全局中有length变量的情况</span><br><span class=\"line\">\tif (isFunction(obj) || isWindow(obj)) &#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn type === &quot;array&quot; || length === 0 ||</span><br><span class=\"line\">\t\ttypeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。</p>\n<p>最后的三个判断分别是：</p>\n<ol>\n<li>如果obj的类型是数组，那么返回true</li>\n<li>如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。</li>\n<li>最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length&gt;0和length===”number”的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2>说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result1 = _.map(arr); // [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result2 = _.map(arr, &#123;name: &apos;Daisy&apos;&#125;) // [false, true]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.map = _.collect = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。</span><br><span class=\"line\">\t\titeratee = cb(iteratee, context);</span><br><span class=\"line\">\t\t// 如果不是类数组（是对象），则获取到keys</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p>我们来看看map函数中这个cb函数到底是什么来历？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.identity = function (value) &#123;</span><br><span class=\"line\">\treturn value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var cb = function (value, context, argCount) &#123;</span><br><span class=\"line\">    // 如果value不存在</span><br><span class=\"line\">\tif (value == null) return _.identity;</span><br><span class=\"line\">\t// 如果传入的是个函数</span><br><span class=\"line\">\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);</span><br><span class=\"line\">\t// 如果传入的是个对象</span><br><span class=\"line\">\tif (_.isObject(value)) return _.matcher(value);</span><br><span class=\"line\">\treturn _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>cb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。</p>\n<ol>\n<li>如果value不存在，那就对应上面的<em>.map(obj)的情况，map中的iteratee就是</em>.identity函数，他会将后面接收到的obj[currentKey]直接返回。</li>\n<li>如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的</li>\n<li>如果value是个对象，对应<em>.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用</em>.matcher函数</li>\n<li>这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：<a href=\"http://www.bootcss.com/p/underscore/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee函数</a><h3 id=\"matcher\"><a href=\"#matcher\" class=\"headerlink\" title=\"matcher\"></a>matcher</h3>那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.matcher = _.matches = function (attrs) &#123;</span><br><span class=\"line\">    // 将attrs和&#123;&#125;合并为一个对象（避免attrs为undefined）</span><br><span class=\"line\">\tattrs = _.extendOwn(&#123;&#125;, attrs);</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn _.isMatch(obj, attrs);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项</span><br><span class=\"line\">_.isMatch = function (object, attrs) &#123;</span><br><span class=\"line\">\tvar keys = _.keys(attrs), length = keys.length;</span><br><span class=\"line\">\t// 如果object和attr都是空，那么返回true，否则object为空时返回false</span><br><span class=\"line\">\tif (object == null) return !length;</span><br><span class=\"line\">\t// 这一步没懂是为了做什么？</span><br><span class=\"line\">\tvar obj = Object(object);</span><br><span class=\"line\">\tfor (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tvar key = keys[i];</span><br><span class=\"line\">\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>matcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。<br>这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。<br>所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。<br>这也就是为什么_.map([{name:’Kevin’}, {name: ‘Daisy’, age: 18}], {name: ‘Daisy’}); 会返回 [false, true]。</p>\n<h3 id=\"重写each\"><a href=\"#重写each\" class=\"headerlink\" title=\"重写each\"></a>重写each</h3><p>each和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each = _.forEach = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\titeratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn obj;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter、every、some、reject\"><a href=\"#filter、every、some、reject\" class=\"headerlink\" title=\"filter、every、some、reject\"></a>filter、every、some、reject</h2><p>这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。</p>\n<h2 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"each\"></a><strong>each</strong></h2><p>在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iteratee函数有三个参数，分别是item、index、array或者value、key、obj</span><br><span class=\"line\">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 如果不传context，那么each方法里面的this就会指向window</span><br><span class=\"line\">    iteratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">    var i, length;</span><br><span class=\"line\">    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">        for (i = 0, length = obj.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[i], i, obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    // 一般是指对象</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var keys = _.keys(obj);</span><br><span class=\"line\">        for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[keys[i]], keys[i], obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>each函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数<br>","more":"<br>不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。</p>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // 这个函数主要是给传进来的func函数绑定context作用域。</span><br><span class=\"line\">var optimizeCb = function (func, context, argCount) &#123;</span><br><span class=\"line\">    // 如果没有传context，那就直接返回func函数</span><br><span class=\"line\">\tif (context === void 0) return func;</span><br><span class=\"line\">\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数</span><br><span class=\"line\">\tswitch (argCount == null ? 3 : argCount) &#123;</span><br><span class=\"line\">\t\tcase 1: return function (value) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tcase 2: return function (value, other) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, other);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是each、map等</span><br><span class=\"line\">\t\tcase 3: return function (value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是reduce等</span><br><span class=\"line\">\t\tcase 4: return function (accumulator, value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 如果参数数量大于4</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\treturn func.apply(context, arguments);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。<br>这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？<br>原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：<a href=\"https://segmentfault.com/q/1010000007894513\" target=\"_blank\" rel=\"noopener\">call和apply</a></p>\n<h3 id=\"isArrayLike\"><a href=\"#isArrayLike\" class=\"headerlink\" title=\"isArrayLike\"></a>isArrayLike</h3><p>关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个高阶函数，返回对象上某个具体属性的值</span><br><span class=\"line\">var property = function (key) &#123;</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn obj == null ? void 0 : obj[key];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里有个ios8上面的bug，会导致类似var pbj = &#123;1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;&#125;这种对象的obj.length = 4; jQuery中也有这个bug。</span><br><span class=\"line\">// https://github.com/jashkenas/underscore/issues/2081 </span><br><span class=\"line\">// https://github.com/jquery/jquery/issues/2145</span><br><span class=\"line\">// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).</span><br><span class=\"line\">// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer</span><br><span class=\"line\">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 据说用obj[&quot;length&quot;]就可以解决？我没有ios8的环境，有兴趣的可以试试</span><br><span class=\"line\">var getLength = property(&apos;length&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组</span><br><span class=\"line\">var isArrayLike = function (collection) &#123;</span><br><span class=\"line\">\tvar length = getLength(collection);</span><br><span class=\"line\">\treturn typeof length == &apos;number&apos; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。<br>我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArrayLike(obj) &#123;</span><br><span class=\"line\">\t// Support: real iOS 8.2 only (not reproducible in simulator)</span><br><span class=\"line\">\t// `in` check used to prevent JIT error (gh-2145)</span><br><span class=\"line\">\t// hasOwn isn&apos;t used here due to false negatives</span><br><span class=\"line\">\t// regarding Nodelist length in IE</span><br><span class=\"line\">\tvar length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class=\"line\">\t\ttype = toType(obj);</span><br><span class=\"line\">\t// 排除了obj为function和全局中有length变量的情况</span><br><span class=\"line\">\tif (isFunction(obj) || isWindow(obj)) &#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn type === &quot;array&quot; || length === 0 ||</span><br><span class=\"line\">\t\ttypeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。</p>\n<p>最后的三个判断分别是：</p>\n<ol>\n<li>如果obj的类型是数组，那么返回true</li>\n<li>如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。</li>\n<li>最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length&gt;0和length===”number”的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2>说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result1 = _.map(arr); // [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result2 = _.map(arr, &#123;name: &apos;Daisy&apos;&#125;) // [false, true]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.map = _.collect = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。</span><br><span class=\"line\">\t\titeratee = cb(iteratee, context);</span><br><span class=\"line\">\t\t// 如果不是类数组（是对象），则获取到keys</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p>我们来看看map函数中这个cb函数到底是什么来历？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.identity = function (value) &#123;</span><br><span class=\"line\">\treturn value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var cb = function (value, context, argCount) &#123;</span><br><span class=\"line\">    // 如果value不存在</span><br><span class=\"line\">\tif (value == null) return _.identity;</span><br><span class=\"line\">\t// 如果传入的是个函数</span><br><span class=\"line\">\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);</span><br><span class=\"line\">\t// 如果传入的是个对象</span><br><span class=\"line\">\tif (_.isObject(value)) return _.matcher(value);</span><br><span class=\"line\">\treturn _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>cb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。</p>\n<ol>\n<li>如果value不存在，那就对应上面的<em>.map(obj)的情况，map中的iteratee就是</em>.identity函数，他会将后面接收到的obj[currentKey]直接返回。</li>\n<li>如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的</li>\n<li>如果value是个对象，对应<em>.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用</em>.matcher函数</li>\n<li>这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：<a href=\"http://www.bootcss.com/p/underscore/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee函数</a><h3 id=\"matcher\"><a href=\"#matcher\" class=\"headerlink\" title=\"matcher\"></a>matcher</h3>那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.matcher = _.matches = function (attrs) &#123;</span><br><span class=\"line\">    // 将attrs和&#123;&#125;合并为一个对象（避免attrs为undefined）</span><br><span class=\"line\">\tattrs = _.extendOwn(&#123;&#125;, attrs);</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn _.isMatch(obj, attrs);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项</span><br><span class=\"line\">_.isMatch = function (object, attrs) &#123;</span><br><span class=\"line\">\tvar keys = _.keys(attrs), length = keys.length;</span><br><span class=\"line\">\t// 如果object和attr都是空，那么返回true，否则object为空时返回false</span><br><span class=\"line\">\tif (object == null) return !length;</span><br><span class=\"line\">\t// 这一步没懂是为了做什么？</span><br><span class=\"line\">\tvar obj = Object(object);</span><br><span class=\"line\">\tfor (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tvar key = keys[i];</span><br><span class=\"line\">\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>matcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。<br>这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。<br>所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。<br>这也就是为什么_.map([{name:’Kevin’}, {name: ‘Daisy’, age: 18}], {name: ‘Daisy’}); 会返回 [false, true]。</p>\n<h3 id=\"重写each\"><a href=\"#重写each\" class=\"headerlink\" title=\"重写each\"></a>重写each</h3><p>each和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each = _.forEach = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\titeratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn obj;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter、every、some、reject\"><a href=\"#filter、every、some、reject\" class=\"headerlink\" title=\"filter、every、some、reject\"></a>filter、every、some、reject</h2><p>这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之整体架构","date":"2018-03-16T13:08:56.000Z","_content":"最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。\n本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。\n今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。\n## 基础模块 ##\n首先，我们先来简单的看一下整体的代码：\n```\n// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)\n(function() {\n\n  var root = this;\n  \n  // 保存当前环境中已经存在的_变量（在noConflict中用到）\n  var previousUnderscore = root._;\n  \n  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  var Ctor = function(){};\n  // 内部实现省略\n  var _ = function(obj) {};\n  \n    // 这里是各种方法的实现（省略）\n    \n  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n  \n  // 版本号\n  _.VERSION = '1.8.3';\n  \n  // 用amd的形式导出\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this))\n```\n<!-- more -->\n## 全局对象 ##\n这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：\n```\nvar root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this;\n```\n这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。\n\n## void(0) ? undefined ##\n扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？\n关于void的解释，我们可以看这里：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\nvoid 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。\n其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[\"ygy\"]、Object.\\__undefined\\__、Object.\\__ygy\\__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined\n\n## noConflict ##\n也许有时候我们会碰到这样一种情况，\\_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。\n```\n_.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n};\nvar underscore = _.noConflict();\n```\n显而易见，这里正常保留原来的\\_变量，并返回了underscore这个方法（this就是\\_方法）\n## \\_ ##\n接下来讲到了本文的重点，关于\\_方法的分析，在看源码之前，我们先熟悉一下\\_的用法。\n这里总结的是我日常的用法，如果有遗漏，希望大家补充。\n一种是直接调用\\_上的方法，比如\\_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如\\_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(\"body\").click()则是调用jQuery原型上的方法。\n\n既然\\_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。\n\n这里来看源码：\n```\n// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。\nvar _ = function(obj) {\n    // 如果obj是_的实例（这种情况我真的没碰到过）\n    if (obj instanceof _) return obj;\n    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）\n    if (!(this instanceof _)) return new _(obj);\n    // 对应_([1,2,3])这种情况\n    this._wrapped = obj;\n  };\n```\n我先从源码上来解释，这里可以看出来\\_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。\n```\nvar Person = function() {\n    this.name = \"ygy\";\n    this.age = 22;\n}\nPerson.say = function() {\n    console.log(\"hello\")\n}\nPerson.prototype.say = function() {\n    console.log(\"world\")\n}\nvar ygy = new Person();\nPerson.say(); // hello\nygy.say(); // world\n```\n所以我们平时用的\\_.map就是Person.say()这种用法，而\\_([1, 2, 3]).map则是ygy.say()这种用法。\n\n在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？\n\n首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针\\__proto\\__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：\n```\nvar ygy = {};\nygy.__proto__ = Person.prototype \n// 或者var ygy = Object.create(Person.prototype)\nPerson.call(ygy);\n```\n这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析\\_方法的源码：\n\\_接收一个对象作为参数，如果这个对象是\\_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）\n    \n如果this不是\\_的实例，那么就会返回一个新的实例new \\_(obj)，这个该怎么理解？\n我们需要结合例子来看这句话，在\\_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。\n    \n那么既然this指向window，那么this肯定不是\\_的实例，所以this instanceof \\_必然会返回false，这样的话就会return一个new \\_([1, 2, 3])，所以\\_([1, 2, 3])就是new \\_([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：\n```\nvar obj = {}\nobj.__proto__ = _.prototype\n// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用\n_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]\n```\n这样我们就理解了为什么\\_([1, 2, 3]).map中map是原型上的方法，因为\\_([1, 2, 3])是一个实例。\n\n我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：\n```\nvar _ = function(obj) {\n    return new _.prototype.init(obj)\n}\n_.prototype = {\n    init: function(obj) {\n    \tthis.__wrapped = obj\n    \treturn this\n    },\n    name: function(name) {\n        console.log(name)\n    }\n}\n_.prototype.init.prototype = _.prototype;\nvar a = _([1, 2, 3])\na.name(\"ygy\"); // ygy\n```\nunderscore中所有方法都是在\\_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。\n如果本文有错误和不足之处，希望大家指出。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之整体架构.md","raw":"---\ntitle: underscore源码剖析之整体架构\ndate: 2018-03-16 21:08:56\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: [前端, underscore]\n---\n最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。\n本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。\n今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。\n## 基础模块 ##\n首先，我们先来简单的看一下整体的代码：\n```\n// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)\n(function() {\n\n  var root = this;\n  \n  // 保存当前环境中已经存在的_变量（在noConflict中用到）\n  var previousUnderscore = root._;\n  \n  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  var Ctor = function(){};\n  // 内部实现省略\n  var _ = function(obj) {};\n  \n    // 这里是各种方法的实现（省略）\n    \n  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n  \n  // 版本号\n  _.VERSION = '1.8.3';\n  \n  // 用amd的形式导出\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this))\n```\n<!-- more -->\n## 全局对象 ##\n这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：\n```\nvar root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this;\n```\n这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。\n\n## void(0) ? undefined ##\n扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？\n关于void的解释，我们可以看这里：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\nvoid 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。\n其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[\"ygy\"]、Object.\\__undefined\\__、Object.\\__ygy\\__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined\n\n## noConflict ##\n也许有时候我们会碰到这样一种情况，\\_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。\n```\n_.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n};\nvar underscore = _.noConflict();\n```\n显而易见，这里正常保留原来的\\_变量，并返回了underscore这个方法（this就是\\_方法）\n## \\_ ##\n接下来讲到了本文的重点，关于\\_方法的分析，在看源码之前，我们先熟悉一下\\_的用法。\n这里总结的是我日常的用法，如果有遗漏，希望大家补充。\n一种是直接调用\\_上的方法，比如\\_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如\\_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(\"body\").click()则是调用jQuery原型上的方法。\n\n既然\\_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。\n\n这里来看源码：\n```\n// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。\nvar _ = function(obj) {\n    // 如果obj是_的实例（这种情况我真的没碰到过）\n    if (obj instanceof _) return obj;\n    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）\n    if (!(this instanceof _)) return new _(obj);\n    // 对应_([1,2,3])这种情况\n    this._wrapped = obj;\n  };\n```\n我先从源码上来解释，这里可以看出来\\_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。\n```\nvar Person = function() {\n    this.name = \"ygy\";\n    this.age = 22;\n}\nPerson.say = function() {\n    console.log(\"hello\")\n}\nPerson.prototype.say = function() {\n    console.log(\"world\")\n}\nvar ygy = new Person();\nPerson.say(); // hello\nygy.say(); // world\n```\n所以我们平时用的\\_.map就是Person.say()这种用法，而\\_([1, 2, 3]).map则是ygy.say()这种用法。\n\n在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？\n\n首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针\\__proto\\__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：\n```\nvar ygy = {};\nygy.__proto__ = Person.prototype \n// 或者var ygy = Object.create(Person.prototype)\nPerson.call(ygy);\n```\n这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析\\_方法的源码：\n\\_接收一个对象作为参数，如果这个对象是\\_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）\n    \n如果this不是\\_的实例，那么就会返回一个新的实例new \\_(obj)，这个该怎么理解？\n我们需要结合例子来看这句话，在\\_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。\n    \n那么既然this指向window，那么this肯定不是\\_的实例，所以this instanceof \\_必然会返回false，这样的话就会return一个new \\_([1, 2, 3])，所以\\_([1, 2, 3])就是new \\_([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：\n```\nvar obj = {}\nobj.__proto__ = _.prototype\n// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用\n_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]\n```\n这样我们就理解了为什么\\_([1, 2, 3]).map中map是原型上的方法，因为\\_([1, 2, 3])是一个实例。\n\n我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：\n```\nvar _ = function(obj) {\n    return new _.prototype.init(obj)\n}\n_.prototype = {\n    init: function(obj) {\n    \tthis.__wrapped = obj\n    \treturn this\n    },\n    name: function(name) {\n        console.log(name)\n    }\n}\n_.prototype.init.prototype = _.prototype;\nvar a = _([1, 2, 3])\na.name(\"ygy\"); // ygy\n```\nunderscore中所有方法都是在\\_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。\n如果本文有错误和不足之处，希望大家指出。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之整体架构","published":1,"updated":"2019-04-07T05:53:12.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs670067drfdql55mfih","content":"<p>最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。<br>本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。<br>今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。</p>\n<h2 id=\"基础模块\"><a href=\"#基础模块\" class=\"headerlink\" title=\"基础模块\"></a>基础模块</h2><p>首先，我们先来简单的看一下整体的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var root = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 保存当前环境中已经存在的_变量（在noConflict中用到）</span><br><span class=\"line\">  var previousUnderscore = root._;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩</span><br><span class=\"line\">  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    push             = ArrayProto.push,</span><br><span class=\"line\">    slice            = ArrayProto.slice,</span><br><span class=\"line\">    toString         = ObjProto.toString,</span><br><span class=\"line\">    hasOwnProperty   = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    nativeIsArray      = Array.isArray,</span><br><span class=\"line\">    nativeKeys         = Object.keys,</span><br><span class=\"line\">    nativeBind         = FuncProto.bind,</span><br><span class=\"line\">    nativeCreate       = Object.create;</span><br><span class=\"line\"></span><br><span class=\"line\">  var Ctor = function()&#123;&#125;;</span><br><span class=\"line\">  // 内部实现省略</span><br><span class=\"line\">  var _ = function(obj) &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 这里是各种方法的实现（省略）</span><br><span class=\"line\">    </span><br><span class=\"line\">  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量</span><br><span class=\"line\">  if (typeof exports !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class=\"line\">      exports = module.exports = _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    exports._ = _;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    root._ = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 版本号</span><br><span class=\"line\">  _.VERSION = &apos;1.8.3&apos;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用amd的形式导出</span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(&apos;underscore&apos;, [], function() &#123;</span><br><span class=\"line\">      return _;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"全局对象\"><a href=\"#全局对象\" class=\"headerlink\" title=\"全局对象\"></a>全局对象</h2><p>这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var root = typeof self == &apos;object&apos; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &apos;object&apos; &amp;&amp; global.global === global &amp;&amp; global || this;</span><br></pre></td></tr></table></figure></p>\n<p>这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。</p>\n<h2 id=\"void-0-undefined\"><a href=\"#void-0-undefined\" class=\"headerlink\" title=\"void(0) ? undefined\"></a>void(0) ? undefined</h2><p>扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？<br>关于void的解释，我们可以看这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void\" target=\"_blank\" rel=\"noopener\">MDN</a><br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。<br>其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[“ygy”]、Object.__undefined__、Object.__ygy__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined</p>\n<h2 id=\"noConflict\"><a href=\"#noConflict\" class=\"headerlink\" title=\"noConflict\"></a>noConflict</h2><p>也许有时候我们会碰到这样一种情况，_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = function() &#123;</span><br><span class=\"line\">    root._ = previousUnderscore;</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var underscore = _.noConflict();</span><br></pre></td></tr></table></figure></p>\n<p>显而易见，这里正常保留原来的_变量，并返回了underscore这个方法（this就是_方法）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"_\"></a>_</h2><p>接下来讲到了本文的重点，关于_方法的分析，在看源码之前，我们先熟悉一下_的用法。<br>这里总结的是我日常的用法，如果有遗漏，希望大家补充。<br>一种是直接调用_上的方法，比如_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(“body”).click()则是调用jQuery原型上的方法。</p>\n<p>既然_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。</p>\n<p>这里来看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</span><br><span class=\"line\">// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。</span><br><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    // 如果obj是_的实例（这种情况我真的没碰到过）</span><br><span class=\"line\">    if (obj instanceof _) return obj;</span><br><span class=\"line\">    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）</span><br><span class=\"line\">    if (!(this instanceof _)) return new _(obj);</span><br><span class=\"line\">    // 对应_([1,2,3])这种情况</span><br><span class=\"line\">    this._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我先从源码上来解释，这里可以看出来_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function() &#123;</span><br><span class=\"line\">    this.name = &quot;ygy&quot;;</span><br><span class=\"line\">    this.age = 22;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;world&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ygy = new Person();</span><br><span class=\"line\">Person.say(); // hello</span><br><span class=\"line\">ygy.say(); // world</span><br></pre></td></tr></table></figure></p>\n<p>所以我们平时用的_.map就是Person.say()这种用法，而_([1, 2, 3]).map则是ygy.say()这种用法。</p>\n<p>在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？</p>\n<p>首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针__proto__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ygy = &#123;&#125;;</span><br><span class=\"line\">ygy.__proto__ = Person.prototype </span><br><span class=\"line\">// 或者var ygy = Object.create(Person.prototype)</span><br><span class=\"line\">Person.call(ygy);</span><br></pre></td></tr></table></figure></p>\n<p>这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析_方法的源码：<br>_接收一个对象作为参数，如果这个对象是_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）</p>\n<p>如果this不是_的实例，那么就会返回一个新的实例new _(obj)，这个该怎么理解？<br>我们需要结合例子来看这句话，在_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。</p>\n<p>那么既然this指向window，那么this肯定不是_的实例，所以this instanceof _必然会返回false，这样的话就会return一个new _([1, 2, 3])，所以_([1, 2, 3])就是new _([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = _.prototype</span><br><span class=\"line\">// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用</span><br><span class=\"line\">_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就理解了为什么_([1, 2, 3]).map中map是原型上的方法，因为_([1, 2, 3])是一个实例。</p>\n<p>我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    return new _.prototype.init(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype = &#123;</span><br><span class=\"line\">    init: function(obj) &#123;</span><br><span class=\"line\">    \tthis.__wrapped = obj</span><br><span class=\"line\">    \treturn this</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: function(name) &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype.init.prototype = _.prototype;</span><br><span class=\"line\">var a = _([1, 2, 3])</span><br><span class=\"line\">a.name(&quot;ygy&quot;); // ygy</span><br></pre></td></tr></table></figure></p>\n<p>underscore中所有方法都是在_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。<br>如果本文有错误和不足之处，希望大家指出。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。<br>本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。<br>今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。</p>\n<h2 id=\"基础模块\"><a href=\"#基础模块\" class=\"headerlink\" title=\"基础模块\"></a>基础模块</h2><p>首先，我们先来简单的看一下整体的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var root = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 保存当前环境中已经存在的_变量（在noConflict中用到）</span><br><span class=\"line\">  var previousUnderscore = root._;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩</span><br><span class=\"line\">  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    push             = ArrayProto.push,</span><br><span class=\"line\">    slice            = ArrayProto.slice,</span><br><span class=\"line\">    toString         = ObjProto.toString,</span><br><span class=\"line\">    hasOwnProperty   = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    nativeIsArray      = Array.isArray,</span><br><span class=\"line\">    nativeKeys         = Object.keys,</span><br><span class=\"line\">    nativeBind         = FuncProto.bind,</span><br><span class=\"line\">    nativeCreate       = Object.create;</span><br><span class=\"line\"></span><br><span class=\"line\">  var Ctor = function()&#123;&#125;;</span><br><span class=\"line\">  // 内部实现省略</span><br><span class=\"line\">  var _ = function(obj) &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 这里是各种方法的实现（省略）</span><br><span class=\"line\">    </span><br><span class=\"line\">  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量</span><br><span class=\"line\">  if (typeof exports !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class=\"line\">      exports = module.exports = _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    exports._ = _;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    root._ = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 版本号</span><br><span class=\"line\">  _.VERSION = &apos;1.8.3&apos;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用amd的形式导出</span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(&apos;underscore&apos;, [], function() &#123;</span><br><span class=\"line\">      return _;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"全局对象\"><a href=\"#全局对象\" class=\"headerlink\" title=\"全局对象\"></a>全局对象</h2><p>这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var root = typeof self == &apos;object&apos; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &apos;object&apos; &amp;&amp; global.global === global &amp;&amp; global || this;</span><br></pre></td></tr></table></figure></p>\n<p>这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。</p>\n<h2 id=\"void-0-undefined\"><a href=\"#void-0-undefined\" class=\"headerlink\" title=\"void(0) ? undefined\"></a>void(0) ? undefined</h2><p>扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？<br>关于void的解释，我们可以看这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void\" target=\"_blank\" rel=\"noopener\">MDN</a><br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。<br>其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[“ygy”]、Object.__undefined__、Object.__ygy__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined</p>\n<h2 id=\"noConflict\"><a href=\"#noConflict\" class=\"headerlink\" title=\"noConflict\"></a>noConflict</h2><p>也许有时候我们会碰到这样一种情况，_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = function() &#123;</span><br><span class=\"line\">    root._ = previousUnderscore;</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var underscore = _.noConflict();</span><br></pre></td></tr></table></figure></p>\n<p>显而易见，这里正常保留原来的_变量，并返回了underscore这个方法（this就是_方法）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"_\"></a>_</h2><p>接下来讲到了本文的重点，关于_方法的分析，在看源码之前，我们先熟悉一下_的用法。<br>这里总结的是我日常的用法，如果有遗漏，希望大家补充。<br>一种是直接调用_上的方法，比如_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(“body”).click()则是调用jQuery原型上的方法。</p>\n<p>既然_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。</p>\n<p>这里来看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</span><br><span class=\"line\">// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。</span><br><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    // 如果obj是_的实例（这种情况我真的没碰到过）</span><br><span class=\"line\">    if (obj instanceof _) return obj;</span><br><span class=\"line\">    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）</span><br><span class=\"line\">    if (!(this instanceof _)) return new _(obj);</span><br><span class=\"line\">    // 对应_([1,2,3])这种情况</span><br><span class=\"line\">    this._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我先从源码上来解释，这里可以看出来_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function() &#123;</span><br><span class=\"line\">    this.name = &quot;ygy&quot;;</span><br><span class=\"line\">    this.age = 22;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;world&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ygy = new Person();</span><br><span class=\"line\">Person.say(); // hello</span><br><span class=\"line\">ygy.say(); // world</span><br></pre></td></tr></table></figure></p>\n<p>所以我们平时用的_.map就是Person.say()这种用法，而_([1, 2, 3]).map则是ygy.say()这种用法。</p>\n<p>在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？</p>\n<p>首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针__proto__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ygy = &#123;&#125;;</span><br><span class=\"line\">ygy.__proto__ = Person.prototype </span><br><span class=\"line\">// 或者var ygy = Object.create(Person.prototype)</span><br><span class=\"line\">Person.call(ygy);</span><br></pre></td></tr></table></figure></p>\n<p>这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析_方法的源码：<br>_接收一个对象作为参数，如果这个对象是_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）</p>\n<p>如果this不是_的实例，那么就会返回一个新的实例new _(obj)，这个该怎么理解？<br>我们需要结合例子来看这句话，在_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。</p>\n<p>那么既然this指向window，那么this肯定不是_的实例，所以this instanceof _必然会返回false，这样的话就会return一个new _([1, 2, 3])，所以_([1, 2, 3])就是new _([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = _.prototype</span><br><span class=\"line\">// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用</span><br><span class=\"line\">_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就理解了为什么_([1, 2, 3]).map中map是原型上的方法，因为_([1, 2, 3])是一个实例。</p>\n<p>我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    return new _.prototype.init(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype = &#123;</span><br><span class=\"line\">    init: function(obj) &#123;</span><br><span class=\"line\">    \tthis.__wrapped = obj</span><br><span class=\"line\">    \treturn this</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: function(name) &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype.init.prototype = _.prototype;</span><br><span class=\"line\">var a = _([1, 2, 3])</span><br><span class=\"line\">a.name(&quot;ygy&quot;); // ygy</span><br></pre></td></tr></table></figure></p>\n<p>underscore中所有方法都是在_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。<br>如果本文有错误和不足之处，希望大家指出。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"世界变了样","date":"2019-03-27T09:51:51.000Z","top":1000,"_content":"## 2018.04.27\n每次听到许巍的《喜悦》我就会想家，想起小时候家里的后院，沐浴着春天的阳光，午睡醒来后还有些昏昏沉沉，揉揉眼，去后院享受微风拂过的感觉，想起已经老去的爷爷奶奶。\n过年的时候给爷爷奶奶买了智能机，教会他们怎么用，怎么开视频，每次看到他们我都很欣慰，可能家人是让我前进的唯一动力吧。\n\n## 2018.09.25\n下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁思绪万千。\n初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。\n那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。\n<!-- more -->\n\n## 2018.09.30\n十一长假的第一天，一个人茕茕地坐了一天高铁。\n与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。\n自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。\n可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。\n古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。\n\n## 2018.10.07\n在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。\n在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。\n也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。\n所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。\n\n## 2018.12.06\n秋叶还不忍从母亲的怀中挣脱，狂暴的冬风已经在拍打着行人被冻得通红的脸颊。\n今年的寒冬似乎比以往来的都要早。\n上个月跟同事去三亚团建，在那里休息了几天后，也算是彻底地放松了身心。消除压力后更是燃烧了工作和生活上的热情，可突兀而来的寒冬却把热情一下子浇灭了。\n最近和朋友沟通颇多，和星星讨论技术，我们可以从前端聊到后台，从数据结构聊到设计模式，我很庆幸有这么一个热爱技术的朋友，让我在编程学习路上不再寂寞。和艾老师聊人生，他很有自己的想法，也引导了我，让我下定决心去和他一起去做一些自己真正热爱的事情。和昭哥聊写作，博学的他给了我很多指导意见，在编程之外，我已经把写作作为第二爱好。\n今年上半年我一直在思考着一件事情，我该如何提高自制力？这件事困扰了我很多年，我一心想成为自律的人，却总是被各种事情诱惑。\n从三亚回来后，我尝试着做出了几个改变。我强迫自己每天提前半个小时起床来学习数据结构，坚持早起提高了我的自律；每天晚上回家先把琐事给处理完，然后关上qq和微信，开始学习react源码，现在我几乎已经看完了react源码；每天睡前半个小时看一些写作相关的书；每周末去公司健身房跑五千米。\n这些小小的习惯改变了我的生活规律，让我在不知不觉中充分管理了自己的时间，变成了一个更自律的人。\n可世事多艰，有些事情并不会按照自己理想中的那样发展。毕竟，除了生活之外，工作才是占据时间最多的部分。\n不得不说，毕业这一年多来，我对自己在工作上的表现不尽满意，这也让我思考了良久，不得不去反思自身的问题以及需要改进的地方。\n\n## 2018.12.07\n下班前还是找老大聊了一下最近的工作情况。\n我将自身的一些问题，和工作中的困难都说了一下，也表达了一下对现状的不满，老大表示没有注意到这些问题，也承诺以后会给我一些更完整的业务来做，希望这会是个好的开始。\n\n## 2018.12.21\n眨眼间就到了年底。\n去年年末定下的小目标，今年却连一半都未完成。\n也许是在舒适区呆了太久的缘故，最近焦虑感在不停增加。也可能是见过了太多优秀的人，总想追赶上他们的脚步，可是能力总是达不到预期，白白给自己增加了很多压力。\n今年最大的收获就是在技术网站和群聊认识了一些同样对技术充满热情的小伙伴，只有多和别人进行思维碰撞，才会知道自己有哪些不足。\n最近在工作上遇到的困扰，也和很多朋友进行了交流，挺感谢大家对我的理解和引导，我也认识到了自身的很多问题，和未来的一些改进方向，希望19年是更好的一年。\n\n## 2019.01.08\n有多久没有因为技术上的进步而开心了？刚学前端的时候，做一个小效果都会很欣喜，现在反而抛弃了初心。\n还记得17年年末总结的时候，我说自己陷入了技术瓶颈，始终突破不了，一直在初级前端阶段，怎么都突破不了，不知道该怎么学习，整个人很浮躁。\n18年上半年一直在逃避，逃避工作，逃避学习，浑浑噩噩地过了半年，不知道自己想做什么，不知道自己热爱什么，什么都不想做，丧失了对工作和生活的热情。\n一直到十月份，我才慢慢找回自己，我觉得不能这样堕落下去了，在舒适区呆久了会荒废掉，所以我咬咬牙做出了很多决定。\n还好在那几个月我进步了很多，看了不下五十篇相关文章，关于怎么写好业务代码，怎么写的更优雅，怎么解耦，怎么分层。也因此在技术网站认识了不少小伙伴和大佬们，我们一起讨论设计模式，讨论代码分层和解耦，讨论React等等，和志同道合的人一起交流是很开心的事情。\n和@xhxStar 、@江湖鹰莹莹嘤 交流是最简单粗暴的。\n我说我这边有个这样的功能，该怎么写的更合理？有什么更好的想法？莹莹就会和我说xxxxxx就好了。\n我说想做个vscode插件，功能大概是xxxx的，如果不做语法分析，该怎么做呢？星星就会告诉我方案A、方案B、方案C等等，甚至直接贴源码出来给我看，虽然到最后我也没有做成功。\n如果不是为了生存，我应该会做一个整天埋头研究技术和厨艺的人，遵从自己内心去做一些真正喜欢的事情，做自己真正喜欢的产品。\n毕竟如果连自己现在做的产品都不感兴趣，那怎么能做得好呢？这也是我迷茫的原因，以前我不觉得自己比其他人差，只是没合适的机会发挥自己的长处。\n现在我对自己的能力产生了极大的怀疑，也许我真的就是不如别人。我想了很多原因，我觉得是我自己做的不够好，\n19年的目标就是继续提高代码质量，努力去补习丢掉的计算机基础，去做一些第三方的开源插件，做一些自己真正喜欢的事情。\n\n## 2019.03.17\n年后来了我就提了离职，中间有一个月交接时间，我认为这一个月找工作也够了。但是任务还是没少，就一直在赶工，希望能早点儿做完，可以早点儿起身去找工作。直到上周才算是把所有的活做完，中间又请了两天假去面试，周四办完离职手续后就算是失业了。\n\n关于裸辞这件事，由于我比较任性，也自认为比较年轻，觉得呆的不开心就直接走吧，没必要继续委屈自己。我走的时候领导也再三劝了我很多次，让我找到后再走，甚至给了我一周时间让我再考虑一下，可我的想法从未动摇。\n\n为什么要裸辞呢？也许是在微信公众号和知乎看到了太多贩卖焦虑的文章，我总觉得中年危机很快就会来临，无时无刻不在焦虑。温水里面的青蛙一开始也不会觉得哪里不对，等到真正发现处于困境的时候就很难走出来了，而我不想当一只在舒适区里面被温水泡着的青蛙。\n\n我唯一后悔的就是没有在半年前就离开，那个时候我刚有离职的想法，却一直把问题归到自己身上，现在看还是一个是否合适的问题，如果公司不能给你带来你最想要的东西，那么就可以考虑离开了。毕竟即使是谈恋爱也会遇到不合适，更别说是面对一个自己以前没呆过的公司了，只有呆过才知道是不是合适。\n\n虽然我现在还在找工作，但再也不会因为工作太忙而没时间准备面试了，出去面试也不需要向领导撒谎请假，平时在家刷刷题，晒晒太阳，出去面面试，这周末还打算回学校看樱花，过的很舒服自在。\n\n虽然我是裸辞的，但毕竟风险太大。我觉得在裸辞之前，有几个问题需要考虑。\n\n1. 如果裸辞，自己有信心找一份薪资待遇至少和现在持平的公司吗？\n2. 如果两三个月内一直找不到工作，自己有足够的资金来度过这段时期吗？\n3. 自己是否有足够强大的心理，能够忍受失业期间的压力吗？\n\n虽然我也不能保证自己能够做到1、3两条，但我在毕业这一年多来，已经存了不少钱，这些钱也足够保证我在失业情况下在上海呆一年，这也是我为啥义无反顾的选择了裸辞。\n\n裸辞之后，我打算边休息边找工作，尽量找到一个更好的公司，这样自己就能多在那里呆上几年了。\n\n## 2019.03.25\n今天在陪小侄女玩的时候，看到93发了一张截图过来，原来是奇舞周刊在掘金上看到我的那篇文章，有意转载。\n于是我很愉快的接受了，并且得到了奇舞周刊赠送的一本《javascript测试驱动开发》，上面还有月影大大的签名。\n短短一天时间，我的公众号就涨了150个粉丝。奇舞周刊给了我极大鼓励，让我坚定了走技术变现之路的决心。\n\n## 2019.03.27\n打开很久不用的《微信读书》，又翻起了书架里面《悉达多》，可依然读不进去，原因还是无法集中注意力。\n心想，既然读不进去，何不尝试睡前听书呢？尝试了一下后发现效果非常好，听书可以让自己沉浸于书本的世界中，也能帮助睡眠。\n悉达多是一个婆罗门的儿子，出身高贵，所有人都爱他。但他觉得还不够，阿特曼到底在哪里？究竟什么是我？这些没有人能告诉他，即使是博学多识的父亲也不知道。\n于是他开始疑惑，开始渴望寻求更多的知识。他决定成为一个沙门，在获得父亲的理解后，他毅然踏上了修行之路。\n在修行的路上，他忍受了各种痛苦与煎熬，但这些依然不能动摇他的内心。\n和歌文达修行的几年里，他依然没有找到正确答案。在见识了佛之后，他告别歌文达，抛却了内心对世俗的厌恶，融入世俗之中，变成了自己最讨厌的样子之后幡然醒悟，从而得道。\n作为一个年轻人，我也会很迷茫，也变得越来越顽固，越来越冷漠，内心也会变得空虚，很想融入到别人的生活之中，不知道未来的路在何方，也不知道自己该去做什么。","source":"_posts/世界变了样.md","raw":"---\ntitle: 世界变了样\ndate: 2019-03-27 17:51:51\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\ntop: 1000\n---\n## 2018.04.27\n每次听到许巍的《喜悦》我就会想家，想起小时候家里的后院，沐浴着春天的阳光，午睡醒来后还有些昏昏沉沉，揉揉眼，去后院享受微风拂过的感觉，想起已经老去的爷爷奶奶。\n过年的时候给爷爷奶奶买了智能机，教会他们怎么用，怎么开视频，每次看到他们我都很欣慰，可能家人是让我前进的唯一动力吧。\n\n## 2018.09.25\n下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁思绪万千。\n初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。\n那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。\n<!-- more -->\n\n## 2018.09.30\n十一长假的第一天，一个人茕茕地坐了一天高铁。\n与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。\n自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。\n可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。\n古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。\n\n## 2018.10.07\n在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。\n在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。\n也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。\n所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。\n\n## 2018.12.06\n秋叶还不忍从母亲的怀中挣脱，狂暴的冬风已经在拍打着行人被冻得通红的脸颊。\n今年的寒冬似乎比以往来的都要早。\n上个月跟同事去三亚团建，在那里休息了几天后，也算是彻底地放松了身心。消除压力后更是燃烧了工作和生活上的热情，可突兀而来的寒冬却把热情一下子浇灭了。\n最近和朋友沟通颇多，和星星讨论技术，我们可以从前端聊到后台，从数据结构聊到设计模式，我很庆幸有这么一个热爱技术的朋友，让我在编程学习路上不再寂寞。和艾老师聊人生，他很有自己的想法，也引导了我，让我下定决心去和他一起去做一些自己真正热爱的事情。和昭哥聊写作，博学的他给了我很多指导意见，在编程之外，我已经把写作作为第二爱好。\n今年上半年我一直在思考着一件事情，我该如何提高自制力？这件事困扰了我很多年，我一心想成为自律的人，却总是被各种事情诱惑。\n从三亚回来后，我尝试着做出了几个改变。我强迫自己每天提前半个小时起床来学习数据结构，坚持早起提高了我的自律；每天晚上回家先把琐事给处理完，然后关上qq和微信，开始学习react源码，现在我几乎已经看完了react源码；每天睡前半个小时看一些写作相关的书；每周末去公司健身房跑五千米。\n这些小小的习惯改变了我的生活规律，让我在不知不觉中充分管理了自己的时间，变成了一个更自律的人。\n可世事多艰，有些事情并不会按照自己理想中的那样发展。毕竟，除了生活之外，工作才是占据时间最多的部分。\n不得不说，毕业这一年多来，我对自己在工作上的表现不尽满意，这也让我思考了良久，不得不去反思自身的问题以及需要改进的地方。\n\n## 2018.12.07\n下班前还是找老大聊了一下最近的工作情况。\n我将自身的一些问题，和工作中的困难都说了一下，也表达了一下对现状的不满，老大表示没有注意到这些问题，也承诺以后会给我一些更完整的业务来做，希望这会是个好的开始。\n\n## 2018.12.21\n眨眼间就到了年底。\n去年年末定下的小目标，今年却连一半都未完成。\n也许是在舒适区呆了太久的缘故，最近焦虑感在不停增加。也可能是见过了太多优秀的人，总想追赶上他们的脚步，可是能力总是达不到预期，白白给自己增加了很多压力。\n今年最大的收获就是在技术网站和群聊认识了一些同样对技术充满热情的小伙伴，只有多和别人进行思维碰撞，才会知道自己有哪些不足。\n最近在工作上遇到的困扰，也和很多朋友进行了交流，挺感谢大家对我的理解和引导，我也认识到了自身的很多问题，和未来的一些改进方向，希望19年是更好的一年。\n\n## 2019.01.08\n有多久没有因为技术上的进步而开心了？刚学前端的时候，做一个小效果都会很欣喜，现在反而抛弃了初心。\n还记得17年年末总结的时候，我说自己陷入了技术瓶颈，始终突破不了，一直在初级前端阶段，怎么都突破不了，不知道该怎么学习，整个人很浮躁。\n18年上半年一直在逃避，逃避工作，逃避学习，浑浑噩噩地过了半年，不知道自己想做什么，不知道自己热爱什么，什么都不想做，丧失了对工作和生活的热情。\n一直到十月份，我才慢慢找回自己，我觉得不能这样堕落下去了，在舒适区呆久了会荒废掉，所以我咬咬牙做出了很多决定。\n还好在那几个月我进步了很多，看了不下五十篇相关文章，关于怎么写好业务代码，怎么写的更优雅，怎么解耦，怎么分层。也因此在技术网站认识了不少小伙伴和大佬们，我们一起讨论设计模式，讨论代码分层和解耦，讨论React等等，和志同道合的人一起交流是很开心的事情。\n和@xhxStar 、@江湖鹰莹莹嘤 交流是最简单粗暴的。\n我说我这边有个这样的功能，该怎么写的更合理？有什么更好的想法？莹莹就会和我说xxxxxx就好了。\n我说想做个vscode插件，功能大概是xxxx的，如果不做语法分析，该怎么做呢？星星就会告诉我方案A、方案B、方案C等等，甚至直接贴源码出来给我看，虽然到最后我也没有做成功。\n如果不是为了生存，我应该会做一个整天埋头研究技术和厨艺的人，遵从自己内心去做一些真正喜欢的事情，做自己真正喜欢的产品。\n毕竟如果连自己现在做的产品都不感兴趣，那怎么能做得好呢？这也是我迷茫的原因，以前我不觉得自己比其他人差，只是没合适的机会发挥自己的长处。\n现在我对自己的能力产生了极大的怀疑，也许我真的就是不如别人。我想了很多原因，我觉得是我自己做的不够好，\n19年的目标就是继续提高代码质量，努力去补习丢掉的计算机基础，去做一些第三方的开源插件，做一些自己真正喜欢的事情。\n\n## 2019.03.17\n年后来了我就提了离职，中间有一个月交接时间，我认为这一个月找工作也够了。但是任务还是没少，就一直在赶工，希望能早点儿做完，可以早点儿起身去找工作。直到上周才算是把所有的活做完，中间又请了两天假去面试，周四办完离职手续后就算是失业了。\n\n关于裸辞这件事，由于我比较任性，也自认为比较年轻，觉得呆的不开心就直接走吧，没必要继续委屈自己。我走的时候领导也再三劝了我很多次，让我找到后再走，甚至给了我一周时间让我再考虑一下，可我的想法从未动摇。\n\n为什么要裸辞呢？也许是在微信公众号和知乎看到了太多贩卖焦虑的文章，我总觉得中年危机很快就会来临，无时无刻不在焦虑。温水里面的青蛙一开始也不会觉得哪里不对，等到真正发现处于困境的时候就很难走出来了，而我不想当一只在舒适区里面被温水泡着的青蛙。\n\n我唯一后悔的就是没有在半年前就离开，那个时候我刚有离职的想法，却一直把问题归到自己身上，现在看还是一个是否合适的问题，如果公司不能给你带来你最想要的东西，那么就可以考虑离开了。毕竟即使是谈恋爱也会遇到不合适，更别说是面对一个自己以前没呆过的公司了，只有呆过才知道是不是合适。\n\n虽然我现在还在找工作，但再也不会因为工作太忙而没时间准备面试了，出去面试也不需要向领导撒谎请假，平时在家刷刷题，晒晒太阳，出去面面试，这周末还打算回学校看樱花，过的很舒服自在。\n\n虽然我是裸辞的，但毕竟风险太大。我觉得在裸辞之前，有几个问题需要考虑。\n\n1. 如果裸辞，自己有信心找一份薪资待遇至少和现在持平的公司吗？\n2. 如果两三个月内一直找不到工作，自己有足够的资金来度过这段时期吗？\n3. 自己是否有足够强大的心理，能够忍受失业期间的压力吗？\n\n虽然我也不能保证自己能够做到1、3两条，但我在毕业这一年多来，已经存了不少钱，这些钱也足够保证我在失业情况下在上海呆一年，这也是我为啥义无反顾的选择了裸辞。\n\n裸辞之后，我打算边休息边找工作，尽量找到一个更好的公司，这样自己就能多在那里呆上几年了。\n\n## 2019.03.25\n今天在陪小侄女玩的时候，看到93发了一张截图过来，原来是奇舞周刊在掘金上看到我的那篇文章，有意转载。\n于是我很愉快的接受了，并且得到了奇舞周刊赠送的一本《javascript测试驱动开发》，上面还有月影大大的签名。\n短短一天时间，我的公众号就涨了150个粉丝。奇舞周刊给了我极大鼓励，让我坚定了走技术变现之路的决心。\n\n## 2019.03.27\n打开很久不用的《微信读书》，又翻起了书架里面《悉达多》，可依然读不进去，原因还是无法集中注意力。\n心想，既然读不进去，何不尝试睡前听书呢？尝试了一下后发现效果非常好，听书可以让自己沉浸于书本的世界中，也能帮助睡眠。\n悉达多是一个婆罗门的儿子，出身高贵，所有人都爱他。但他觉得还不够，阿特曼到底在哪里？究竟什么是我？这些没有人能告诉他，即使是博学多识的父亲也不知道。\n于是他开始疑惑，开始渴望寻求更多的知识。他决定成为一个沙门，在获得父亲的理解后，他毅然踏上了修行之路。\n在修行的路上，他忍受了各种痛苦与煎熬，但这些依然不能动摇他的内心。\n和歌文达修行的几年里，他依然没有找到正确答案。在见识了佛之后，他告别歌文达，抛却了内心对世俗的厌恶，融入世俗之中，变成了自己最讨厌的样子之后幡然醒悟，从而得道。\n作为一个年轻人，我也会很迷茫，也变得越来越顽固，越来越冷漠，内心也会变得空虚，很想融入到别人的生活之中，不知道未来的路在何方，也不知道自己该去做什么。","slug":"世界变了样","published":1,"updated":"2019-04-07T06:26:38.444Z","_id":"cju6jhs6c006adrfdl1clpqp2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"2018-04-27\"><a href=\"#2018-04-27\" class=\"headerlink\" title=\"2018.04.27\"></a>2018.04.27</h2><p>每次听到许巍的《喜悦》我就会想家，想起小时候家里的后院，沐浴着春天的阳光，午睡醒来后还有些昏昏沉沉，揉揉眼，去后院享受微风拂过的感觉，想起已经老去的爷爷奶奶。<br>过年的时候给爷爷奶奶买了智能机，教会他们怎么用，怎么开视频，每次看到他们我都很欣慰，可能家人是让我前进的唯一动力吧。</p>\n<h2 id=\"2018-09-25\"><a href=\"#2018-09-25\" class=\"headerlink\" title=\"2018.09.25\"></a>2018.09.25</h2><p>下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁思绪万千。<br>初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。<br>那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。<br><a id=\"more\"></a></p>\n<h2 id=\"2018-09-30\"><a href=\"#2018-09-30\" class=\"headerlink\" title=\"2018.09.30\"></a>2018.09.30</h2><p>十一长假的第一天，一个人茕茕地坐了一天高铁。<br>与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。<br>自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。<br>可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。<br>古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。</p>\n<h2 id=\"2018-10-07\"><a href=\"#2018-10-07\" class=\"headerlink\" title=\"2018.10.07\"></a>2018.10.07</h2><p>在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。<br>在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。<br>也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。<br>所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。</p>\n<h2 id=\"2018-12-06\"><a href=\"#2018-12-06\" class=\"headerlink\" title=\"2018.12.06\"></a>2018.12.06</h2><p>秋叶还不忍从母亲的怀中挣脱，狂暴的冬风已经在拍打着行人被冻得通红的脸颊。<br>今年的寒冬似乎比以往来的都要早。<br>上个月跟同事去三亚团建，在那里休息了几天后，也算是彻底地放松了身心。消除压力后更是燃烧了工作和生活上的热情，可突兀而来的寒冬却把热情一下子浇灭了。<br>最近和朋友沟通颇多，和星星讨论技术，我们可以从前端聊到后台，从数据结构聊到设计模式，我很庆幸有这么一个热爱技术的朋友，让我在编程学习路上不再寂寞。和艾老师聊人生，他很有自己的想法，也引导了我，让我下定决心去和他一起去做一些自己真正热爱的事情。和昭哥聊写作，博学的他给了我很多指导意见，在编程之外，我已经把写作作为第二爱好。<br>今年上半年我一直在思考着一件事情，我该如何提高自制力？这件事困扰了我很多年，我一心想成为自律的人，却总是被各种事情诱惑。<br>从三亚回来后，我尝试着做出了几个改变。我强迫自己每天提前半个小时起床来学习数据结构，坚持早起提高了我的自律；每天晚上回家先把琐事给处理完，然后关上qq和微信，开始学习react源码，现在我几乎已经看完了react源码；每天睡前半个小时看一些写作相关的书；每周末去公司健身房跑五千米。<br>这些小小的习惯改变了我的生活规律，让我在不知不觉中充分管理了自己的时间，变成了一个更自律的人。<br>可世事多艰，有些事情并不会按照自己理想中的那样发展。毕竟，除了生活之外，工作才是占据时间最多的部分。<br>不得不说，毕业这一年多来，我对自己在工作上的表现不尽满意，这也让我思考了良久，不得不去反思自身的问题以及需要改进的地方。</p>\n<h2 id=\"2018-12-07\"><a href=\"#2018-12-07\" class=\"headerlink\" title=\"2018.12.07\"></a>2018.12.07</h2><p>下班前还是找老大聊了一下最近的工作情况。<br>我将自身的一些问题，和工作中的困难都说了一下，也表达了一下对现状的不满，老大表示没有注意到这些问题，也承诺以后会给我一些更完整的业务来做，希望这会是个好的开始。</p>\n<h2 id=\"2018-12-21\"><a href=\"#2018-12-21\" class=\"headerlink\" title=\"2018.12.21\"></a>2018.12.21</h2><p>眨眼间就到了年底。<br>去年年末定下的小目标，今年却连一半都未完成。<br>也许是在舒适区呆了太久的缘故，最近焦虑感在不停增加。也可能是见过了太多优秀的人，总想追赶上他们的脚步，可是能力总是达不到预期，白白给自己增加了很多压力。<br>今年最大的收获就是在技术网站和群聊认识了一些同样对技术充满热情的小伙伴，只有多和别人进行思维碰撞，才会知道自己有哪些不足。<br>最近在工作上遇到的困扰，也和很多朋友进行了交流，挺感谢大家对我的理解和引导，我也认识到了自身的很多问题，和未来的一些改进方向，希望19年是更好的一年。</p>\n<h2 id=\"2019-01-08\"><a href=\"#2019-01-08\" class=\"headerlink\" title=\"2019.01.08\"></a>2019.01.08</h2><p>有多久没有因为技术上的进步而开心了？刚学前端的时候，做一个小效果都会很欣喜，现在反而抛弃了初心。<br>还记得17年年末总结的时候，我说自己陷入了技术瓶颈，始终突破不了，一直在初级前端阶段，怎么都突破不了，不知道该怎么学习，整个人很浮躁。<br>18年上半年一直在逃避，逃避工作，逃避学习，浑浑噩噩地过了半年，不知道自己想做什么，不知道自己热爱什么，什么都不想做，丧失了对工作和生活的热情。<br>一直到十月份，我才慢慢找回自己，我觉得不能这样堕落下去了，在舒适区呆久了会荒废掉，所以我咬咬牙做出了很多决定。<br>还好在那几个月我进步了很多，看了不下五十篇相关文章，关于怎么写好业务代码，怎么写的更优雅，怎么解耦，怎么分层。也因此在技术网站认识了不少小伙伴和大佬们，我们一起讨论设计模式，讨论代码分层和解耦，讨论React等等，和志同道合的人一起交流是很开心的事情。<br>和@xhxStar 、@江湖鹰莹莹嘤 交流是最简单粗暴的。<br>我说我这边有个这样的功能，该怎么写的更合理？有什么更好的想法？莹莹就会和我说xxxxxx就好了。<br>我说想做个vscode插件，功能大概是xxxx的，如果不做语法分析，该怎么做呢？星星就会告诉我方案A、方案B、方案C等等，甚至直接贴源码出来给我看，虽然到最后我也没有做成功。<br>如果不是为了生存，我应该会做一个整天埋头研究技术和厨艺的人，遵从自己内心去做一些真正喜欢的事情，做自己真正喜欢的产品。<br>毕竟如果连自己现在做的产品都不感兴趣，那怎么能做得好呢？这也是我迷茫的原因，以前我不觉得自己比其他人差，只是没合适的机会发挥自己的长处。<br>现在我对自己的能力产生了极大的怀疑，也许我真的就是不如别人。我想了很多原因，我觉得是我自己做的不够好，<br>19年的目标就是继续提高代码质量，努力去补习丢掉的计算机基础，去做一些第三方的开源插件，做一些自己真正喜欢的事情。</p>\n<h2 id=\"2019-03-17\"><a href=\"#2019-03-17\" class=\"headerlink\" title=\"2019.03.17\"></a>2019.03.17</h2><p>年后来了我就提了离职，中间有一个月交接时间，我认为这一个月找工作也够了。但是任务还是没少，就一直在赶工，希望能早点儿做完，可以早点儿起身去找工作。直到上周才算是把所有的活做完，中间又请了两天假去面试，周四办完离职手续后就算是失业了。</p>\n<p>关于裸辞这件事，由于我比较任性，也自认为比较年轻，觉得呆的不开心就直接走吧，没必要继续委屈自己。我走的时候领导也再三劝了我很多次，让我找到后再走，甚至给了我一周时间让我再考虑一下，可我的想法从未动摇。</p>\n<p>为什么要裸辞呢？也许是在微信公众号和知乎看到了太多贩卖焦虑的文章，我总觉得中年危机很快就会来临，无时无刻不在焦虑。温水里面的青蛙一开始也不会觉得哪里不对，等到真正发现处于困境的时候就很难走出来了，而我不想当一只在舒适区里面被温水泡着的青蛙。</p>\n<p>我唯一后悔的就是没有在半年前就离开，那个时候我刚有离职的想法，却一直把问题归到自己身上，现在看还是一个是否合适的问题，如果公司不能给你带来你最想要的东西，那么就可以考虑离开了。毕竟即使是谈恋爱也会遇到不合适，更别说是面对一个自己以前没呆过的公司了，只有呆过才知道是不是合适。</p>\n<p>虽然我现在还在找工作，但再也不会因为工作太忙而没时间准备面试了，出去面试也不需要向领导撒谎请假，平时在家刷刷题，晒晒太阳，出去面面试，这周末还打算回学校看樱花，过的很舒服自在。</p>\n<p>虽然我是裸辞的，但毕竟风险太大。我觉得在裸辞之前，有几个问题需要考虑。</p>\n<ol>\n<li>如果裸辞，自己有信心找一份薪资待遇至少和现在持平的公司吗？</li>\n<li>如果两三个月内一直找不到工作，自己有足够的资金来度过这段时期吗？</li>\n<li>自己是否有足够强大的心理，能够忍受失业期间的压力吗？</li>\n</ol>\n<p>虽然我也不能保证自己能够做到1、3两条，但我在毕业这一年多来，已经存了不少钱，这些钱也足够保证我在失业情况下在上海呆一年，这也是我为啥义无反顾的选择了裸辞。</p>\n<p>裸辞之后，我打算边休息边找工作，尽量找到一个更好的公司，这样自己就能多在那里呆上几年了。</p>\n<h2 id=\"2019-03-25\"><a href=\"#2019-03-25\" class=\"headerlink\" title=\"2019.03.25\"></a>2019.03.25</h2><p>今天在陪小侄女玩的时候，看到93发了一张截图过来，原来是奇舞周刊在掘金上看到我的那篇文章，有意转载。<br>于是我很愉快的接受了，并且得到了奇舞周刊赠送的一本《javascript测试驱动开发》，上面还有月影大大的签名。<br>短短一天时间，我的公众号就涨了150个粉丝。奇舞周刊给了我极大鼓励，让我坚定了走技术变现之路的决心。</p>\n<h2 id=\"2019-03-27\"><a href=\"#2019-03-27\" class=\"headerlink\" title=\"2019.03.27\"></a>2019.03.27</h2><p>打开很久不用的《微信读书》，又翻起了书架里面《悉达多》，可依然读不进去，原因还是无法集中注意力。<br>心想，既然读不进去，何不尝试睡前听书呢？尝试了一下后发现效果非常好，听书可以让自己沉浸于书本的世界中，也能帮助睡眠。<br>悉达多是一个婆罗门的儿子，出身高贵，所有人都爱他。但他觉得还不够，阿特曼到底在哪里？究竟什么是我？这些没有人能告诉他，即使是博学多识的父亲也不知道。<br>于是他开始疑惑，开始渴望寻求更多的知识。他决定成为一个沙门，在获得父亲的理解后，他毅然踏上了修行之路。<br>在修行的路上，他忍受了各种痛苦与煎熬，但这些依然不能动摇他的内心。<br>和歌文达修行的几年里，他依然没有找到正确答案。在见识了佛之后，他告别歌文达，抛却了内心对世俗的厌恶，融入世俗之中，变成了自己最讨厌的样子之后幡然醒悟，从而得道。<br>作为一个年轻人，我也会很迷茫，也变得越来越顽固，越来越冷漠，内心也会变得空虚，很想融入到别人的生活之中，不知道未来的路在何方，也不知道自己该去做什么。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"2018-04-27\"><a href=\"#2018-04-27\" class=\"headerlink\" title=\"2018.04.27\"></a>2018.04.27</h2><p>每次听到许巍的《喜悦》我就会想家，想起小时候家里的后院，沐浴着春天的阳光，午睡醒来后还有些昏昏沉沉，揉揉眼，去后院享受微风拂过的感觉，想起已经老去的爷爷奶奶。<br>过年的时候给爷爷奶奶买了智能机，教会他们怎么用，怎么开视频，每次看到他们我都很欣慰，可能家人是让我前进的唯一动力吧。</p>\n<h2 id=\"2018-09-25\"><a href=\"#2018-09-25\" class=\"headerlink\" title=\"2018.09.25\"></a>2018.09.25</h2><p>下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁思绪万千。<br>初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。<br>那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。<br>","more":"</p>\n<h2 id=\"2018-09-30\"><a href=\"#2018-09-30\" class=\"headerlink\" title=\"2018.09.30\"></a>2018.09.30</h2><p>十一长假的第一天，一个人茕茕地坐了一天高铁。<br>与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。<br>自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。<br>可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。<br>古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。</p>\n<h2 id=\"2018-10-07\"><a href=\"#2018-10-07\" class=\"headerlink\" title=\"2018.10.07\"></a>2018.10.07</h2><p>在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。<br>在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。<br>也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。<br>所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。</p>\n<h2 id=\"2018-12-06\"><a href=\"#2018-12-06\" class=\"headerlink\" title=\"2018.12.06\"></a>2018.12.06</h2><p>秋叶还不忍从母亲的怀中挣脱，狂暴的冬风已经在拍打着行人被冻得通红的脸颊。<br>今年的寒冬似乎比以往来的都要早。<br>上个月跟同事去三亚团建，在那里休息了几天后，也算是彻底地放松了身心。消除压力后更是燃烧了工作和生活上的热情，可突兀而来的寒冬却把热情一下子浇灭了。<br>最近和朋友沟通颇多，和星星讨论技术，我们可以从前端聊到后台，从数据结构聊到设计模式，我很庆幸有这么一个热爱技术的朋友，让我在编程学习路上不再寂寞。和艾老师聊人生，他很有自己的想法，也引导了我，让我下定决心去和他一起去做一些自己真正热爱的事情。和昭哥聊写作，博学的他给了我很多指导意见，在编程之外，我已经把写作作为第二爱好。<br>今年上半年我一直在思考着一件事情，我该如何提高自制力？这件事困扰了我很多年，我一心想成为自律的人，却总是被各种事情诱惑。<br>从三亚回来后，我尝试着做出了几个改变。我强迫自己每天提前半个小时起床来学习数据结构，坚持早起提高了我的自律；每天晚上回家先把琐事给处理完，然后关上qq和微信，开始学习react源码，现在我几乎已经看完了react源码；每天睡前半个小时看一些写作相关的书；每周末去公司健身房跑五千米。<br>这些小小的习惯改变了我的生活规律，让我在不知不觉中充分管理了自己的时间，变成了一个更自律的人。<br>可世事多艰，有些事情并不会按照自己理想中的那样发展。毕竟，除了生活之外，工作才是占据时间最多的部分。<br>不得不说，毕业这一年多来，我对自己在工作上的表现不尽满意，这也让我思考了良久，不得不去反思自身的问题以及需要改进的地方。</p>\n<h2 id=\"2018-12-07\"><a href=\"#2018-12-07\" class=\"headerlink\" title=\"2018.12.07\"></a>2018.12.07</h2><p>下班前还是找老大聊了一下最近的工作情况。<br>我将自身的一些问题，和工作中的困难都说了一下，也表达了一下对现状的不满，老大表示没有注意到这些问题，也承诺以后会给我一些更完整的业务来做，希望这会是个好的开始。</p>\n<h2 id=\"2018-12-21\"><a href=\"#2018-12-21\" class=\"headerlink\" title=\"2018.12.21\"></a>2018.12.21</h2><p>眨眼间就到了年底。<br>去年年末定下的小目标，今年却连一半都未完成。<br>也许是在舒适区呆了太久的缘故，最近焦虑感在不停增加。也可能是见过了太多优秀的人，总想追赶上他们的脚步，可是能力总是达不到预期，白白给自己增加了很多压力。<br>今年最大的收获就是在技术网站和群聊认识了一些同样对技术充满热情的小伙伴，只有多和别人进行思维碰撞，才会知道自己有哪些不足。<br>最近在工作上遇到的困扰，也和很多朋友进行了交流，挺感谢大家对我的理解和引导，我也认识到了自身的很多问题，和未来的一些改进方向，希望19年是更好的一年。</p>\n<h2 id=\"2019-01-08\"><a href=\"#2019-01-08\" class=\"headerlink\" title=\"2019.01.08\"></a>2019.01.08</h2><p>有多久没有因为技术上的进步而开心了？刚学前端的时候，做一个小效果都会很欣喜，现在反而抛弃了初心。<br>还记得17年年末总结的时候，我说自己陷入了技术瓶颈，始终突破不了，一直在初级前端阶段，怎么都突破不了，不知道该怎么学习，整个人很浮躁。<br>18年上半年一直在逃避，逃避工作，逃避学习，浑浑噩噩地过了半年，不知道自己想做什么，不知道自己热爱什么，什么都不想做，丧失了对工作和生活的热情。<br>一直到十月份，我才慢慢找回自己，我觉得不能这样堕落下去了，在舒适区呆久了会荒废掉，所以我咬咬牙做出了很多决定。<br>还好在那几个月我进步了很多，看了不下五十篇相关文章，关于怎么写好业务代码，怎么写的更优雅，怎么解耦，怎么分层。也因此在技术网站认识了不少小伙伴和大佬们，我们一起讨论设计模式，讨论代码分层和解耦，讨论React等等，和志同道合的人一起交流是很开心的事情。<br>和@xhxStar 、@江湖鹰莹莹嘤 交流是最简单粗暴的。<br>我说我这边有个这样的功能，该怎么写的更合理？有什么更好的想法？莹莹就会和我说xxxxxx就好了。<br>我说想做个vscode插件，功能大概是xxxx的，如果不做语法分析，该怎么做呢？星星就会告诉我方案A、方案B、方案C等等，甚至直接贴源码出来给我看，虽然到最后我也没有做成功。<br>如果不是为了生存，我应该会做一个整天埋头研究技术和厨艺的人，遵从自己内心去做一些真正喜欢的事情，做自己真正喜欢的产品。<br>毕竟如果连自己现在做的产品都不感兴趣，那怎么能做得好呢？这也是我迷茫的原因，以前我不觉得自己比其他人差，只是没合适的机会发挥自己的长处。<br>现在我对自己的能力产生了极大的怀疑，也许我真的就是不如别人。我想了很多原因，我觉得是我自己做的不够好，<br>19年的目标就是继续提高代码质量，努力去补习丢掉的计算机基础，去做一些第三方的开源插件，做一些自己真正喜欢的事情。</p>\n<h2 id=\"2019-03-17\"><a href=\"#2019-03-17\" class=\"headerlink\" title=\"2019.03.17\"></a>2019.03.17</h2><p>年后来了我就提了离职，中间有一个月交接时间，我认为这一个月找工作也够了。但是任务还是没少，就一直在赶工，希望能早点儿做完，可以早点儿起身去找工作。直到上周才算是把所有的活做完，中间又请了两天假去面试，周四办完离职手续后就算是失业了。</p>\n<p>关于裸辞这件事，由于我比较任性，也自认为比较年轻，觉得呆的不开心就直接走吧，没必要继续委屈自己。我走的时候领导也再三劝了我很多次，让我找到后再走，甚至给了我一周时间让我再考虑一下，可我的想法从未动摇。</p>\n<p>为什么要裸辞呢？也许是在微信公众号和知乎看到了太多贩卖焦虑的文章，我总觉得中年危机很快就会来临，无时无刻不在焦虑。温水里面的青蛙一开始也不会觉得哪里不对，等到真正发现处于困境的时候就很难走出来了，而我不想当一只在舒适区里面被温水泡着的青蛙。</p>\n<p>我唯一后悔的就是没有在半年前就离开，那个时候我刚有离职的想法，却一直把问题归到自己身上，现在看还是一个是否合适的问题，如果公司不能给你带来你最想要的东西，那么就可以考虑离开了。毕竟即使是谈恋爱也会遇到不合适，更别说是面对一个自己以前没呆过的公司了，只有呆过才知道是不是合适。</p>\n<p>虽然我现在还在找工作，但再也不会因为工作太忙而没时间准备面试了，出去面试也不需要向领导撒谎请假，平时在家刷刷题，晒晒太阳，出去面面试，这周末还打算回学校看樱花，过的很舒服自在。</p>\n<p>虽然我是裸辞的，但毕竟风险太大。我觉得在裸辞之前，有几个问题需要考虑。</p>\n<ol>\n<li>如果裸辞，自己有信心找一份薪资待遇至少和现在持平的公司吗？</li>\n<li>如果两三个月内一直找不到工作，自己有足够的资金来度过这段时期吗？</li>\n<li>自己是否有足够强大的心理，能够忍受失业期间的压力吗？</li>\n</ol>\n<p>虽然我也不能保证自己能够做到1、3两条，但我在毕业这一年多来，已经存了不少钱，这些钱也足够保证我在失业情况下在上海呆一年，这也是我为啥义无反顾的选择了裸辞。</p>\n<p>裸辞之后，我打算边休息边找工作，尽量找到一个更好的公司，这样自己就能多在那里呆上几年了。</p>\n<h2 id=\"2019-03-25\"><a href=\"#2019-03-25\" class=\"headerlink\" title=\"2019.03.25\"></a>2019.03.25</h2><p>今天在陪小侄女玩的时候，看到93发了一张截图过来，原来是奇舞周刊在掘金上看到我的那篇文章，有意转载。<br>于是我很愉快的接受了，并且得到了奇舞周刊赠送的一本《javascript测试驱动开发》，上面还有月影大大的签名。<br>短短一天时间，我的公众号就涨了150个粉丝。奇舞周刊给了我极大鼓励，让我坚定了走技术变现之路的决心。</p>\n<h2 id=\"2019-03-27\"><a href=\"#2019-03-27\" class=\"headerlink\" title=\"2019.03.27\"></a>2019.03.27</h2><p>打开很久不用的《微信读书》，又翻起了书架里面《悉达多》，可依然读不进去，原因还是无法集中注意力。<br>心想，既然读不进去，何不尝试睡前听书呢？尝试了一下后发现效果非常好，听书可以让自己沉浸于书本的世界中，也能帮助睡眠。<br>悉达多是一个婆罗门的儿子，出身高贵，所有人都爱他。但他觉得还不够，阿特曼到底在哪里？究竟什么是我？这些没有人能告诉他，即使是博学多识的父亲也不知道。<br>于是他开始疑惑，开始渴望寻求更多的知识。他决定成为一个沙门，在获得父亲的理解后，他毅然踏上了修行之路。<br>在修行的路上，他忍受了各种痛苦与煎熬，但这些依然不能动摇他的内心。<br>和歌文达修行的几年里，他依然没有找到正确答案。在见识了佛之后，他告别歌文达，抛却了内心对世俗的厌恶，融入世俗之中，变成了自己最讨厌的样子之后幡然醒悟，从而得道。<br>作为一个年轻人，我也会很迷茫，也变得越来越顽固，越来越冷漠，内心也会变得空虚，很想融入到别人的生活之中，不知道未来的路在何方，也不知道自己该去做什么。</p>"},{"title":"优化代码中的条件判断","date":"2019-01-20T10:14:58.000Z","_content":"在我们平时的开发中，if else是最常用的条件判断语句。在一些简单的场景下，if else用起来很爽，但是在稍微复杂一点儿的逻辑中，大量的if else就会让别人看的一脸蒙逼。\n如果别人要修改或者新增一个条件，那就要在这个上面继续增加条件。这样恶性循环下去，原本只有几个if else最后就有可能变成十几个，甚至几十个。\n别说不可能，我就见过有人在React组件里面用了大量的if else，可读性和可维护性非常差。（当然，这个不算if else的锅，主要是组件设计的问题）\n\n这篇文章主要参与自《代码大全2》，原书中使用vb和java实现，这里我是基于TypeScript的实现，对书中内容加入了一些自己的理解。\n<!--more-->\n## 从一个例子说起\n### 日历\n假如我们要做一个日历组件，那我们肯定要知道一年12个月中每个月都多少天，这个我们要怎么判断呢？\n最笨的方法当然是用if else啊。\n```javascript\nif (month === 1) {\n    return 31;\n}\nif (month === 2) {\n    return 28;\n}\n...\nif (month === 12) {\n    return 31;\n}\n```\n这样一下子就要写12次if，白白浪费了那么多时间，效率也很低。\n这个时候就会有人想到用switch/case来做这个了，但是switch/case也不会比if简化很多，依然要写12个case啊！！！甚至如果还要考虑闰年呢？岂不是更麻烦？\n我们不妨转换一下思维，每个月份对应一个数字，月份都是按顺序的，我们是否可以用一个数组来储存天数？到时候用下标来访问？\n```javascript\nconst month: number = new Date().getMonth(),\n    year: number = new Date().getFullYear(),\n    isLeapYear: boolean = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n\nconst monthDays: number[] = [31, isLeapYear ? 29 : 28, 31, ... , 31];\nconst days: number = monthDays[month];\n```\n## 概念\n看完上面的例子，相信你对表驱动法有了一定地认识。这里引用一下《代码大全》中的总结。\n> 表驱动法就是一种编程模式，从表里面查找信息而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。\n\n使用表驱动法前需要思考两个问题，一个是如何从表中查询，毕竟不是所有场景都像上面那么简单的，如果if判断的是不同的范围，这该怎么查？\n另一个则是你需要在表里面查询什么，是数据？还是动作？亦或是索引？\n基于这两个问题，这里将查询分为以下三种：\n\n 1. 直接访问\n 2. 索引访问\n 3. 阶梯访问\n\n## 直接访问表\n我们上面介绍的那个日历就是一个很好的直接访问表的例子，但是很多情况并没有这么简单。\n### 统计保险费率\n假设你在写一个保险费率的程序，这个费率会根据年龄、性别、婚姻状态等不同情况变化，如果你用逻辑控制结构（if、switch）来表示不同费率，那么会非常麻烦。\n```javascript\nif (gender === 'female') {\n    if (hasMarried) {\n        if (age < 18) {\n            //\n        } else if (age < 65) {\n            //\n        } else {\n            // \n        }\n    } else if (age < 18) {\n        //\n    } else if (age < 65) {\n        //\n    } else if {\n        //\n    }\n} else {\n    ...\n}\n```\n但是从上面的日历例子来看，这个年龄却是个范围，不是个固定的值，没法用数组或者对象来做映射，那么该怎么办呢？这里涉及到了上面说的问题，如何从表中查询？\n这个问题可以用阶梯访问表和直接访问表两种方法来解决，阶梯访问这个后续会介绍，这里只说直接访问表。\n有两种解决方法：\n1、复制信息从而能够直接使用键值\n    我们可以给1-17年龄范围的每个年龄都复制一份信息，然后直接用age来访问，同理对其他年龄段的也都一样。这种方法在于操作很简单，表的结构也很简单。但有个缺点就是会浪费空间，毕竟生成了很多冗余信息。\n2、转换键值\n我们不妨再换种思路，如果我们把年龄范围转换成键呢？这样就可以直接来访问了，唯一需要考虑的问题就是年龄如何转换为键值。\n我们当然可以继续用if else完成这种转换。前面已经说过，简单的if else是没什么问题的，表驱动只是为了优化复杂的逻辑判断，使其变得更灵活、易扩展。\n```javascript\nenum genders {\n    lessThan18 = '<18',\n    between18And56 = '18-65',\n    moreThan56 = '>65'\n}\nenum genders {\n    female = 0,\n    male = 1\n}\nenum marry = {\n    unmarried = 0,\n    married = 1\n}\nconst age2key = (age: number): string => {\n    if (age < 18) {\n        return genders.lessThan18\n    }\n    if (age < 65) {\n        return genders.between18And56\n    }\n    return genders.moreThan56\n}\nconst premiumRate: {\n    [genders: string]: {\n        [marry: string]: {\n            rate: number\n        }\n    }\n} = {\n    [genders.lessThan18]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.1\n            },\n            [marry.married]: {\n                rate: 0.2\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.3\n            },\n            [marry.married]: {\n                rate: 0.4\n            }\n        }\n    },\n    [genders.between18And56]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.5\n            },\n            [marry.married]: {\n                rate: 0.6\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.7\n            },\n            [marry.married]: {\n                rate: 0.8\n            }\n        }\n    },\n    [genders.moreThan56]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.5\n            },\n            [marry.married]: {\n                rate: 0.6\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.7\n            },\n            [marry.married]: {\n                rate: 0.8\n            }\n    }\n}\nconst getRate = (age: number, hasMarried: 0 | 1, gender: 0 | 1) => {\n     const ageKey: string = age2key(age);\n     return premiumRate[ageKey]\n        && premiumRate[ageKey][gender]\n        && premiumRate[ageKey][gender][hasMarried]\n}\n```\n\n## 索引访问表\n我们前面那个保险费率问题，在处理年龄范围的时候很头疼，这种范围往往不像上面那么容易得到key。\n我们当时提到了复制信息从而能够直接使用键值，但是这种方法浪费了很多空间，因为每个年龄都会保存着一份数据，但是如果我们只是保存索引，通过这个索引来查询数据呢？\n假设人刚出生是0岁，最多能活到100岁，那么我们需要创建一个长度为101的数组，数组的下标对应着人的年龄，这样在0-17的每个年龄我们都储存'<18'，在18-65储存'18-65', 在65以上储存'>65'。\n这样我们通过年龄就可以拿到对应的索引，再通过索引来查询对应的数据。\n看起来这种方法要比上面的直接访问表更复杂，但是在一些很难通过转换键值、数据占用空间很大的场景下可以试试通过索引来访问。\n```javascript\nconst ages: string[] = ['<18', '<18', '<18', '<18', ... , '18-65', '18-65', '18-65', '18-65', ... , '>65', '>65', '>65', '>65']\nconst ageKey: string = ages[age];\n```\n\n## 阶梯访问表\n同样是为了解决上面那个年龄范围的问题，阶梯访问没有索引访问直接，但是会更节省空间。\n为了使用阶梯方法，你需要把每个区间的上限写入一张表中，然后通过循环来检查年龄所在的区间，所以在使用阶梯访问的时候一定要注意检查区间的端点。\n```javascript\nconst ageRanges: number[] = [17, 65, 100],\n  keys: string[] = ['<18', '18-65', '>65'],\n  len: number = keys.length;\nconst getKey = (age: number): string => {\n  for (let i = 0; i < len; i++) {\n    console.log('i', i)\n    console.log('ageRanges', ageRanges[i])\n    if (age <= ageRanges[i]) {\n      return keys[i]\n    }\n  }\n  return keys[len-1];\n}\n```\n阶梯访问适合在索引访问无法适用的场景，比如如果是浮点数，就无法用索引访问创建一个数组来拿到索引。\n在数据量比较大的情况下，考虑用二分查找来代替顺序查找，。\n在大多数情况下，优先使用直接访问和索引访问，除非两者实在无法处理，才考虑使用阶梯访问。\n\n从这三种访问表来看，主要是为了解决如何从表中查询，在不同的场景应该使用合适的访问表。\n\n参考资料：\n\n 1. [代码大全（第2版）][1]\n\n\n  [1]: https://book.douban.com/subject/1477390/","source":"_posts/优化代码中的条件判断.md","raw":"---\ntitle: 优化代码中的条件判断\ndate: 2019-01-20 18:14:58\ntags:\n    - 前端\n    - javascript\ncategories:\n    - 前端\n---\n在我们平时的开发中，if else是最常用的条件判断语句。在一些简单的场景下，if else用起来很爽，但是在稍微复杂一点儿的逻辑中，大量的if else就会让别人看的一脸蒙逼。\n如果别人要修改或者新增一个条件，那就要在这个上面继续增加条件。这样恶性循环下去，原本只有几个if else最后就有可能变成十几个，甚至几十个。\n别说不可能，我就见过有人在React组件里面用了大量的if else，可读性和可维护性非常差。（当然，这个不算if else的锅，主要是组件设计的问题）\n\n这篇文章主要参与自《代码大全2》，原书中使用vb和java实现，这里我是基于TypeScript的实现，对书中内容加入了一些自己的理解。\n<!--more-->\n## 从一个例子说起\n### 日历\n假如我们要做一个日历组件，那我们肯定要知道一年12个月中每个月都多少天，这个我们要怎么判断呢？\n最笨的方法当然是用if else啊。\n```javascript\nif (month === 1) {\n    return 31;\n}\nif (month === 2) {\n    return 28;\n}\n...\nif (month === 12) {\n    return 31;\n}\n```\n这样一下子就要写12次if，白白浪费了那么多时间，效率也很低。\n这个时候就会有人想到用switch/case来做这个了，但是switch/case也不会比if简化很多，依然要写12个case啊！！！甚至如果还要考虑闰年呢？岂不是更麻烦？\n我们不妨转换一下思维，每个月份对应一个数字，月份都是按顺序的，我们是否可以用一个数组来储存天数？到时候用下标来访问？\n```javascript\nconst month: number = new Date().getMonth(),\n    year: number = new Date().getFullYear(),\n    isLeapYear: boolean = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n\nconst monthDays: number[] = [31, isLeapYear ? 29 : 28, 31, ... , 31];\nconst days: number = monthDays[month];\n```\n## 概念\n看完上面的例子，相信你对表驱动法有了一定地认识。这里引用一下《代码大全》中的总结。\n> 表驱动法就是一种编程模式，从表里面查找信息而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。\n\n使用表驱动法前需要思考两个问题，一个是如何从表中查询，毕竟不是所有场景都像上面那么简单的，如果if判断的是不同的范围，这该怎么查？\n另一个则是你需要在表里面查询什么，是数据？还是动作？亦或是索引？\n基于这两个问题，这里将查询分为以下三种：\n\n 1. 直接访问\n 2. 索引访问\n 3. 阶梯访问\n\n## 直接访问表\n我们上面介绍的那个日历就是一个很好的直接访问表的例子，但是很多情况并没有这么简单。\n### 统计保险费率\n假设你在写一个保险费率的程序，这个费率会根据年龄、性别、婚姻状态等不同情况变化，如果你用逻辑控制结构（if、switch）来表示不同费率，那么会非常麻烦。\n```javascript\nif (gender === 'female') {\n    if (hasMarried) {\n        if (age < 18) {\n            //\n        } else if (age < 65) {\n            //\n        } else {\n            // \n        }\n    } else if (age < 18) {\n        //\n    } else if (age < 65) {\n        //\n    } else if {\n        //\n    }\n} else {\n    ...\n}\n```\n但是从上面的日历例子来看，这个年龄却是个范围，不是个固定的值，没法用数组或者对象来做映射，那么该怎么办呢？这里涉及到了上面说的问题，如何从表中查询？\n这个问题可以用阶梯访问表和直接访问表两种方法来解决，阶梯访问这个后续会介绍，这里只说直接访问表。\n有两种解决方法：\n1、复制信息从而能够直接使用键值\n    我们可以给1-17年龄范围的每个年龄都复制一份信息，然后直接用age来访问，同理对其他年龄段的也都一样。这种方法在于操作很简单，表的结构也很简单。但有个缺点就是会浪费空间，毕竟生成了很多冗余信息。\n2、转换键值\n我们不妨再换种思路，如果我们把年龄范围转换成键呢？这样就可以直接来访问了，唯一需要考虑的问题就是年龄如何转换为键值。\n我们当然可以继续用if else完成这种转换。前面已经说过，简单的if else是没什么问题的，表驱动只是为了优化复杂的逻辑判断，使其变得更灵活、易扩展。\n```javascript\nenum genders {\n    lessThan18 = '<18',\n    between18And56 = '18-65',\n    moreThan56 = '>65'\n}\nenum genders {\n    female = 0,\n    male = 1\n}\nenum marry = {\n    unmarried = 0,\n    married = 1\n}\nconst age2key = (age: number): string => {\n    if (age < 18) {\n        return genders.lessThan18\n    }\n    if (age < 65) {\n        return genders.between18And56\n    }\n    return genders.moreThan56\n}\nconst premiumRate: {\n    [genders: string]: {\n        [marry: string]: {\n            rate: number\n        }\n    }\n} = {\n    [genders.lessThan18]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.1\n            },\n            [marry.married]: {\n                rate: 0.2\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.3\n            },\n            [marry.married]: {\n                rate: 0.4\n            }\n        }\n    },\n    [genders.between18And56]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.5\n            },\n            [marry.married]: {\n                rate: 0.6\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.7\n            },\n            [marry.married]: {\n                rate: 0.8\n            }\n        }\n    },\n    [genders.moreThan56]: {\n        [genders.female]: {\n            [marry.unmarried]: {\n                rate: 0.5\n            },\n            [marry.married]: {\n                rate: 0.6\n            }\n        },\n        [genders.male]: {\n            [marry.unmarried]: {\n                rate: 0.7\n            },\n            [marry.married]: {\n                rate: 0.8\n            }\n    }\n}\nconst getRate = (age: number, hasMarried: 0 | 1, gender: 0 | 1) => {\n     const ageKey: string = age2key(age);\n     return premiumRate[ageKey]\n        && premiumRate[ageKey][gender]\n        && premiumRate[ageKey][gender][hasMarried]\n}\n```\n\n## 索引访问表\n我们前面那个保险费率问题，在处理年龄范围的时候很头疼，这种范围往往不像上面那么容易得到key。\n我们当时提到了复制信息从而能够直接使用键值，但是这种方法浪费了很多空间，因为每个年龄都会保存着一份数据，但是如果我们只是保存索引，通过这个索引来查询数据呢？\n假设人刚出生是0岁，最多能活到100岁，那么我们需要创建一个长度为101的数组，数组的下标对应着人的年龄，这样在0-17的每个年龄我们都储存'<18'，在18-65储存'18-65', 在65以上储存'>65'。\n这样我们通过年龄就可以拿到对应的索引，再通过索引来查询对应的数据。\n看起来这种方法要比上面的直接访问表更复杂，但是在一些很难通过转换键值、数据占用空间很大的场景下可以试试通过索引来访问。\n```javascript\nconst ages: string[] = ['<18', '<18', '<18', '<18', ... , '18-65', '18-65', '18-65', '18-65', ... , '>65', '>65', '>65', '>65']\nconst ageKey: string = ages[age];\n```\n\n## 阶梯访问表\n同样是为了解决上面那个年龄范围的问题，阶梯访问没有索引访问直接，但是会更节省空间。\n为了使用阶梯方法，你需要把每个区间的上限写入一张表中，然后通过循环来检查年龄所在的区间，所以在使用阶梯访问的时候一定要注意检查区间的端点。\n```javascript\nconst ageRanges: number[] = [17, 65, 100],\n  keys: string[] = ['<18', '18-65', '>65'],\n  len: number = keys.length;\nconst getKey = (age: number): string => {\n  for (let i = 0; i < len; i++) {\n    console.log('i', i)\n    console.log('ageRanges', ageRanges[i])\n    if (age <= ageRanges[i]) {\n      return keys[i]\n    }\n  }\n  return keys[len-1];\n}\n```\n阶梯访问适合在索引访问无法适用的场景，比如如果是浮点数，就无法用索引访问创建一个数组来拿到索引。\n在数据量比较大的情况下，考虑用二分查找来代替顺序查找，。\n在大多数情况下，优先使用直接访问和索引访问，除非两者实在无法处理，才考虑使用阶梯访问。\n\n从这三种访问表来看，主要是为了解决如何从表中查询，在不同的场景应该使用合适的访问表。\n\n参考资料：\n\n 1. [代码大全（第2版）][1]\n\n\n  [1]: https://book.douban.com/subject/1477390/","slug":"优化代码中的条件判断","published":1,"updated":"2019-04-07T05:56:13.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs6j006ddrfdk9cf1hbd","content":"<p>在我们平时的开发中，if else是最常用的条件判断语句。在一些简单的场景下，if else用起来很爽，但是在稍微复杂一点儿的逻辑中，大量的if else就会让别人看的一脸蒙逼。<br>如果别人要修改或者新增一个条件，那就要在这个上面继续增加条件。这样恶性循环下去，原本只有几个if else最后就有可能变成十几个，甚至几十个。<br>别说不可能，我就见过有人在React组件里面用了大量的if else，可读性和可维护性非常差。（当然，这个不算if else的锅，主要是组件设计的问题）</p>\n<p>这篇文章主要参与自《代码大全2》，原书中使用vb和java实现，这里我是基于TypeScript的实现，对书中内容加入了一些自己的理解。<br><a id=\"more\"></a></p>\n<h2 id=\"从一个例子说起\"><a href=\"#从一个例子说起\" class=\"headerlink\" title=\"从一个例子说起\"></a>从一个例子说起</h2><h3 id=\"日历\"><a href=\"#日历\" class=\"headerlink\" title=\"日历\"></a>日历</h3><p>假如我们要做一个日历组件，那我们肯定要知道一年12个月中每个月都多少天，这个我们要怎么判断呢？<br>最笨的方法当然是用if else啊。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">12</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样一下子就要写12次if，白白浪费了那么多时间，效率也很低。<br>这个时候就会有人想到用switch/case来做这个了，但是switch/case也不会比if简化很多，依然要写12个case啊！！！甚至如果还要考虑闰年呢？岂不是更麻烦？<br>我们不妨转换一下思维，每个月份对应一个数字，月份都是按顺序的，我们是否可以用一个数组来储存天数？到时候用下标来访问？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> month: number = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMonth(),</span><br><span class=\"line\">    year: number = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear(),</span><br><span class=\"line\">    isLeapYear: boolean = year % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> != <span class=\"number\">0</span> || year % <span class=\"number\">400</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> monthDays: number[] = [<span class=\"number\">31</span>, isLeapYear ? <span class=\"number\">29</span> : <span class=\"number\">28</span>, <span class=\"number\">31</span>, ... , <span class=\"number\">31</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> days: number = monthDays[month];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>看完上面的例子，相信你对表驱动法有了一定地认识。这里引用一下《代码大全》中的总结。</p>\n<blockquote>\n<p>表驱动法就是一种编程模式，从表里面查找信息而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。</p>\n</blockquote>\n<p>使用表驱动法前需要思考两个问题，一个是如何从表中查询，毕竟不是所有场景都像上面那么简单的，如果if判断的是不同的范围，这该怎么查？<br>另一个则是你需要在表里面查询什么，是数据？还是动作？亦或是索引？<br>基于这两个问题，这里将查询分为以下三种：</p>\n<ol>\n<li>直接访问</li>\n<li>索引访问</li>\n<li>阶梯访问</li>\n</ol>\n<h2 id=\"直接访问表\"><a href=\"#直接访问表\" class=\"headerlink\" title=\"直接访问表\"></a>直接访问表</h2><p>我们上面介绍的那个日历就是一个很好的直接访问表的例子，但是很多情况并没有这么简单。</p>\n<h3 id=\"统计保险费率\"><a href=\"#统计保险费率\" class=\"headerlink\" title=\"统计保险费率\"></a>统计保险费率</h3><p>假设你在写一个保险费率的程序，这个费率会根据年龄、性别、婚姻状态等不同情况变化，如果你用逻辑控制结构（if、switch）来表示不同费率，那么会非常麻烦。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (gender === <span class=\"string\">'female'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasMarried) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是从上面的日历例子来看，这个年龄却是个范围，不是个固定的值，没法用数组或者对象来做映射，那么该怎么办呢？这里涉及到了上面说的问题，如何从表中查询？<br>这个问题可以用阶梯访问表和直接访问表两种方法来解决，阶梯访问这个后续会介绍，这里只说直接访问表。<br>有两种解决方法：<br>1、复制信息从而能够直接使用键值<br>    我们可以给1-17年龄范围的每个年龄都复制一份信息，然后直接用age来访问，同理对其他年龄段的也都一样。这种方法在于操作很简单，表的结构也很简单。但有个缺点就是会浪费空间，毕竟生成了很多冗余信息。<br>2、转换键值<br>我们不妨再换种思路，如果我们把年龄范围转换成键呢？这样就可以直接来访问了，唯一需要考虑的问题就是年龄如何转换为键值。<br>我们当然可以继续用if else完成这种转换。前面已经说过，简单的if else是没什么问题的，表驱动只是为了优化复杂的逻辑判断，使其变得更灵活、易扩展。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum genders &#123;</span><br><span class=\"line\">    lessThan18 = <span class=\"string\">'&lt;18'</span>,</span><br><span class=\"line\">    between18And56 = <span class=\"string\">'18-65'</span>,</span><br><span class=\"line\">    moreThan56 = <span class=\"string\">'&gt;65'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum genders &#123;</span><br><span class=\"line\">    female = <span class=\"number\">0</span>,</span><br><span class=\"line\">    male = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum marry = &#123;</span><br><span class=\"line\">    unmarried = <span class=\"number\">0</span>,</span><br><span class=\"line\">    married = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age2key = (age: number): <span class=\"function\"><span class=\"params\">string</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> genders.lessThan18</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> genders.between18And56</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genders.moreThan56</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> premiumRate: &#123;</span><br><span class=\"line\">    [genders: string]: &#123;</span><br><span class=\"line\">        [marry: string]: &#123;</span><br><span class=\"line\">            rate: number</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; = &#123;</span><br><span class=\"line\">    [genders.lessThan18]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.3</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.4</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [genders.between18And56]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.5</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.6</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.7</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.8</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [genders.moreThan56]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.5</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.6</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.7</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.8</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getRate = <span class=\"function\">(<span class=\"params\">age: number, hasMarried: <span class=\"number\">0</span> | <span class=\"number\">1</span>, gender: <span class=\"number\">0</span> | <span class=\"number\">1</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ageKey: string = age2key(age);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> premiumRate[ageKey]</span><br><span class=\"line\">        &amp;&amp; premiumRate[ageKey][gender]</span><br><span class=\"line\">        &amp;&amp; premiumRate[ageKey][gender][hasMarried]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"索引访问表\"><a href=\"#索引访问表\" class=\"headerlink\" title=\"索引访问表\"></a>索引访问表</h2><p>我们前面那个保险费率问题，在处理年龄范围的时候很头疼，这种范围往往不像上面那么容易得到key。<br>我们当时提到了复制信息从而能够直接使用键值，但是这种方法浪费了很多空间，因为每个年龄都会保存着一份数据，但是如果我们只是保存索引，通过这个索引来查询数据呢？<br>假设人刚出生是0岁，最多能活到100岁，那么我们需要创建一个长度为101的数组，数组的下标对应着人的年龄，这样在0-17的每个年龄我们都储存’&lt;18’，在18-65储存’18-65’, 在65以上储存’&gt;65’。<br>这样我们通过年龄就可以拿到对应的索引，再通过索引来查询对应的数据。<br>看起来这种方法要比上面的直接访问表更复杂，但是在一些很难通过转换键值、数据占用空间很大的场景下可以试试通过索引来访问。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ages: string[] = [<span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, ... , <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, ... , <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> ageKey: string = ages[age];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"阶梯访问表\"><a href=\"#阶梯访问表\" class=\"headerlink\" title=\"阶梯访问表\"></a>阶梯访问表</h2><p>同样是为了解决上面那个年龄范围的问题，阶梯访问没有索引访问直接，但是会更节省空间。<br>为了使用阶梯方法，你需要把每个区间的上限写入一张表中，然后通过循环来检查年龄所在的区间，所以在使用阶梯访问的时候一定要注意检查区间的端点。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ageRanges: number[] = [<span class=\"number\">17</span>, <span class=\"number\">65</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  keys: string[] = [<span class=\"string\">'&lt;18'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'&gt;65'</span>],</span><br><span class=\"line\">  len: number = keys.length;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getKey = (age: number): <span class=\"function\"><span class=\"params\">string</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i'</span>, i)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ageRanges'</span>, ageRanges[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt;= ageRanges[i]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> keys[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys[len<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>阶梯访问适合在索引访问无法适用的场景，比如如果是浮点数，就无法用索引访问创建一个数组来拿到索引。<br>在数据量比较大的情况下，考虑用二分查找来代替顺序查找，。<br>在大多数情况下，优先使用直接访问和索引访问，除非两者实在无法处理，才考虑使用阶梯访问。</p>\n<p>从这三种访问表来看，主要是为了解决如何从表中查询，在不同的场景应该使用合适的访问表。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/1477390/\" target=\"_blank\" rel=\"noopener\">代码大全（第2版）</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在我们平时的开发中，if else是最常用的条件判断语句。在一些简单的场景下，if else用起来很爽，但是在稍微复杂一点儿的逻辑中，大量的if else就会让别人看的一脸蒙逼。<br>如果别人要修改或者新增一个条件，那就要在这个上面继续增加条件。这样恶性循环下去，原本只有几个if else最后就有可能变成十几个，甚至几十个。<br>别说不可能，我就见过有人在React组件里面用了大量的if else，可读性和可维护性非常差。（当然，这个不算if else的锅，主要是组件设计的问题）</p>\n<p>这篇文章主要参与自《代码大全2》，原书中使用vb和java实现，这里我是基于TypeScript的实现，对书中内容加入了一些自己的理解。<br>","more":"</p>\n<h2 id=\"从一个例子说起\"><a href=\"#从一个例子说起\" class=\"headerlink\" title=\"从一个例子说起\"></a>从一个例子说起</h2><h3 id=\"日历\"><a href=\"#日历\" class=\"headerlink\" title=\"日历\"></a>日历</h3><p>假如我们要做一个日历组件，那我们肯定要知道一年12个月中每个月都多少天，这个我们要怎么判断呢？<br>最笨的方法当然是用if else啊。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (month === <span class=\"number\">12</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">31</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样一下子就要写12次if，白白浪费了那么多时间，效率也很低。<br>这个时候就会有人想到用switch/case来做这个了，但是switch/case也不会比if简化很多，依然要写12个case啊！！！甚至如果还要考虑闰年呢？岂不是更麻烦？<br>我们不妨转换一下思维，每个月份对应一个数字，月份都是按顺序的，我们是否可以用一个数组来储存天数？到时候用下标来访问？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> month: number = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMonth(),</span><br><span class=\"line\">    year: number = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear(),</span><br><span class=\"line\">    isLeapYear: boolean = year % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> != <span class=\"number\">0</span> || year % <span class=\"number\">400</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> monthDays: number[] = [<span class=\"number\">31</span>, isLeapYear ? <span class=\"number\">29</span> : <span class=\"number\">28</span>, <span class=\"number\">31</span>, ... , <span class=\"number\">31</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> days: number = monthDays[month];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>看完上面的例子，相信你对表驱动法有了一定地认识。这里引用一下《代码大全》中的总结。</p>\n<blockquote>\n<p>表驱动法就是一种编程模式，从表里面查找信息而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。</p>\n</blockquote>\n<p>使用表驱动法前需要思考两个问题，一个是如何从表中查询，毕竟不是所有场景都像上面那么简单的，如果if判断的是不同的范围，这该怎么查？<br>另一个则是你需要在表里面查询什么，是数据？还是动作？亦或是索引？<br>基于这两个问题，这里将查询分为以下三种：</p>\n<ol>\n<li>直接访问</li>\n<li>索引访问</li>\n<li>阶梯访问</li>\n</ol>\n<h2 id=\"直接访问表\"><a href=\"#直接访问表\" class=\"headerlink\" title=\"直接访问表\"></a>直接访问表</h2><p>我们上面介绍的那个日历就是一个很好的直接访问表的例子，但是很多情况并没有这么简单。</p>\n<h3 id=\"统计保险费率\"><a href=\"#统计保险费率\" class=\"headerlink\" title=\"统计保险费率\"></a>统计保险费率</h3><p>假设你在写一个保险费率的程序，这个费率会根据年龄、性别、婚姻状态等不同情况变化，如果你用逻辑控制结构（if、switch）来表示不同费率，那么会非常麻烦。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (gender === <span class=\"string\">'female'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasMarried) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是从上面的日历例子来看，这个年龄却是个范围，不是个固定的值，没法用数组或者对象来做映射，那么该怎么办呢？这里涉及到了上面说的问题，如何从表中查询？<br>这个问题可以用阶梯访问表和直接访问表两种方法来解决，阶梯访问这个后续会介绍，这里只说直接访问表。<br>有两种解决方法：<br>1、复制信息从而能够直接使用键值<br>    我们可以给1-17年龄范围的每个年龄都复制一份信息，然后直接用age来访问，同理对其他年龄段的也都一样。这种方法在于操作很简单，表的结构也很简单。但有个缺点就是会浪费空间，毕竟生成了很多冗余信息。<br>2、转换键值<br>我们不妨再换种思路，如果我们把年龄范围转换成键呢？这样就可以直接来访问了，唯一需要考虑的问题就是年龄如何转换为键值。<br>我们当然可以继续用if else完成这种转换。前面已经说过，简单的if else是没什么问题的，表驱动只是为了优化复杂的逻辑判断，使其变得更灵活、易扩展。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum genders &#123;</span><br><span class=\"line\">    lessThan18 = <span class=\"string\">'&lt;18'</span>,</span><br><span class=\"line\">    between18And56 = <span class=\"string\">'18-65'</span>,</span><br><span class=\"line\">    moreThan56 = <span class=\"string\">'&gt;65'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum genders &#123;</span><br><span class=\"line\">    female = <span class=\"number\">0</span>,</span><br><span class=\"line\">    male = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum marry = &#123;</span><br><span class=\"line\">    unmarried = <span class=\"number\">0</span>,</span><br><span class=\"line\">    married = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age2key = (age: number): <span class=\"function\"><span class=\"params\">string</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> genders.lessThan18</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">65</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> genders.between18And56</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genders.moreThan56</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> premiumRate: &#123;</span><br><span class=\"line\">    [genders: string]: &#123;</span><br><span class=\"line\">        [marry: string]: &#123;</span><br><span class=\"line\">            rate: number</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; = &#123;</span><br><span class=\"line\">    [genders.lessThan18]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.3</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.4</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [genders.between18And56]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.5</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.6</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.7</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.8</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [genders.moreThan56]: &#123;</span><br><span class=\"line\">        [genders.female]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.5</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.6</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        [genders.male]: &#123;</span><br><span class=\"line\">            [marry.unmarried]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.7</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            [marry.married]: &#123;</span><br><span class=\"line\">                rate: <span class=\"number\">0.8</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getRate = <span class=\"function\">(<span class=\"params\">age: number, hasMarried: <span class=\"number\">0</span> | <span class=\"number\">1</span>, gender: <span class=\"number\">0</span> | <span class=\"number\">1</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> ageKey: string = age2key(age);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> premiumRate[ageKey]</span><br><span class=\"line\">        &amp;&amp; premiumRate[ageKey][gender]</span><br><span class=\"line\">        &amp;&amp; premiumRate[ageKey][gender][hasMarried]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"索引访问表\"><a href=\"#索引访问表\" class=\"headerlink\" title=\"索引访问表\"></a>索引访问表</h2><p>我们前面那个保险费率问题，在处理年龄范围的时候很头疼，这种范围往往不像上面那么容易得到key。<br>我们当时提到了复制信息从而能够直接使用键值，但是这种方法浪费了很多空间，因为每个年龄都会保存着一份数据，但是如果我们只是保存索引，通过这个索引来查询数据呢？<br>假设人刚出生是0岁，最多能活到100岁，那么我们需要创建一个长度为101的数组，数组的下标对应着人的年龄，这样在0-17的每个年龄我们都储存’&lt;18’，在18-65储存’18-65’, 在65以上储存’&gt;65’。<br>这样我们通过年龄就可以拿到对应的索引，再通过索引来查询对应的数据。<br>看起来这种方法要比上面的直接访问表更复杂，但是在一些很难通过转换键值、数据占用空间很大的场景下可以试试通过索引来访问。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ages: string[] = [<span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, <span class=\"string\">'&lt;18'</span>, ... , <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'18-65'</span>, ... , <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>, <span class=\"string\">'&gt;65'</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> ageKey: string = ages[age];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"阶梯访问表\"><a href=\"#阶梯访问表\" class=\"headerlink\" title=\"阶梯访问表\"></a>阶梯访问表</h2><p>同样是为了解决上面那个年龄范围的问题，阶梯访问没有索引访问直接，但是会更节省空间。<br>为了使用阶梯方法，你需要把每个区间的上限写入一张表中，然后通过循环来检查年龄所在的区间，所以在使用阶梯访问的时候一定要注意检查区间的端点。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ageRanges: number[] = [<span class=\"number\">17</span>, <span class=\"number\">65</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  keys: string[] = [<span class=\"string\">'&lt;18'</span>, <span class=\"string\">'18-65'</span>, <span class=\"string\">'&gt;65'</span>],</span><br><span class=\"line\">  len: number = keys.length;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getKey = (age: number): <span class=\"function\"><span class=\"params\">string</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i'</span>, i)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ageRanges'</span>, ageRanges[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt;= ageRanges[i]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> keys[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys[len<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>阶梯访问适合在索引访问无法适用的场景，比如如果是浮点数，就无法用索引访问创建一个数组来拿到索引。<br>在数据量比较大的情况下，考虑用二分查找来代替顺序查找，。<br>在大多数情况下，优先使用直接访问和索引访问，除非两者实在无法处理，才考虑使用阶梯访问。</p>\n<p>从这三种访问表来看，主要是为了解决如何从表中查询，在不同的场景应该使用合适的访问表。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/1477390/\" target=\"_blank\" rel=\"noopener\">代码大全（第2版）</a></li>\n</ol>"},{"title":"如何写好前端业务代码？","date":"2019-03-27T15:08:16.000Z","_content":"## 前言\n\n如何写出可维护和可读性高的代码，这一直是一个困扰很多人的问题。关于变量如何起名、如何优化if else之类的小技巧，这里就不做介绍了，推荐去看《代码大全2》，千书万书，都不如一本《代码大全2》。\n\n工作以来，我一直在写一些重复且交互复杂的页面，也没有整理过自己的思路，这篇文章是我工作一年半来在项目中总结出来的一些经验。\n<!-- more -->\n\n## 分层\n\n对于业务代码来说，大部分的前端应用都还是以展示数据为主，无非是从接口拿到数据，进行一系列数据格式化后，显示在页面当中。\n\n首先，应当尽可能的进行分层，传统的mvc分层很适用于前端开发，但对于复杂页面来说，随着业务逻辑增加，往往会造成controller臃肿的问题。因此，在此之上，可以将controller其分成formatter、service等等。\n\n\n![](https://user-gold-cdn.xitu.io/2019/3/21/1699e115a0724a58?w=1074&h=798&f=png&s=61000)\n下面这是一些分层后简单的目录结构。\n```javascript\n    + pages\n        + hotelList\n            + components\n                + Header.jsx\n            + formatter\n                + index.js\n            + share\n                + constants.js\n                + utils.js\n            + view.js\n            + controller.js\n            + model.js\n```\n\n### Service\n统一管理所有请求路径，并且将页面中涉及到的网络请求封装为class。\n```javascript\n// api.js\nexport default {\n    HOTELLIST: '/hotelList',\n    HOTELDETAIL: '/hotelDetail'\n}\n\n// Service.js\nclass Service {\n    fetchHotelList = (params) => {\n        return fetch(HOTELLIST, params);\n    }\n    fetchHotelDetail = (params) => {\n        return fetch(HOTELLIST, params);\n    }\n}\nexport default new Service\n```\n这样带来的好处就是，很清楚的知道页面中涉及了哪些请求，如果使用了TypeScript，后续某个请求方法名修改了后，在所有调用的地方也会提示错误，非常方便。\n\n### formatter\n\nformatter层储存一些格式化数据的方法，这些方法接收数据，返回新的数据，不应该再涉及到其他的逻辑，这样有利于单元测试。单个format函数也不应该格式化过多数据，函数应该根据功能进行适当拆分，合理复用。\n\n### mvc\n\n顾名思义，controller就是mvc中的c，controller应该是处理各种副作用操作（网络请求、缓存、事件响应等等）的地方。\n\n当处理一个请求的时候，controller会调用service里面对应的方法，拿到数据后再调用formatter的方法，将格式化后的数据存入store中，展示到页面上。\n\n```javascript\nclass Controller {\n    fetchHotelList = () => async (dispatch) => {\n        const params = {}\n        this.showLoading();\n        try {\n            const res = await Service.fetchHotelList(params)\n            const hotelList = formatHotelList(res.Data && res.Data.HotelList)\n            dispatch({\n                type: 'UPDATE_HOTELLIST',\n                hotelList\n            })\n        } catch (err) {\n            this.showError(err);\n        } finally {\n            this.hideLoading();\n        }\n    }\n}\n```\nview则是指react组件，建议尽量用纯函数组件，有了hooks之后，react也会变得更加纯粹（实际上有状态组件也可以看做一个mvc的结构，state是model，render是view，各种handler方法是controller）。\n\n对于react来说，最外层的一般称作容器组件，我们会在容器组件里面进行网络请求等副作用的操作。\n\n在这里，容器组件里面的一些逻辑也可以剥离出来放到controller中（react-imvc就是这种做法），这样就可以给controller赋予生命周期，容器组件只用于纯展示。\n\n我们将容器组件的生命周期放到wrapper这个高阶组件中，并在里面调用controller里面封装的生命周期，这样我们可以就编写更加纯粹的view，例如：\n\nwrapper.js\n```javascript\n// wrapper.js（伪代码）\nconst Wrapper = (view) => {\n    return class extends Component {\n        constructor(props) {\n            super(props)\n        }\n        componentWillMount() {\n            this.props.pageWillMount && this.props.pageWillMount()\n        }\n        componentDidMount() {\n                this.props.pageDidMount && this.props.pageDidMount()\n            }\n        }\n        componentWillUnmount() {\n            this.props.pageWillLeave && this.props.pageWillLeave()\n        }\n        render() {\n            const {\n                store: state,\n                actions\n            } = this.props\n            return view({state, actions})\n        }\n    }\n}\n```\n\nview.js\n```javascript\n// view.js\nfunction view({\n    state,\n    actions\n}) {\n    \n    return (\n        <>\n            <Header \n                title={state.title} \n                handleBack={actions.goBackPage}\n            />\n            <Body />\n            <Footer />\n        </>\n    )\n}\nexport default Wrapper(view)\n```\n\ncontroller.js\n```javascript\n// controller.js\nclass Controller {\n    pageDidMount() {\n        this.bindScrollEvent('on')\n        console.log('page did  mount')\n    }\n    pageWillLeave() {\n        this.bindScrollEvent('off')\n        console.log('page will leave')\n    }\n    bindScrollEvent(status) {\n        if (status === 'on) {\n            this.bindScrollEvent('off');\n            window.addEventListener('scroll', this.handleScroll);\n        } else if (status === 'off') {\n            window.removeEventListener('scroll', this.handleScroll);\n        }\n    }\n    // 滚动事件\n    handleScroll() {\n        \n    }\n}\n```\n\n### 其他\n\n对于埋点来说，原本也应该放到controller中，但也是可以独立出来一个tracelog层，至于tracelog层如何实现和调用，还是看个人爱好，我比较喜欢用发布订阅的形式。\n\n如果还涉及到缓存，那我们也可以再分出来一个storage层，这里存放对缓存进行增删查改的各种操作。\n\n对于一些常用的固定不变的值，也可以放到constants.js，通过引入constants来获取值，这样便于后续维护。\n\n```javascript\n// constants.js\nexport const cityMapping = {\n    '1': '北京',\n    '2': '上海'\n}\nexport const traceKey = {\n    'loading': 'PAGE_LOADING'\n}\n// tracelog.js\nclass TraceLog {\n    traceLoading = (params) => {\n        tracelog(traceKey.loading, params);\n    }\n}\nexport default new TraceLog\n\n// storage.js\nexport default class Storage {\n    static get instance() {\n        // \n    }\n    setName(name) {\n        //\n    }\n    getName() {\n        //\n    }\n}\n```\n\n## 数据与交互\n\n不过也不代表着这样写就够了，分层只能够保证代码结构上的清晰，真正想写出好的业务代码，最重要的还是你对业务逻辑足够清晰，页面上的数据流动是怎样的？数据结构怎么设计更加合理？页面上有哪些交互？这些交互会带来哪些影响？\n\n以如下酒店列表页为例，这个页面看似简单，实际上包含了很多复杂的交互。\n\n上方的是四个筛选项菜单，点开后里面包含了很多子类筛选项，比如筛选里面包括了双床、大床、三床，价格/星级里面包含了高档/豪华、￥150-￥300等等。\n\n下方是快捷筛选项，对应了部分筛选项菜单里面的子类筛选项。\n\n![image_1d6dgvgio1hfg82u1kmo1u141tv69.png-230.3kB][1]\n\n当我们选中筛选里面的双床后，下方的双床也会被默认选中，反之当我们选中下方的双床后，筛选类别里面的双床也会被选中，名称还会回显到原来的筛选上。\n\n![image_1d6dgvscipuea6nsnhl6a1ijam.png-231.3kB][2]\n\n\n![image_1d6dhiup11mnj12351f0fl36msh1g.png-57.7kB][3]\n\n\n除此之外，我们点击搜索框后，输入'双床'，联想词会出现双床，并表示这是个筛选项，如果用户选中了这个双床，我们依然需要筛选项和快捷筛选项默认选中。\n\n这三个地方都涉及到了筛选项，并且修改一个，其他两个地方就要跟着改变，更何况三者的数据来自于三个不同的接口数据，这是多么蛋疼的一件事情！\n\n![image_1d6dhc833375eo118vq1od61j6u13.png-40.4kB][4]\n\n我借助这个例子来说明，在开始写页面之前，一定要对页面中的隐藏交互和数据流动很熟悉，也需要去设计更加合理的数据结构。\n\n对于深层次的列表结构，键值对会比数组查询速度更快，通过key也会更容易和其他数据进行联动，但是却不能保证顺序，有时候可能就需要牺牲空间来换时间。\n```javascript\n// 假设筛选项床型type为1，大床id为1，双床id为2.\nconst bed = {\n    '1-1': {\n        name: '大床',\n        id: 1,\n        type: 1\n    },\n    '1-2': {\n        name: '双床',\n        id: 2,\n        type: 1\n    }\n}\nconst bedSort = ['1-1', '1-2'] // 保证展示顺序\n```\n当我们选中大床的时候，只需要保存'1-1'这个key，再和store中快捷筛选项列表里面的key进行mapping（快捷筛选项里面的项也应该格式化为{'type-id': filterItem}的键值对格式），这样从时间复杂度上说，比直接遍历两个数组更高效。\n\n## 总结\n\n在开始写业务之前，理应先想清楚需求和业务逻辑，设计出合理的数据结构，对代码进行好的分层，这样在一定程度上可以写出可维护性更高的代码。\n\n**PS**：欢迎大家关注我的公众号【前端小馆】，大家一起来讨论技术。\n\n\n![](https://user-gold-cdn.xitu.io/2019/3/21/1699e08ee230f8c4?w=129&h=129&f=png&s=12818)\n\n  [1]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b427d326?w=416&h=687&f=png&s=235835\n  [2]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b41c1ea6?w=420&h=687&f=png&s=236813\n  [3]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b433857b?w=427&h=689&f=png&s=59076\n  [4]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b448c96a?w=420&h=419&f=png&s=41349\n  [5]: https://github.com/Lucifier129/Lucifier129.github.io/issues/2","source":"_posts/如何写好前端业务代码？.md","raw":"---\ntitle: 如何写好前端业务代码？\ndate: 2019-03-27 23:08:16\ncategories: 前端\ntags:\n    - react\n    - javascript\n    - 前端\n---\n## 前言\n\n如何写出可维护和可读性高的代码，这一直是一个困扰很多人的问题。关于变量如何起名、如何优化if else之类的小技巧，这里就不做介绍了，推荐去看《代码大全2》，千书万书，都不如一本《代码大全2》。\n\n工作以来，我一直在写一些重复且交互复杂的页面，也没有整理过自己的思路，这篇文章是我工作一年半来在项目中总结出来的一些经验。\n<!-- more -->\n\n## 分层\n\n对于业务代码来说，大部分的前端应用都还是以展示数据为主，无非是从接口拿到数据，进行一系列数据格式化后，显示在页面当中。\n\n首先，应当尽可能的进行分层，传统的mvc分层很适用于前端开发，但对于复杂页面来说，随着业务逻辑增加，往往会造成controller臃肿的问题。因此，在此之上，可以将controller其分成formatter、service等等。\n\n\n![](https://user-gold-cdn.xitu.io/2019/3/21/1699e115a0724a58?w=1074&h=798&f=png&s=61000)\n下面这是一些分层后简单的目录结构。\n```javascript\n    + pages\n        + hotelList\n            + components\n                + Header.jsx\n            + formatter\n                + index.js\n            + share\n                + constants.js\n                + utils.js\n            + view.js\n            + controller.js\n            + model.js\n```\n\n### Service\n统一管理所有请求路径，并且将页面中涉及到的网络请求封装为class。\n```javascript\n// api.js\nexport default {\n    HOTELLIST: '/hotelList',\n    HOTELDETAIL: '/hotelDetail'\n}\n\n// Service.js\nclass Service {\n    fetchHotelList = (params) => {\n        return fetch(HOTELLIST, params);\n    }\n    fetchHotelDetail = (params) => {\n        return fetch(HOTELLIST, params);\n    }\n}\nexport default new Service\n```\n这样带来的好处就是，很清楚的知道页面中涉及了哪些请求，如果使用了TypeScript，后续某个请求方法名修改了后，在所有调用的地方也会提示错误，非常方便。\n\n### formatter\n\nformatter层储存一些格式化数据的方法，这些方法接收数据，返回新的数据，不应该再涉及到其他的逻辑，这样有利于单元测试。单个format函数也不应该格式化过多数据，函数应该根据功能进行适当拆分，合理复用。\n\n### mvc\n\n顾名思义，controller就是mvc中的c，controller应该是处理各种副作用操作（网络请求、缓存、事件响应等等）的地方。\n\n当处理一个请求的时候，controller会调用service里面对应的方法，拿到数据后再调用formatter的方法，将格式化后的数据存入store中，展示到页面上。\n\n```javascript\nclass Controller {\n    fetchHotelList = () => async (dispatch) => {\n        const params = {}\n        this.showLoading();\n        try {\n            const res = await Service.fetchHotelList(params)\n            const hotelList = formatHotelList(res.Data && res.Data.HotelList)\n            dispatch({\n                type: 'UPDATE_HOTELLIST',\n                hotelList\n            })\n        } catch (err) {\n            this.showError(err);\n        } finally {\n            this.hideLoading();\n        }\n    }\n}\n```\nview则是指react组件，建议尽量用纯函数组件，有了hooks之后，react也会变得更加纯粹（实际上有状态组件也可以看做一个mvc的结构，state是model，render是view，各种handler方法是controller）。\n\n对于react来说，最外层的一般称作容器组件，我们会在容器组件里面进行网络请求等副作用的操作。\n\n在这里，容器组件里面的一些逻辑也可以剥离出来放到controller中（react-imvc就是这种做法），这样就可以给controller赋予生命周期，容器组件只用于纯展示。\n\n我们将容器组件的生命周期放到wrapper这个高阶组件中，并在里面调用controller里面封装的生命周期，这样我们可以就编写更加纯粹的view，例如：\n\nwrapper.js\n```javascript\n// wrapper.js（伪代码）\nconst Wrapper = (view) => {\n    return class extends Component {\n        constructor(props) {\n            super(props)\n        }\n        componentWillMount() {\n            this.props.pageWillMount && this.props.pageWillMount()\n        }\n        componentDidMount() {\n                this.props.pageDidMount && this.props.pageDidMount()\n            }\n        }\n        componentWillUnmount() {\n            this.props.pageWillLeave && this.props.pageWillLeave()\n        }\n        render() {\n            const {\n                store: state,\n                actions\n            } = this.props\n            return view({state, actions})\n        }\n    }\n}\n```\n\nview.js\n```javascript\n// view.js\nfunction view({\n    state,\n    actions\n}) {\n    \n    return (\n        <>\n            <Header \n                title={state.title} \n                handleBack={actions.goBackPage}\n            />\n            <Body />\n            <Footer />\n        </>\n    )\n}\nexport default Wrapper(view)\n```\n\ncontroller.js\n```javascript\n// controller.js\nclass Controller {\n    pageDidMount() {\n        this.bindScrollEvent('on')\n        console.log('page did  mount')\n    }\n    pageWillLeave() {\n        this.bindScrollEvent('off')\n        console.log('page will leave')\n    }\n    bindScrollEvent(status) {\n        if (status === 'on) {\n            this.bindScrollEvent('off');\n            window.addEventListener('scroll', this.handleScroll);\n        } else if (status === 'off') {\n            window.removeEventListener('scroll', this.handleScroll);\n        }\n    }\n    // 滚动事件\n    handleScroll() {\n        \n    }\n}\n```\n\n### 其他\n\n对于埋点来说，原本也应该放到controller中，但也是可以独立出来一个tracelog层，至于tracelog层如何实现和调用，还是看个人爱好，我比较喜欢用发布订阅的形式。\n\n如果还涉及到缓存，那我们也可以再分出来一个storage层，这里存放对缓存进行增删查改的各种操作。\n\n对于一些常用的固定不变的值，也可以放到constants.js，通过引入constants来获取值，这样便于后续维护。\n\n```javascript\n// constants.js\nexport const cityMapping = {\n    '1': '北京',\n    '2': '上海'\n}\nexport const traceKey = {\n    'loading': 'PAGE_LOADING'\n}\n// tracelog.js\nclass TraceLog {\n    traceLoading = (params) => {\n        tracelog(traceKey.loading, params);\n    }\n}\nexport default new TraceLog\n\n// storage.js\nexport default class Storage {\n    static get instance() {\n        // \n    }\n    setName(name) {\n        //\n    }\n    getName() {\n        //\n    }\n}\n```\n\n## 数据与交互\n\n不过也不代表着这样写就够了，分层只能够保证代码结构上的清晰，真正想写出好的业务代码，最重要的还是你对业务逻辑足够清晰，页面上的数据流动是怎样的？数据结构怎么设计更加合理？页面上有哪些交互？这些交互会带来哪些影响？\n\n以如下酒店列表页为例，这个页面看似简单，实际上包含了很多复杂的交互。\n\n上方的是四个筛选项菜单，点开后里面包含了很多子类筛选项，比如筛选里面包括了双床、大床、三床，价格/星级里面包含了高档/豪华、￥150-￥300等等。\n\n下方是快捷筛选项，对应了部分筛选项菜单里面的子类筛选项。\n\n![image_1d6dgvgio1hfg82u1kmo1u141tv69.png-230.3kB][1]\n\n当我们选中筛选里面的双床后，下方的双床也会被默认选中，反之当我们选中下方的双床后，筛选类别里面的双床也会被选中，名称还会回显到原来的筛选上。\n\n![image_1d6dgvscipuea6nsnhl6a1ijam.png-231.3kB][2]\n\n\n![image_1d6dhiup11mnj12351f0fl36msh1g.png-57.7kB][3]\n\n\n除此之外，我们点击搜索框后，输入'双床'，联想词会出现双床，并表示这是个筛选项，如果用户选中了这个双床，我们依然需要筛选项和快捷筛选项默认选中。\n\n这三个地方都涉及到了筛选项，并且修改一个，其他两个地方就要跟着改变，更何况三者的数据来自于三个不同的接口数据，这是多么蛋疼的一件事情！\n\n![image_1d6dhc833375eo118vq1od61j6u13.png-40.4kB][4]\n\n我借助这个例子来说明，在开始写页面之前，一定要对页面中的隐藏交互和数据流动很熟悉，也需要去设计更加合理的数据结构。\n\n对于深层次的列表结构，键值对会比数组查询速度更快，通过key也会更容易和其他数据进行联动，但是却不能保证顺序，有时候可能就需要牺牲空间来换时间。\n```javascript\n// 假设筛选项床型type为1，大床id为1，双床id为2.\nconst bed = {\n    '1-1': {\n        name: '大床',\n        id: 1,\n        type: 1\n    },\n    '1-2': {\n        name: '双床',\n        id: 2,\n        type: 1\n    }\n}\nconst bedSort = ['1-1', '1-2'] // 保证展示顺序\n```\n当我们选中大床的时候，只需要保存'1-1'这个key，再和store中快捷筛选项列表里面的key进行mapping（快捷筛选项里面的项也应该格式化为{'type-id': filterItem}的键值对格式），这样从时间复杂度上说，比直接遍历两个数组更高效。\n\n## 总结\n\n在开始写业务之前，理应先想清楚需求和业务逻辑，设计出合理的数据结构，对代码进行好的分层，这样在一定程度上可以写出可维护性更高的代码。\n\n**PS**：欢迎大家关注我的公众号【前端小馆】，大家一起来讨论技术。\n\n\n![](https://user-gold-cdn.xitu.io/2019/3/21/1699e08ee230f8c4?w=129&h=129&f=png&s=12818)\n\n  [1]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b427d326?w=416&h=687&f=png&s=235835\n  [2]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b41c1ea6?w=420&h=687&f=png&s=236813\n  [3]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b433857b?w=427&h=689&f=png&s=59076\n  [4]: https://user-gold-cdn.xitu.io/2019/3/21/1699de85b448c96a?w=420&h=419&f=png&s=41349\n  [5]: https://github.com/Lucifier129/Lucifier129.github.io/issues/2","slug":"如何写好前端业务代码？","published":1,"updated":"2019-04-07T05:53:12.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs6o006gdrfd6y161ig6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>如何写出可维护和可读性高的代码，这一直是一个困扰很多人的问题。关于变量如何起名、如何优化if else之类的小技巧，这里就不做介绍了，推荐去看《代码大全2》，千书万书，都不如一本《代码大全2》。</p>\n<p>工作以来，我一直在写一些重复且交互复杂的页面，也没有整理过自己的思路，这篇文章是我工作一年半来在项目中总结出来的一些经验。<br><a id=\"more\"></a></p>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>对于业务代码来说，大部分的前端应用都还是以展示数据为主，无非是从接口拿到数据，进行一系列数据格式化后，显示在页面当中。</p>\n<p>首先，应当尽可能的进行分层，传统的mvc分层很适用于前端开发，但对于复杂页面来说，随着业务逻辑增加，往往会造成controller臃肿的问题。因此，在此之上，可以将controller其分成formatter、service等等。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699e115a0724a58?w=1074&amp;h=798&amp;f=png&amp;s=61000\" alt=\"\"><br>下面这是一些分层后简单的目录结构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ pages</span><br><span class=\"line\">    + hotelList</span><br><span class=\"line\">        + components</span><br><span class=\"line\">            + Header.jsx</span><br><span class=\"line\">        + formatter</span><br><span class=\"line\">            + index.js</span><br><span class=\"line\">        + share</span><br><span class=\"line\">            + constants.js</span><br><span class=\"line\">            + utils.js</span><br><span class=\"line\">        + view.js</span><br><span class=\"line\">        + controller.js</span><br><span class=\"line\">        + model.js</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>统一管理所有请求路径，并且将页面中涉及到的网络请求封装为class。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// api.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    HOTELLIST: <span class=\"string\">'/hotelList'</span>,</span><br><span class=\"line\">    HOTELDETAIL: <span class=\"string\">'/hotelDetail'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Service.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    fetchHotelList = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetch(HOTELLIST, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fetchHotelDetail = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetch(HOTELLIST, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Service</span><br></pre></td></tr></table></figure></p>\n<p>这样带来的好处就是，很清楚的知道页面中涉及了哪些请求，如果使用了TypeScript，后续某个请求方法名修改了后，在所有调用的地方也会提示错误，非常方便。</p>\n<h3 id=\"formatter\"><a href=\"#formatter\" class=\"headerlink\" title=\"formatter\"></a>formatter</h3><p>formatter层储存一些格式化数据的方法，这些方法接收数据，返回新的数据，不应该再涉及到其他的逻辑，这样有利于单元测试。单个format函数也不应该格式化过多数据，函数应该根据功能进行适当拆分，合理复用。</p>\n<h3 id=\"mvc\"><a href=\"#mvc\" class=\"headerlink\" title=\"mvc\"></a>mvc</h3><p>顾名思义，controller就是mvc中的c，controller应该是处理各种副作用操作（网络请求、缓存、事件响应等等）的地方。</p>\n<p>当处理一个请求的时候，controller会调用service里面对应的方法，拿到数据后再调用formatter的方法，将格式化后的数据存入store中，展示到页面上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    fetchHotelList = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">async</span> (dispatch) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.showLoading();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> Service.fetchHotelList(params)</span><br><span class=\"line\">            <span class=\"keyword\">const</span> hotelList = formatHotelList(res.Data &amp;&amp; res.Data.HotelList)</span><br><span class=\"line\">            dispatch(&#123;</span><br><span class=\"line\">                type: <span class=\"string\">'UPDATE_HOTELLIST'</span>,</span><br><span class=\"line\">                hotelList</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showError(err);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hideLoading();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>view则是指react组件，建议尽量用纯函数组件，有了hooks之后，react也会变得更加纯粹（实际上有状态组件也可以看做一个mvc的结构，state是model，render是view，各种handler方法是controller）。</p>\n<p>对于react来说，最外层的一般称作容器组件，我们会在容器组件里面进行网络请求等副作用的操作。</p>\n<p>在这里，容器组件里面的一些逻辑也可以剥离出来放到controller中（react-imvc就是这种做法），这样就可以给controller赋予生命周期，容器组件只用于纯展示。</p>\n<p>我们将容器组件的生命周期放到wrapper这个高阶组件中，并在里面调用controller里面封装的生命周期，这样我们可以就编写更加纯粹的view，例如：</p>\n<p>wrapper.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wrapper.js（伪代码）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Wrapper = <span class=\"function\">(<span class=\"params\">view</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pageWillMount &amp;&amp; <span class=\"keyword\">this</span>.props.pageWillMount()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.props.pageDidMount &amp;&amp; <span class=\"keyword\">this</span>.props.pageDidMount()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pageWillLeave &amp;&amp; <span class=\"keyword\">this</span>.props.pageWillLeave()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">                store: state,</span><br><span class=\"line\">                actions</span><br><span class=\"line\">            &#125; = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view(&#123;state, actions&#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>view.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// view.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">view</span>(<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    state,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    actions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;Header </span><br><span class=\"line\">                title=&#123;state.title&#125; </span><br><span class=\"line\">                handleBack=&#123;actions.goBackPage&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Body /&gt;</span><br><span class=\"line\">            &lt;Footer /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Wrapper(view)</span></span><br></pre></td></tr></table></figure></p>\n<p>controller.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// controller.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    pageDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bindScrollEvent(<span class=\"string\">'on'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'page did  mount'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pageWillLeave() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bindScrollEvent(<span class=\"string\">'off'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'page will leave'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bindScrollEvent(status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status === <span class=\"string\">'on) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            this.bindScrollEvent('</span>off<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">            window.addEventListener('</span>scroll<span class=\"string\">', this.handleScroll);</span></span><br><span class=\"line\"><span class=\"string\">        &#125; else if (status === '</span>off<span class=\"string\">') &#123;</span></span><br><span class=\"line\"><span class=\"string\">            window.removeEventListener('</span>scroll<span class=\"string\">', this.handleScroll);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    // 滚动事件</span></span><br><span class=\"line\"><span class=\"string\">    handleScroll() &#123;</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>对于埋点来说，原本也应该放到controller中，但也是可以独立出来一个tracelog层，至于tracelog层如何实现和调用，还是看个人爱好，我比较喜欢用发布订阅的形式。</p>\n<p>如果还涉及到缓存，那我们也可以再分出来一个storage层，这里存放对缓存进行增删查改的各种操作。</p>\n<p>对于一些常用的固定不变的值，也可以放到constants.js，通过引入constants来获取值，这样便于后续维护。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> cityMapping = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'北京'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'上海'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> traceKey = &#123;</span><br><span class=\"line\">    <span class=\"string\">'loading'</span>: <span class=\"string\">'PAGE_LOADING'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// tracelog.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraceLog</span> </span>&#123;</span><br><span class=\"line\">    traceLoading = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        tracelog(traceKey.loading, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> TraceLog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// storage.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> get instance() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据与交互\"><a href=\"#数据与交互\" class=\"headerlink\" title=\"数据与交互\"></a>数据与交互</h2><p>不过也不代表着这样写就够了，分层只能够保证代码结构上的清晰，真正想写出好的业务代码，最重要的还是你对业务逻辑足够清晰，页面上的数据流动是怎样的？数据结构怎么设计更加合理？页面上有哪些交互？这些交互会带来哪些影响？</p>\n<p>以如下酒店列表页为例，这个页面看似简单，实际上包含了很多复杂的交互。</p>\n<p>上方的是四个筛选项菜单，点开后里面包含了很多子类筛选项，比如筛选里面包括了双床、大床、三床，价格/星级里面包含了高档/豪华、￥150-￥300等等。</p>\n<p>下方是快捷筛选项，对应了部分筛选项菜单里面的子类筛选项。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b427d326?w=416&amp;h=687&amp;f=png&amp;s=235835\" alt=\"image_1d6dgvgio1hfg82u1kmo1u141tv69.png-230.3kB\"></p>\n<p>当我们选中筛选里面的双床后，下方的双床也会被默认选中，反之当我们选中下方的双床后，筛选类别里面的双床也会被选中，名称还会回显到原来的筛选上。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b41c1ea6?w=420&amp;h=687&amp;f=png&amp;s=236813\" alt=\"image_1d6dgvscipuea6nsnhl6a1ijam.png-231.3kB\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b433857b?w=427&amp;h=689&amp;f=png&amp;s=59076\" alt=\"image_1d6dhiup11mnj12351f0fl36msh1g.png-57.7kB\"></p>\n<p>除此之外，我们点击搜索框后，输入’双床’，联想词会出现双床，并表示这是个筛选项，如果用户选中了这个双床，我们依然需要筛选项和快捷筛选项默认选中。</p>\n<p>这三个地方都涉及到了筛选项，并且修改一个，其他两个地方就要跟着改变，更何况三者的数据来自于三个不同的接口数据，这是多么蛋疼的一件事情！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b448c96a?w=420&amp;h=419&amp;f=png&amp;s=41349\" alt=\"image_1d6dhc833375eo118vq1od61j6u13.png-40.4kB\"></p>\n<p>我借助这个例子来说明，在开始写页面之前，一定要对页面中的隐藏交互和数据流动很熟悉，也需要去设计更加合理的数据结构。</p>\n<p>对于深层次的列表结构，键值对会比数组查询速度更快，通过key也会更容易和其他数据进行联动，但是却不能保证顺序，有时候可能就需要牺牲空间来换时间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设筛选项床型type为1，大床id为1，双床id为2.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bed = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1-1'</span>: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'大床'</span>,</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        type: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'1-2'</span>: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'双床'</span>,</span><br><span class=\"line\">        id: <span class=\"number\">2</span>,</span><br><span class=\"line\">        type: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> bedSort = [<span class=\"string\">'1-1'</span>, <span class=\"string\">'1-2'</span>] <span class=\"comment\">// 保证展示顺序</span></span><br></pre></td></tr></table></figure></p>\n<p>当我们选中大床的时候，只需要保存’1-1’这个key，再和store中快捷筛选项列表里面的key进行mapping（快捷筛选项里面的项也应该格式化为{‘type-id’: filterItem}的键值对格式），这样从时间复杂度上说，比直接遍历两个数组更高效。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在开始写业务之前，理应先想清楚需求和业务逻辑，设计出合理的数据结构，对代码进行好的分层，这样在一定程度上可以写出可维护性更高的代码。</p>\n<p><strong>PS</strong>：欢迎大家关注我的公众号【前端小馆】，大家一起来讨论技术。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699e08ee230f8c4?w=129&amp;h=129&amp;f=png&amp;s=12818\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>如何写出可维护和可读性高的代码，这一直是一个困扰很多人的问题。关于变量如何起名、如何优化if else之类的小技巧，这里就不做介绍了，推荐去看《代码大全2》，千书万书，都不如一本《代码大全2》。</p>\n<p>工作以来，我一直在写一些重复且交互复杂的页面，也没有整理过自己的思路，这篇文章是我工作一年半来在项目中总结出来的一些经验。<br>","more":"</p>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>对于业务代码来说，大部分的前端应用都还是以展示数据为主，无非是从接口拿到数据，进行一系列数据格式化后，显示在页面当中。</p>\n<p>首先，应当尽可能的进行分层，传统的mvc分层很适用于前端开发，但对于复杂页面来说，随着业务逻辑增加，往往会造成controller臃肿的问题。因此，在此之上，可以将controller其分成formatter、service等等。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699e115a0724a58?w=1074&amp;h=798&amp;f=png&amp;s=61000\" alt=\"\"><br>下面这是一些分层后简单的目录结构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ pages</span><br><span class=\"line\">    + hotelList</span><br><span class=\"line\">        + components</span><br><span class=\"line\">            + Header.jsx</span><br><span class=\"line\">        + formatter</span><br><span class=\"line\">            + index.js</span><br><span class=\"line\">        + share</span><br><span class=\"line\">            + constants.js</span><br><span class=\"line\">            + utils.js</span><br><span class=\"line\">        + view.js</span><br><span class=\"line\">        + controller.js</span><br><span class=\"line\">        + model.js</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>统一管理所有请求路径，并且将页面中涉及到的网络请求封装为class。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// api.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    HOTELLIST: <span class=\"string\">'/hotelList'</span>,</span><br><span class=\"line\">    HOTELDETAIL: <span class=\"string\">'/hotelDetail'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Service.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    fetchHotelList = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetch(HOTELLIST, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fetchHotelDetail = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetch(HOTELLIST, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Service</span><br></pre></td></tr></table></figure></p>\n<p>这样带来的好处就是，很清楚的知道页面中涉及了哪些请求，如果使用了TypeScript，后续某个请求方法名修改了后，在所有调用的地方也会提示错误，非常方便。</p>\n<h3 id=\"formatter\"><a href=\"#formatter\" class=\"headerlink\" title=\"formatter\"></a>formatter</h3><p>formatter层储存一些格式化数据的方法，这些方法接收数据，返回新的数据，不应该再涉及到其他的逻辑，这样有利于单元测试。单个format函数也不应该格式化过多数据，函数应该根据功能进行适当拆分，合理复用。</p>\n<h3 id=\"mvc\"><a href=\"#mvc\" class=\"headerlink\" title=\"mvc\"></a>mvc</h3><p>顾名思义，controller就是mvc中的c，controller应该是处理各种副作用操作（网络请求、缓存、事件响应等等）的地方。</p>\n<p>当处理一个请求的时候，controller会调用service里面对应的方法，拿到数据后再调用formatter的方法，将格式化后的数据存入store中，展示到页面上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    fetchHotelList = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">async</span> (dispatch) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.showLoading();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> Service.fetchHotelList(params)</span><br><span class=\"line\">            <span class=\"keyword\">const</span> hotelList = formatHotelList(res.Data &amp;&amp; res.Data.HotelList)</span><br><span class=\"line\">            dispatch(&#123;</span><br><span class=\"line\">                type: <span class=\"string\">'UPDATE_HOTELLIST'</span>,</span><br><span class=\"line\">                hotelList</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showError(err);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hideLoading();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>view则是指react组件，建议尽量用纯函数组件，有了hooks之后，react也会变得更加纯粹（实际上有状态组件也可以看做一个mvc的结构，state是model，render是view，各种handler方法是controller）。</p>\n<p>对于react来说，最外层的一般称作容器组件，我们会在容器组件里面进行网络请求等副作用的操作。</p>\n<p>在这里，容器组件里面的一些逻辑也可以剥离出来放到controller中（react-imvc就是这种做法），这样就可以给controller赋予生命周期，容器组件只用于纯展示。</p>\n<p>我们将容器组件的生命周期放到wrapper这个高阶组件中，并在里面调用controller里面封装的生命周期，这样我们可以就编写更加纯粹的view，例如：</p>\n<p>wrapper.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wrapper.js（伪代码）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Wrapper = <span class=\"function\">(<span class=\"params\">view</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pageWillMount &amp;&amp; <span class=\"keyword\">this</span>.props.pageWillMount()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.props.pageDidMount &amp;&amp; <span class=\"keyword\">this</span>.props.pageDidMount()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pageWillLeave &amp;&amp; <span class=\"keyword\">this</span>.props.pageWillLeave()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">                store: state,</span><br><span class=\"line\">                actions</span><br><span class=\"line\">            &#125; = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view(&#123;state, actions&#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>view.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// view.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">view</span>(<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    state,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    actions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;Header </span><br><span class=\"line\">                title=&#123;state.title&#125; </span><br><span class=\"line\">                handleBack=&#123;actions.goBackPage&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Body /&gt;</span><br><span class=\"line\">            &lt;Footer /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Wrapper(view)</span></span><br></pre></td></tr></table></figure></p>\n<p>controller.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// controller.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    pageDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bindScrollEvent(<span class=\"string\">'on'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'page did  mount'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pageWillLeave() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bindScrollEvent(<span class=\"string\">'off'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'page will leave'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bindScrollEvent(status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status === <span class=\"string\">'on) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            this.bindScrollEvent('</span>off<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">            window.addEventListener('</span>scroll<span class=\"string\">', this.handleScroll);</span></span><br><span class=\"line\"><span class=\"string\">        &#125; else if (status === '</span>off<span class=\"string\">') &#123;</span></span><br><span class=\"line\"><span class=\"string\">            window.removeEventListener('</span>scroll<span class=\"string\">', this.handleScroll);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    // 滚动事件</span></span><br><span class=\"line\"><span class=\"string\">    handleScroll() &#123;</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>对于埋点来说，原本也应该放到controller中，但也是可以独立出来一个tracelog层，至于tracelog层如何实现和调用，还是看个人爱好，我比较喜欢用发布订阅的形式。</p>\n<p>如果还涉及到缓存，那我们也可以再分出来一个storage层，这里存放对缓存进行增删查改的各种操作。</p>\n<p>对于一些常用的固定不变的值，也可以放到constants.js，通过引入constants来获取值，这样便于后续维护。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> cityMapping = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'北京'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'上海'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> traceKey = &#123;</span><br><span class=\"line\">    <span class=\"string\">'loading'</span>: <span class=\"string\">'PAGE_LOADING'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// tracelog.js</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraceLog</span> </span>&#123;</span><br><span class=\"line\">    traceLoading = <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        tracelog(traceKey.loading, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> TraceLog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// storage.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> get instance() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据与交互\"><a href=\"#数据与交互\" class=\"headerlink\" title=\"数据与交互\"></a>数据与交互</h2><p>不过也不代表着这样写就够了，分层只能够保证代码结构上的清晰，真正想写出好的业务代码，最重要的还是你对业务逻辑足够清晰，页面上的数据流动是怎样的？数据结构怎么设计更加合理？页面上有哪些交互？这些交互会带来哪些影响？</p>\n<p>以如下酒店列表页为例，这个页面看似简单，实际上包含了很多复杂的交互。</p>\n<p>上方的是四个筛选项菜单，点开后里面包含了很多子类筛选项，比如筛选里面包括了双床、大床、三床，价格/星级里面包含了高档/豪华、￥150-￥300等等。</p>\n<p>下方是快捷筛选项，对应了部分筛选项菜单里面的子类筛选项。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b427d326?w=416&amp;h=687&amp;f=png&amp;s=235835\" alt=\"image_1d6dgvgio1hfg82u1kmo1u141tv69.png-230.3kB\"></p>\n<p>当我们选中筛选里面的双床后，下方的双床也会被默认选中，反之当我们选中下方的双床后，筛选类别里面的双床也会被选中，名称还会回显到原来的筛选上。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b41c1ea6?w=420&amp;h=687&amp;f=png&amp;s=236813\" alt=\"image_1d6dgvscipuea6nsnhl6a1ijam.png-231.3kB\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b433857b?w=427&amp;h=689&amp;f=png&amp;s=59076\" alt=\"image_1d6dhiup11mnj12351f0fl36msh1g.png-57.7kB\"></p>\n<p>除此之外，我们点击搜索框后，输入’双床’，联想词会出现双床，并表示这是个筛选项，如果用户选中了这个双床，我们依然需要筛选项和快捷筛选项默认选中。</p>\n<p>这三个地方都涉及到了筛选项，并且修改一个，其他两个地方就要跟着改变，更何况三者的数据来自于三个不同的接口数据，这是多么蛋疼的一件事情！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699de85b448c96a?w=420&amp;h=419&amp;f=png&amp;s=41349\" alt=\"image_1d6dhc833375eo118vq1od61j6u13.png-40.4kB\"></p>\n<p>我借助这个例子来说明，在开始写页面之前，一定要对页面中的隐藏交互和数据流动很熟悉，也需要去设计更加合理的数据结构。</p>\n<p>对于深层次的列表结构，键值对会比数组查询速度更快，通过key也会更容易和其他数据进行联动，但是却不能保证顺序，有时候可能就需要牺牲空间来换时间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设筛选项床型type为1，大床id为1，双床id为2.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bed = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1-1'</span>: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'大床'</span>,</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        type: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'1-2'</span>: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'双床'</span>,</span><br><span class=\"line\">        id: <span class=\"number\">2</span>,</span><br><span class=\"line\">        type: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> bedSort = [<span class=\"string\">'1-1'</span>, <span class=\"string\">'1-2'</span>] <span class=\"comment\">// 保证展示顺序</span></span><br></pre></td></tr></table></figure></p>\n<p>当我们选中大床的时候，只需要保存’1-1’这个key，再和store中快捷筛选项列表里面的key进行mapping（快捷筛选项里面的项也应该格式化为{‘type-id’: filterItem}的键值对格式），这样从时间复杂度上说，比直接遍历两个数组更高效。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在开始写业务之前，理应先想清楚需求和业务逻辑，设计出合理的数据结构，对代码进行好的分层，这样在一定程度上可以写出可维护性更高的代码。</p>\n<p><strong>PS</strong>：欢迎大家关注我的公众号【前端小馆】，大家一起来讨论技术。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699e08ee230f8c4?w=129&amp;h=129&amp;f=png&amp;s=12818\" alt=\"\"></p>"},{"title":"毕业二三事","date":"2017-07-01T03:47:36.000Z","_content":"临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。\n21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。\n中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。\n\n下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。\n22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。\n<!-- more -->\n晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。\n23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。\n24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。\n25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。\n26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。\n\n27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。\n\n下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。\n\n28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我抬头看着樱花树枝，它们接连不断地朝我跑来，那一瞬间我觉得时间就像树枝一样，正在从我身边不断流逝。\n\n晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。\n\n29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。\n\n30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/毕业二三事.md","raw":"---\ntitle: 毕业二三事\ndate: 2017-07-01 11:47:36\ntags:\n- 毕业\n- 生活\n- 随笔\ncategories: 生活\n---\n临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。\n21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。\n中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。\n\n下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。\n22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。\n<!-- more -->\n晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。\n23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。\n24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。\n25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。\n26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。\n\n27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。\n\n下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。\n\n28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我抬头看着樱花树枝，它们接连不断地朝我跑来，那一瞬间我觉得时间就像树枝一样，正在从我身边不断流逝。\n\n晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。\n\n29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。\n\n30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"毕业二三事","published":1,"updated":"2019-04-07T05:53:13.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhs6r006jdrfdbc6ae7d5","content":"<p>临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。<br>21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。<br>中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。</p>\n<p>下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。<br>22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。<br><a id=\"more\"></a><br>晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。<br>23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。<br>24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。<br>25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。<br>26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。</p>\n<p>27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。</p>\n<p>下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。</p>\n<p>28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我抬头看着樱花树枝，它们接连不断地朝我跑来，那一瞬间我觉得时间就像树枝一样，正在从我身边不断流逝。</p>\n<p>晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。</p>\n<p>29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。</p>\n<p>30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。<br>21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。<br>中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。</p>\n<p>下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。<br>22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。<br>","more":"<br>晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。<br>23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。<br>24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。<br>25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。<br>26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。</p>\n<p>27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。</p>\n<p>下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。</p>\n<p>28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我抬头看着樱花树枝，它们接连不断地朝我跑来，那一瞬间我觉得时间就像树枝一样，正在从我身边不断流逝。</p>\n<p>晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。</p>\n<p>29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。</p>\n<p>30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"管理自己","date":"2018-07-15T05:14:32.000Z","_content":"本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 \n\n我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 \n\n不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 \n\n历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。 \n<!-- more -->\n○ 我的长处是什么 \n\n多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 \n\n以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 \n\n要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 \n\n回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 \n\n我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 \n\n根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 \n\n其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 \n\n第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 \n\n另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 \n\n与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 \n\n把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 \n\n○ 我的工作方式是怎样的 \n\n令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 \n\n同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 \n\n我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 \n\n德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 \n\n艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 \n\n几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 \n\n没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 \n\n○ 我如何学习 \n\n要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 \n\n所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 \n\n像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 \n\n我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 \n\n在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 \n\n我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ \n\n有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” \n\n一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 \n\n另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 \n\n顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 \n\n其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 \n\n下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 \n\n○ 我的价值观是什么 \n\n要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 \n\n20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” \n\n这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 \n\n如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 \n\n让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 \n\n同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 \n\n至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 \n\n价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 \n\n这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” \n\n而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” \n\n组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 \n\n一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 \n\n如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 \n\n○ 我属于何处 \n\n少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 \n\n或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 \n\n同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” \n\n成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 \n\n○ 我该做出什么贡献 \n\n综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 \n\n随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 \n\n尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ \n\n请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 \n\n正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 \n\n○ 对人际关系负责 \n\n除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 \n\n首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 \n\n老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 \n\n这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 \n\n人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 \n\n这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 \n\n而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 \n\n如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 \n\n即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” \n\n如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” \n\n组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 \n\n○ 管理后半生 \n\n当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 \n\n我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 \n\n发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 \n\n还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 \n\n为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 \n\n最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 \n\n管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 \n\n管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 \n\n同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 \n\n发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 \n\n在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 \n\n自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 \n\n如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命","source":"_posts/管理自己.md","raw":"---\ntitle: 管理自己\ndate: 2018-07-15 13:14:32\ntags:\n    - 读书笔记\n    - 前端\ncategories:\n    - 生活\n---\n本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 \n\n我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 \n\n不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 \n\n历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。 \n<!-- more -->\n○ 我的长处是什么 \n\n多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 \n\n以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 \n\n要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 \n\n回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 \n\n我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 \n\n根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 \n\n其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 \n\n第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 \n\n另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 \n\n与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 \n\n把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 \n\n○ 我的工作方式是怎样的 \n\n令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 \n\n同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 \n\n我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 \n\n德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 \n\n艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 \n\n几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 \n\n没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 \n\n○ 我如何学习 \n\n要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 \n\n所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 \n\n像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 \n\n我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 \n\n在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 \n\n我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ \n\n有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” \n\n一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 \n\n另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 \n\n顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 \n\n其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 \n\n下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 \n\n○ 我的价值观是什么 \n\n要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 \n\n20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” \n\n这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 \n\n如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 \n\n让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 \n\n同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 \n\n至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 \n\n价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 \n\n这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” \n\n而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” \n\n组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 \n\n一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 \n\n如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 \n\n○ 我属于何处 \n\n少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 \n\n或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 \n\n同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” \n\n成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 \n\n○ 我该做出什么贡献 \n\n综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 \n\n随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 \n\n尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ \n\n请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 \n\n正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 \n\n○ 对人际关系负责 \n\n除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 \n\n首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 \n\n老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 \n\n这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 \n\n人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 \n\n这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 \n\n而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 \n\n如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 \n\n即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” \n\n如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” \n\n组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 \n\n○ 管理后半生 \n\n当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 \n\n我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 \n\n发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 \n\n还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 \n\n为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 \n\n最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 \n\n管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 \n\n管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 \n\n同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 \n\n发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 \n\n在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 \n\n自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 \n\n如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命","slug":"管理自己","published":1,"updated":"2019-04-07T05:53:13.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju6jhsgq007hdrfdfuomrd15","content":"<p>本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 </p>\n<p>我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 </p>\n<p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 </p>\n<p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。<br><a id=\"more\"></a><br>○ 我的长处是什么 </p>\n<p>多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 </p>\n<p>以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 </p>\n<p>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 </p>\n<p>回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 </p>\n<p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 </p>\n<p>根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 </p>\n<p>其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 </p>\n<p>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 </p>\n<p>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 </p>\n<p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 </p>\n<p>把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 </p>\n<p>○ 我的工作方式是怎样的 </p>\n<p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 </p>\n<p>同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 </p>\n<p>我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 </p>\n<p>德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 </p>\n<p>艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 </p>\n<p>几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 </p>\n<p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 </p>\n<p>○ 我如何学习 </p>\n<p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 </p>\n<p>所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 </p>\n<p>像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 </p>\n<p>我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 </p>\n<p>在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 </p>\n<p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ </p>\n<p>有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” </p>\n<p>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 </p>\n<p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 </p>\n<p>顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 </p>\n<p>其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 </p>\n<p>下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 </p>\n<p>○ 我的价值观是什么 </p>\n<p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 </p>\n<p>20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” </p>\n<p>这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 </p>\n<p>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 </p>\n<p>让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 </p>\n<p>同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 </p>\n<p>至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 </p>\n<p>价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 </p>\n<p>这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” </p>\n<p>而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” </p>\n<p>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 </p>\n<p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 </p>\n<p>如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 </p>\n<p>○ 我属于何处 </p>\n<p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 </p>\n<p>或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 </p>\n<p>同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” </p>\n<p>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 </p>\n<p>○ 我该做出什么贡献 </p>\n<p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 </p>\n<p>随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 </p>\n<p>尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ </p>\n<p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 </p>\n<p>正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 </p>\n<p>○ 对人际关系负责 </p>\n<p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 </p>\n<p>首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 </p>\n<p>老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 </p>\n<p>这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 </p>\n<p>人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 </p>\n<p>这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 </p>\n<p>而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 </p>\n<p>如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 </p>\n<p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” </p>\n<p>如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” </p>\n<p>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 </p>\n<p>○ 管理后半生 </p>\n<p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 </p>\n<p>我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 </p>\n<p>发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 </p>\n<p>还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 </p>\n<p>为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 </p>\n<p>最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 </p>\n<p>管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 </p>\n<p>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 </p>\n<p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 </p>\n<p>发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 </p>\n<p>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 </p>\n<p>自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 </p>\n<p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命</p>\n","site":{"data":{}},"excerpt":"<p>本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 </p>\n<p>我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 </p>\n<p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 </p>\n<p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。<br>","more":"<br>○ 我的长处是什么 </p>\n<p>多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 </p>\n<p>以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 </p>\n<p>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 </p>\n<p>回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 </p>\n<p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 </p>\n<p>根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 </p>\n<p>其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 </p>\n<p>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 </p>\n<p>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 </p>\n<p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 </p>\n<p>把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 </p>\n<p>○ 我的工作方式是怎样的 </p>\n<p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 </p>\n<p>同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 </p>\n<p>我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 </p>\n<p>德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 </p>\n<p>艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 </p>\n<p>几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 </p>\n<p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 </p>\n<p>○ 我如何学习 </p>\n<p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 </p>\n<p>所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 </p>\n<p>像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 </p>\n<p>我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 </p>\n<p>在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 </p>\n<p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ </p>\n<p>有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” </p>\n<p>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 </p>\n<p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 </p>\n<p>顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 </p>\n<p>其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 </p>\n<p>下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 </p>\n<p>○ 我的价值观是什么 </p>\n<p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 </p>\n<p>20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” </p>\n<p>这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 </p>\n<p>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 </p>\n<p>让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 </p>\n<p>同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 </p>\n<p>至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 </p>\n<p>价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 </p>\n<p>这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” </p>\n<p>而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” </p>\n<p>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 </p>\n<p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 </p>\n<p>如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 </p>\n<p>○ 我属于何处 </p>\n<p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 </p>\n<p>或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 </p>\n<p>同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” </p>\n<p>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 </p>\n<p>○ 我该做出什么贡献 </p>\n<p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 </p>\n<p>随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 </p>\n<p>尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ </p>\n<p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 </p>\n<p>正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 </p>\n<p>○ 对人际关系负责 </p>\n<p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 </p>\n<p>首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 </p>\n<p>老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 </p>\n<p>这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 </p>\n<p>人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 </p>\n<p>这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 </p>\n<p>而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 </p>\n<p>如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 </p>\n<p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” </p>\n<p>如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” </p>\n<p>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 </p>\n<p>○ 管理后半生 </p>\n<p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 </p>\n<p>我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 </p>\n<p>发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 </p>\n<p>还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 </p>\n<p>为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 </p>\n<p>最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 </p>\n<p>管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 </p>\n<p>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 </p>\n<p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 </p>\n<p>发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 </p>\n<p>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 </p>\n<p>自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 </p>\n<p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cju6jhrs30000drfdtje771y1","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrsu000edrfdfeqt6trf"},{"post_id":"cju6jhrt0000jdrfd02ml5ft6","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrt6000sdrfdv74m3g41"},{"post_id":"cju6jhrt2000ndrfd5xvclr7s","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrt7000udrfdedzdoh2l"},{"post_id":"cju6jhrt3000odrfd59v67ut6","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrt9000xdrfdpeepw12q"},{"post_id":"cju6jhrsp000cdrfdfztrn3gd","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrte0018drfd18lxoia7"},{"post_id":"cju6jhrsp000cdrfdfztrn3gd","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhrtg001bdrfdzqlrj07o"},{"post_id":"cju6jhrtb0013drfd2khr09ow","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrti001fdrfdkcz7zdlp"},{"post_id":"cju6jhrsc0002drfd4fq5wlnw","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrtj001idrfd35s8ptuz"},{"post_id":"cju6jhrsc0002drfd4fq5wlnw","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhrtm001ldrfdgqodltp3"},{"post_id":"cju6jhrtf0019drfdpdn9d5ch","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrto001odrfd08svkp4o"},{"post_id":"cju6jhrss000ddrfd3bl91kxb","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrtq001rdrfdzh3uggtj"},{"post_id":"cju6jhrss000ddrfd3bl91kxb","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhrtt001vdrfdn6lcjqhz"},{"post_id":"cju6jhrtg001cdrfdo1hoxag0","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrtv001zdrfd953ugnua"},{"post_id":"cju6jhrsy000hdrfdlrmnpw1c","category_id":"cju6jhrti001edrfdm66taoaw","_id":"cju6jhrtx0023drfd1chb47kh"},{"post_id":"cju6jhrto001qdrfdj54z4xn5","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhrty0027drfde933lyj6"},{"post_id":"cju6jhrsj0006drfdpc6lmqva","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrtz002adrfdc088vu2q"},{"post_id":"cju6jhrsj0006drfdpc6lmqva","category_id":"cju6jhrtm001mdrfdjrp33tds","_id":"cju6jhru0002cdrfdrwo9zos1"},{"post_id":"cju6jhrtt001ydrfdir3f132e","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhru1002edrfdbeuf4hye"},{"post_id":"cju6jhrsl0008drfd4i3pkoo8","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhru2002gdrfdfni5q3ls"},{"post_id":"cju6jhrsl0008drfd4i3pkoo8","category_id":"cju6jhrtr001udrfdiippxrj5","_id":"cju6jhru2002jdrfdm0hoguw8"},{"post_id":"cju6jhrtv0021drfdhna3fwzu","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhru4002mdrfdnre224ob"},{"post_id":"cju6jhrtx0026drfd2x6xmaqn","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhru4002odrfd868d0ftd"},{"post_id":"cju6jhrt5000rdrfd5xmmyi6a","category_id":"cju6jhrtw0022drfdhyw6tals","_id":"cju6jhru5002rdrfdtvk74hu9"},{"post_id":"cju6jhrsn0009drfdocnvtfuz","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhru5002sdrfdxeqmj1io"},{"post_id":"cju6jhrsn0009drfdocnvtfuz","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhru7002vdrfdmzmoggyl"},{"post_id":"cju6jhrt7000tdrfdxgl02cw2","category_id":"cju6jhrtw0022drfdhyw6tals","_id":"cju6jhru7002xdrfdeghqpg3t"},{"post_id":"cju6jhrt8000wdrfdxtc67j0m","category_id":"cju6jhru2002idrfdi04putpj","_id":"cju6jhru90031drfd72mabb4v"},{"post_id":"cju6jhrta0010drfdgukygqaa","category_id":"cju6jhrtw0022drfdhyw6tals","_id":"cju6jhrua0033drfdryy2izeo"},{"post_id":"cju6jhrtd0016drfdo21o9jsx","category_id":"cju6jhru6002tdrfdcswwyti5","_id":"cju6jhrub0036drfdyjvanm9a"},{"post_id":"cju6jhrti001gdrfdjuik4u3f","category_id":"cju6jhru2002idrfdi04putpj","_id":"cju6jhruc0037drfd39lfqpcv"},{"post_id":"cju6jhrtk001kdrfdbwgdajv9","category_id":"cju6jhrub0034drfdat3bn129","_id":"cju6jhrud003ddrfdtugwmmp1"},{"post_id":"cju6jhrtm001ndrfdwqe46blu","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhrue003gdrfd5e8ehgk0"},{"post_id":"cju6jhrtm001ndrfdwqe46blu","category_id":"cju6jhrtr001udrfdiippxrj5","_id":"cju6jhrue003idrfdvdmn3fx4"},{"post_id":"cju6jhrtq001tdrfd0t2xed18","category_id":"cju6jhrub0034drfdat3bn129","_id":"cju6jhruf003jdrfd0dtk05t8"},{"post_id":"cju6jhs5l005wdrfdqalk11ij","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs650065drfdw6ia76us"},{"post_id":"cju6jhs5l005wdrfdqalk11ij","category_id":"cju6jhrtr001udrfdiippxrj5","_id":"cju6jhs6a0068drfdupf4so66"},{"post_id":"cju6jhs5p005zdrfdozvy8q6c","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs6h006bdrfdkh6f3321"},{"post_id":"cju6jhs5p005zdrfdozvy8q6c","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhs6l006edrfdmv7529iy"},{"post_id":"cju6jhs5e005vdrfd9ey6q1x5","category_id":"cju6jhs5o005xdrfdsza47hiq","_id":"cju6jhs6r006hdrfdu62qd0h7"},{"post_id":"cju6jhs600061drfdzjewvj3p","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs6x006kdrfducodmg6t"},{"post_id":"cju6jhs600061drfdzjewvj3p","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhs72006mdrfd9n3ilo2m"},{"post_id":"cju6jhs630063drfd025cdpab","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs75006pdrfdpf01n95o"},{"post_id":"cju6jhs630063drfd025cdpab","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhs75006rdrfdousqf91y"},{"post_id":"cju6jhs670067drfdql55mfih","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs76006tdrfdpr11zz4c"},{"post_id":"cju6jhs670067drfdql55mfih","category_id":"cju6jhrt8000vdrfd10d5mjrq","_id":"cju6jhs77006vdrfd04tqff42"},{"post_id":"cju6jhs6c006adrfdl1clpqp2","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhs77006xdrfdyul6p2hr"},{"post_id":"cju6jhs6j006ddrfdk9cf1hbd","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs78006zdrfdeoablbl8"},{"post_id":"cju6jhs6o006gdrfd6y161ig6","category_id":"cju6jhrso000adrfdkpqw9tql","_id":"cju6jhs790071drfd1j6rwnsm"},{"post_id":"cju6jhs6r006jdrfdbc6ae7d5","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhs790073drfdysncaj83"},{"post_id":"cju6jhsgq007hdrfdfuomrd15","category_id":"cju6jhrsg0004drfdq0st1ktn","_id":"cju6jhsgs007kdrfd80ufndti"}],"PostTag":[{"post_id":"cju6jhrs30000drfdtje771y1","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrsz000idrfdaibzx109"},{"post_id":"cju6jhrs30000drfdtje771y1","tag_id":"cju6jhrso000bdrfdb4a4c4b7","_id":"cju6jhrt1000kdrfdlfwgmrgy"},{"post_id":"cju6jhrsc0002drfd4fq5wlnw","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhrta000zdrfd48i279ma"},{"post_id":"cju6jhrsc0002drfd4fq5wlnw","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhrtb0012drfdzt5b3bto"},{"post_id":"cju6jhrsc0002drfd4fq5wlnw","tag_id":"cju6jhrt5000qdrfdj9o7ah3z","_id":"cju6jhrtd0015drfdgqa2o6ha"},{"post_id":"cju6jhrsj0006drfdpc6lmqva","tag_id":"cju6jhrt9000ydrfd5ipf54a1","_id":"cju6jhrth001ddrfdp0znb0ez"},{"post_id":"cju6jhrsj0006drfdpc6lmqva","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhrtj001hdrfdd5ztkrzc"},{"post_id":"cju6jhrtm001ndrfdwqe46blu","tag_id":"cju6jhrtk001jdrfdq07rgha4","_id":"cju6jhrtq001sdrfd5xfe8mzh"},{"post_id":"cju6jhrtm001ndrfdwqe46blu","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhrtt001wdrfdqwrdok6c"},{"post_id":"cju6jhrsl0008drfd4i3pkoo8","tag_id":"cju6jhrtg001adrfdktsszyck","_id":"cju6jhrtv0020drfdg8cn3nkl"},{"post_id":"cju6jhrsl0008drfd4i3pkoo8","tag_id":"cju6jhrtk001jdrfdq07rgha4","_id":"cju6jhrtx0024drfdt3vcfzpx"},{"post_id":"cju6jhrsl0008drfd4i3pkoo8","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhrtz0028drfd9tschyhe"},{"post_id":"cju6jhrsn0009drfdocnvtfuz","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhru2002hdrfd80szglok"},{"post_id":"cju6jhrsn0009drfdocnvtfuz","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhru3002kdrfd245tzabv"},{"post_id":"cju6jhrsn0009drfdocnvtfuz","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhru4002ndrfdlf59xae2"},{"post_id":"cju6jhrsp000cdrfdfztrn3gd","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhru7002wdrfdmd0besqb"},{"post_id":"cju6jhrsp000cdrfdfztrn3gd","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhru7002ydrfdu5gzwk03"},{"post_id":"cju6jhrsp000cdrfdfztrn3gd","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhrua0032drfdltnogw5w"},{"post_id":"cju6jhrss000ddrfd3bl91kxb","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhrud003adrfdol5eaiq5"},{"post_id":"cju6jhrss000ddrfd3bl91kxb","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhrud003bdrfd1axeczou"},{"post_id":"cju6jhrss000ddrfd3bl91kxb","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhrue003fdrfdknqxlpa5"},{"post_id":"cju6jhrsy000hdrfdlrmnpw1c","tag_id":"cju6jhruc0038drfda8c0ds0p","_id":"cju6jhruf003ldrfd7j6ijg1e"},{"post_id":"cju6jhrsy000hdrfdlrmnpw1c","tag_id":"cju6jhrud003edrfd0iy9wsxc","_id":"cju6jhruf003mdrfdf1cvqz8g"},{"post_id":"cju6jhrsy000hdrfdlrmnpw1c","tag_id":"cju6jhrue003hdrfdyd7jscs9","_id":"cju6jhrug003odrfd3mlix3h7"},{"post_id":"cju6jhrt0000jdrfd02ml5ft6","tag_id":"cju6jhruf003kdrfd816kzg4o","_id":"cju6jhruh003qdrfdrczso3wo"},{"post_id":"cju6jhrt0000jdrfd02ml5ft6","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhruh003rdrfdesfbiyjw"},{"post_id":"cju6jhrt2000ndrfd5xvclr7s","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhruj003udrfd4go3eutp"},{"post_id":"cju6jhrt2000ndrfd5xvclr7s","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhruj003vdrfdm8qaewaf"},{"post_id":"cju6jhrt2000ndrfd5xvclr7s","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhruj003xdrfdjlcx6pmv"},{"post_id":"cju6jhrt3000odrfd59v67ut6","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhruk003zdrfdq5dgiht5"},{"post_id":"cju6jhrt3000odrfd59v67ut6","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhruk0040drfdugzxtg6m"},{"post_id":"cju6jhrt3000odrfd59v67ut6","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhruk0042drfdo490anfr"},{"post_id":"cju6jhrt5000rdrfd5xmmyi6a","tag_id":"cju6jhruj003ydrfdix8hmlt7","_id":"cju6jhrul0044drfdqf4k3waz"},{"post_id":"cju6jhrt5000rdrfd5xmmyi6a","tag_id":"cju6jhruk0041drfd9u9dhnbs","_id":"cju6jhrul0045drfdxt5aephi"},{"post_id":"cju6jhrt7000tdrfdxgl02cw2","tag_id":"cju6jhruj003ydrfdix8hmlt7","_id":"cju6jhruo0048drfd3i2awx77"},{"post_id":"cju6jhrt7000tdrfdxgl02cw2","tag_id":"cju6jhruk0041drfd9u9dhnbs","_id":"cju6jhrup0049drfdnzmsdta8"},{"post_id":"cju6jhrt8000wdrfdxtc67j0m","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhruq004cdrfdad2pjgfz"},{"post_id":"cju6jhrt8000wdrfdxtc67j0m","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhruq004ddrfdy8s5orhv"},{"post_id":"cju6jhrt8000wdrfdxtc67j0m","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrur004fdrfdu3yo62xt"},{"post_id":"cju6jhrta0010drfdgukygqaa","tag_id":"cju6jhruj003ydrfdix8hmlt7","_id":"cju6jhrus004hdrfd83k6pym2"},{"post_id":"cju6jhrta0010drfdgukygqaa","tag_id":"cju6jhruk0041drfd9u9dhnbs","_id":"cju6jhrus004idrfdr7atawhh"},{"post_id":"cju6jhrtb0013drfd2khr09ow","tag_id":"cju6jhrur004gdrfdll9pq7as","_id":"cju6jhruv004ldrfdmxx2kmze"},{"post_id":"cju6jhrtb0013drfd2khr09ow","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhruw004mdrfdt6tsig4n"},{"post_id":"cju6jhrtb0013drfd2khr09ow","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhrux004odrfdvdeztotd"},{"post_id":"cju6jhrtd0016drfdo21o9jsx","tag_id":"cju6jhrut004kdrfde8ubg891","_id":"cju6jhruz004qdrfdsx1hsllj"},{"post_id":"cju6jhrtd0016drfdo21o9jsx","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhruz004rdrfd7oqnv64p"},{"post_id":"cju6jhrtf0019drfdpdn9d5ch","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrv1004tdrfd0nkm0ubc"},{"post_id":"cju6jhrtf0019drfdpdn9d5ch","tag_id":"cju6jhruy004pdrfd1foi8kdk","_id":"cju6jhrv1004udrfdn7e1gdrx"},{"post_id":"cju6jhrtg001cdrfdo1hoxag0","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhrv3004xdrfdmktnvf9l"},{"post_id":"cju6jhrtg001cdrfdo1hoxag0","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrv4004ydrfd27d67rrs"},{"post_id":"cju6jhrtg001cdrfdo1hoxag0","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrv50050drfdiabzgx4s"},{"post_id":"cju6jhrti001gdrfdjuik4u3f","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhrv60052drfdbplbirfo"},{"post_id":"cju6jhrti001gdrfdjuik4u3f","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrv60053drfdcyoyu8o1"},{"post_id":"cju6jhrti001gdrfdjuik4u3f","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrv60055drfdkbct29s2"},{"post_id":"cju6jhrtk001kdrfdbwgdajv9","tag_id":"cju6jhrv50051drfd1b0qw7xd","_id":"cju6jhrv70057drfdti1f37zx"},{"post_id":"cju6jhrtk001kdrfdbwgdajv9","tag_id":"cju6jhrv60054drfd3327xzlg","_id":"cju6jhrv70058drfd0bjl3jcy"},{"post_id":"cju6jhrto001qdrfdj54z4xn5","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhrv8005bdrfds0dj654b"},{"post_id":"cju6jhrto001qdrfdj54z4xn5","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrv8005cdrfdgip4uizv"},{"post_id":"cju6jhrto001qdrfdj54z4xn5","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrv9005edrfd9lvp9qbe"},{"post_id":"cju6jhrtq001tdrfd0t2xed18","tag_id":"cju6jhrv50051drfd1b0qw7xd","_id":"cju6jhrva005gdrfdsbgmj48b"},{"post_id":"cju6jhrtq001tdrfd0t2xed18","tag_id":"cju6jhrv8005ddrfdhmezcyh7","_id":"cju6jhrva005hdrfd3311m3te"},{"post_id":"cju6jhrtt001ydrfdir3f132e","tag_id":"cju6jhruf003kdrfd816kzg4o","_id":"cju6jhrvd005kdrfd94wvsjns"},{"post_id":"cju6jhrtt001ydrfdir3f132e","tag_id":"cju6jhrva005idrfdmqgenvx1","_id":"cju6jhrvx005ldrfd7kplh2zl"},{"post_id":"cju6jhrtv0021drfdhna3fwzu","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhrvz005odrfd2vugwm52"},{"post_id":"cju6jhrtv0021drfdhna3fwzu","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrw0005pdrfdc6os3onx"},{"post_id":"cju6jhrtv0021drfdhna3fwzu","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrw1005rdrfdecjqhdfs"},{"post_id":"cju6jhrtx0026drfd2x6xmaqn","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhrw1005sdrfd7luce30c"},{"post_id":"cju6jhrtx0026drfd2x6xmaqn","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhrw1005tdrfd9hb1oj5r"},{"post_id":"cju6jhrtx0026drfd2x6xmaqn","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhrw1005udrfdi3yy3bbm"},{"post_id":"cju6jhs5l005wdrfdqalk11ij","tag_id":"cju6jhrtg001adrfdktsszyck","_id":"cju6jhs600060drfdh4nhb3jc"},{"post_id":"cju6jhs5l005wdrfdqalk11ij","tag_id":"cju6jhrtk001jdrfdq07rgha4","_id":"cju6jhs630062drfdhuespcyf"},{"post_id":"cju6jhs5l005wdrfdqalk11ij","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs670066drfd4ajt1kve"},{"post_id":"cju6jhs5p005zdrfdozvy8q6c","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhs6b0069drfdkednqqfm"},{"post_id":"cju6jhs5p005zdrfdozvy8q6c","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs6j006cdrfdzrvev7er"},{"post_id":"cju6jhs5p005zdrfdozvy8q6c","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhs6n006fdrfd5228zxt9"},{"post_id":"cju6jhs600061drfdzjewvj3p","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhs6r006idrfdr2rnx5ww"},{"post_id":"cju6jhs600061drfdzjewvj3p","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs71006ldrfdhqyfm9pc"},{"post_id":"cju6jhs600061drfdzjewvj3p","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhs73006odrfd0ppd72ro"},{"post_id":"cju6jhs630063drfd025cdpab","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhs75006qdrfdflczp7ib"},{"post_id":"cju6jhs630063drfd025cdpab","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs76006sdrfd9vxuw944"},{"post_id":"cju6jhs630063drfd025cdpab","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhs76006udrfd33x31y78"},{"post_id":"cju6jhs670067drfdql55mfih","tag_id":"cju6jhrsu000gdrfdw9uqcoyw","_id":"cju6jhs77006wdrfd0f2ajywj"},{"post_id":"cju6jhs670067drfdql55mfih","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs78006ydrfdgqzw8rr0"},{"post_id":"cju6jhs670067drfdql55mfih","tag_id":"cju6jhru0002bdrfdks9pz7n9","_id":"cju6jhs780070drfdkv57b289"},{"post_id":"cju6jhs5e005vdrfd9ey6q1x5","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs790072drfd8vaxgghm"},{"post_id":"cju6jhs5e005vdrfd9ey6q1x5","tag_id":"cju6jhs5o005ydrfd9v0kehfx","_id":"cju6jhs7c0074drfdnhwlkftu"},{"post_id":"cju6jhs5e005vdrfd9ey6q1x5","tag_id":"cju6jhs640064drfd2qjfj3bc","_id":"cju6jhs7e0075drfdilsbe3uw"},{"post_id":"cju6jhs6c006adrfdl1clpqp2","tag_id":"cju6jhrug003pdrfdqlr9b8xm","_id":"cju6jhs7e0076drfdoeactcop"},{"post_id":"cju6jhs6c006adrfdl1clpqp2","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhs7f0077drfdbxgd50ex"},{"post_id":"cju6jhs6c006adrfdl1clpqp2","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhs7f0078drfdi1nqj4lx"},{"post_id":"cju6jhs6j006ddrfdk9cf1hbd","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs7h0079drfdogtdzguj"},{"post_id":"cju6jhs6j006ddrfdk9cf1hbd","tag_id":"cju6jhs640064drfd2qjfj3bc","_id":"cju6jhs7k007adrfd2ckyvobi"},{"post_id":"cju6jhs6o006gdrfd6y161ig6","tag_id":"cju6jhrtk001jdrfdq07rgha4","_id":"cju6jhs7l007bdrfdf5pd2fwx"},{"post_id":"cju6jhs6o006gdrfd6y161ig6","tag_id":"cju6jhs640064drfd2qjfj3bc","_id":"cju6jhs7l007cdrfdt319yl3z"},{"post_id":"cju6jhs6o006gdrfd6y161ig6","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhs7m007ddrfdr7cmz9ri"},{"post_id":"cju6jhs6r006jdrfdbc6ae7d5","tag_id":"cju6jhs72006ndrfd1814mhx5","_id":"cju6jhs7m007edrfdek2h1vx9"},{"post_id":"cju6jhs6r006jdrfdbc6ae7d5","tag_id":"cju6jhrsi0005drfdzkr9742i","_id":"cju6jhs7m007fdrfd0f7j5an2"},{"post_id":"cju6jhs6r006jdrfdbc6ae7d5","tag_id":"cju6jhrui003sdrfd0b7z05hs","_id":"cju6jhs7n007gdrfdiokkb049"},{"post_id":"cju6jhsgq007hdrfdfuomrd15","tag_id":"cju6jhruf003kdrfd816kzg4o","_id":"cju6jhsgs007idrfdup0liojk"},{"post_id":"cju6jhsgq007hdrfdfuomrd15","tag_id":"cju6jhrt2000mdrfdm51rkfpo","_id":"cju6jhsgs007jdrfd8cii5z2i"}],"Tag":[{"name":"生活","_id":"cju6jhrsi0005drfdzkr9742i"},{"name":"未来","_id":"cju6jhrso000bdrfdb4a4c4b7"},{"name":"underscore","_id":"cju6jhrsu000gdrfdw9uqcoyw"},{"name":"前端","_id":"cju6jhrt2000mdrfdm51rkfpo"},{"name":"模板引擎","_id":"cju6jhrt5000qdrfdj9o7ah3z"},{"name":"TypeScript","_id":"cju6jhrt9000ydrfd5ipf54a1"},{"name":"redux","_id":"cju6jhrtg001adrfdktsszyck"},{"name":"react","_id":"cju6jhrtk001jdrfdq07rgha4"},{"name":"编程","_id":"cju6jhru0002bdrfdks9pz7n9"},{"name":"影评","_id":"cju6jhruc0038drfda8c0ds0p"},{"name":"观后感","_id":"cju6jhrud003edrfd0iy9wsxc"},{"name":"个人笔记","_id":"cju6jhrue003hdrfdyd7jscs9"},{"name":"读书笔记","_id":"cju6jhruf003kdrfd816kzg4o"},{"name":"思考","_id":"cju6jhrug003pdrfdqlr9b8xm"},{"name":"随笔","_id":"cju6jhrui003sdrfd0b7z05hs"},{"name":"工作","_id":"cju6jhruj003ydrfdix8hmlt7"},{"name":"周报","_id":"cju6jhruk0041drfd9u9dhnbs"},{"name":"polyfill","_id":"cju6jhrur004gdrfdll9pq7as"},{"name":"理财","_id":"cju6jhrut004kdrfde8ubg891"},{"name":"理想","_id":"cju6jhruy004pdrfd1foi8kdk"},{"name":"歌曲","_id":"cju6jhrv50051drfd1b0qw7xd"},{"name":"电影","_id":"cju6jhrv60054drfd3327xzlg"},{"name":"陈升","_id":"cju6jhrv8005ddrfdhmezcyh7"},{"name":"说话技巧","_id":"cju6jhrva005idrfdmqgenvx1"},{"name":"函数式编程","_id":"cju6jhs5o005ydrfd9v0kehfx"},{"name":"javascript","_id":"cju6jhs640064drfd2qjfj3bc"},{"name":"毕业","_id":"cju6jhs72006ndrfd1814mhx5"}]}}