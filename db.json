{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ETH.png","path":"images/ETH.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/xiong.jpg","path":"images/xiong.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/zhihu.svg","path":"images/zhihu.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/touxiang.png","path":"images/touxiang.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1542188820865},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1542188820865},{"_id":"source/CNAME","hash":"c9e531ba4730789adf382049ec17de18a3756492","modified":1542188820854},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1542188820865},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1542188820866},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1542188820866},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1542188820866},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1542188820866},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1542188820866},{"_id":"themes/hexo-theme-next/README.md","hash":"85696981852ac088cb711444b4b2446824060a74","modified":1542188820866},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1542188820866},{"_id":"themes/hexo-theme-next/_config.yml","hash":"b57904570e9d220fa0002ddb3ede318a3771a58f","modified":1542188820867},{"_id":"themes/hexo-theme-next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1542188820867},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1542188820867},{"_id":"themes/hexo-theme-next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1542188820882},{"_id":"source/_posts/60行代码实现模板引擎.md","hash":"132732a5c0317013515d64ba0367d693a6b55f90","modified":1542886217335},{"_id":"source/_posts/TypeScript踩坑（持续更新）.md","hash":"e43d95e4875e7cdb4f5eda04a3bc363c67eb7e52","modified":1542887210064},{"_id":"source/_posts/JS函数柯里化.md","hash":"c151a2731aafc178a9e4a149460155171bfdae51","modified":1542886222968},{"_id":"source/_posts/react状态管理.md","hash":"685ffb9b78730c32cedb4fa16533389d3bdab49d","modified":1542886227184},{"_id":"source/_posts/underscore debounce防抖动函数分析.md","hash":"82f93a9c437ce66ab7de2e7b38918f30ea2a9757","modified":1542886208917},{"_id":"source/_posts/redux源码分析.md","hash":"6423b84557feace8cb3cf273f686dda5505084cc","modified":1542886232024},{"_id":"source/_posts/underscore查找索引函数分析.md","hash":"2dde3a6b4e46753b580b9905f9a9722a07cd59fb","modified":1542886246164},{"_id":"source/_posts/underscore源码剖析之基础方法.md","hash":"3581bc13f2db80904b92d50dda0410cffdaff560","modified":1542886250163},{"_id":"source/_posts/underscore throttle节流函数分析.md","hash":"80c6dfec5eeccc8da3787b5010573e01c056812a","modified":1542886242660},{"_id":"source/_posts/underscore源码剖析之数组遍历函数分析（一）.md","hash":"12a9b8daf1a809e1854dd0bafa7b6fa6c2fa5e4c","modified":1542886253513},{"_id":"source/_posts/《守望者》观后感.md","hash":"58b01025c2bdaf85ef4c23b2fbb82a80243be547","modified":1542188820856},{"_id":"source/_posts/underscore源码剖析之整体架构.md","hash":"3ec55881fa6afcef671db89796f9fab0cc058cb6","modified":1542886259714},{"_id":"source/_posts/underscore源码剖析之数组遍历函数分析（二）.md","hash":"be8b5c019ebebbc67663fcff820e1a79bf8d1d34","modified":1542886256058},{"_id":"source/_posts/《编写可维护的JS》笔记.md","hash":"4211c531f764731a27f4217a29c1a25495175f84","modified":1542189086424},{"_id":"source/_posts/塞尔达传说.md","hash":"bc4ed77df08e7c03f008e55eac2f477573cd76e1","modified":1542886157719},{"_id":"source/_posts/世界变了样.md","hash":"a4b538e308dd2f4abd87b549d25ae9716b105cc8","modified":1542189359358},{"_id":"source/_posts/实现一个bind函数.md","hash":"d5701a381582ef2f620cc860450d89c1ba983517","modified":1542886138681},{"_id":"source/_posts/富爸爸穷爸爸.md","hash":"22beb947acbc8b47a0a60789996fc701c381e040","modified":1542886145267},{"_id":"source/_posts/梦境小说.md","hash":"34ece6bbf10ce7d957d8e8fddc14a22bf48f9482","modified":1542886151574},{"_id":"source/_posts/流光飞舞.md","hash":"3ebf637919c2750888a65e404980d1ac71c0205c","modified":1542188820857},{"_id":"source/_posts/毕业二三事.md","hash":"e1a7045b0070403cc13f8d999939aab4b455e47c","modified":1542188820857},{"_id":"source/_posts/深夜思考.md","hash":"1e7f4466fa30727f7397b0ed12f9c906c30138a9","modified":1542188820858},{"_id":"source/_posts/牡丹亭外.md","hash":"c4a403273df72db7943c9983aaa9cd44995d39ac","modified":1542188820858},{"_id":"source/_posts/蔡康永的说话之道.md","hash":"21c9b19528d5eadc5422614348775c1654756262","modified":1542188820858},{"_id":"source/about/index.md","hash":"920ac47fc28038916fcc3563accb32fa7108eedd","modified":1542188820859},{"_id":"source/_posts/管理自己.md","hash":"18941f32691cb6636dfc6360d1aacafa07314102","modified":1542886171546},{"_id":"source/categories/index.md","hash":"9c91e1f2691983972809aee61d8c885f57b0f59d","modified":1542188820859},{"_id":"source/tags/index.md","hash":"f8c454c224e54f009dd469e924776f826a73a2d2","modified":1542188820859},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1542188820867},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1542188820867},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1542188820867},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1542188820867},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1542188820868},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1542188820869},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1542188820869},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1542188820869},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1542188820869},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"e3e9c6963f9f7eb6b20102a5c3c99939282dc4b9","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1542188820882},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1542188820882},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1542188820882},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1542188820882},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1542188820945},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1542188820945},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1542188820945},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820903},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1542188820869},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1542188820869},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1542188820870},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"12e53bfcfb3f9a86fc202264ba54d6ccbd121059","modified":1542189551547},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1542188820880},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1542188820880},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1542188820880},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1542188820882},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1542188820883},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1542188820884},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1542188820884},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/images/ETH.png","hash":"a7c437c9c0037cd178025f638e51f72ca7e0abe9","modified":1542188820904},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1542188820904},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1542188820905},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1542188820905},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1542188820905},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1542188820905},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1542188820906},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1542188820907},{"_id":"themes/hexo-theme-next/source/images/xiong.jpg","hash":"9c3b2868bb9ec01e05ea334ec8f55cb377ea1027","modified":1542188820910},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","hash":"7d901488caf7480a49f24de97e8a18ec607b94db","modified":1542188820910},{"_id":"themes/hexo-theme-next/source/images/zhihu.svg","hash":"10d7e2940861c8cb5ab45480d1c9d24dac4f08e5","modified":1542188820910},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820873},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","hash":"5eb0ecf461d58f9aa862b7d42a9106ec9ea771f4","modified":1542188820905},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1542188820871},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1542188820872},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1542188820873},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1542188820874},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1542188820875},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1542188820875},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1542188820875},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1542188820875},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1542188820876},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1542188820876},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1542188820876},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1542188820877},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1542188820877},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1542188820877},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1542188820877},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1542188820878},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1542188820878},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1542188820878},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1542188820878},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1542188820878},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1542188820879},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1542188820880},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1542188820880},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1542188820881},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1542188820881},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1542188820898},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1542188820903},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1542188820910},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1542188820910},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1542188820911},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1542188820912},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1542188820912},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1542188820912},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1542188820915},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1542188820918},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1542188820918},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1542188820918},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1542188820918},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1542188820921},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1542188820921},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1542188820922},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1542188820922},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1542188820921},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1542188820923},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1542188820922},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1542188820923},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1542188820923},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1542188820932},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1542188820933},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1542188820933},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1542188820933},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1542188820934},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1542188820933},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1542188820933},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1542188820934},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1542188820934},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1542188820934},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1542188820935},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1542188820935},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1542188820935},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1542188820935},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1542188820935},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1542188820936},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1542188820936},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1542188820936},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1542188820936},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1542188820936},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1542188820937},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1542188820937},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1542188820937},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1542188820937},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1542188820938},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1542188820942},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1542188820938},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1542188820938},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1542188820942},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1542188820944},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1542188820944},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1542188820944},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542188820933},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1542188820880},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1542188820880},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1542188820896},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1542188820884},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1542188820884},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1542188820884},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1542188820884},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1542188820892},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"19dccf83801b12885b2cac684f4917bb72730f4f","modified":1542188820896},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1542188820897},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1542188820897},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1542188820897},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1542188820897},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1542188820897},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1542188820899},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1542188820899},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1542188820899},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1542188820899},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1542188820899},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1542188820900},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1542188820900},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1542188820900},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1542188820901},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1542188820901},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1542188820901},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1542188820901},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1542188820912},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1542188820915},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1542188820918},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1542188820915},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1542188820921},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1542188820922},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1542188820922},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1542188820924},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"7aeb7a3d248bb60f4db84e34a8aa7b394c1bf5bb","modified":1542188820923},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"90d46921c8d5bafb0d35ee0a541c67f350361e16","modified":1542188820924},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1542188820942},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1542188820942},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1542188820914},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1542188820915},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1542188820931},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1542188820943},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1542188820885},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1542188820886},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1542188820886},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1542188820886},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1542188820886},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1542188820887},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1542188820890},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1542188820891},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1542188820891},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1542188820891},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1542188820891},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1542188820891},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1542188820892},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1542188820892},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1542188820892},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1542188820892},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1542188820888},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1542188820889},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1542188820889},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1542188820889},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1542188820889},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1542188820889},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1542188820890},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1542188820890},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1542188820890},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1542188820890},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1542188820893},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1542188820894},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1542188820894},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1542188820894},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1542188820894},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1542188820895},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1542188820896},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1542188820896},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1542188820896},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1542188820900},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1542188820900},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1542188820902},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1542188820913},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1542188820913},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1542188820913},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1542188820914},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1542188820919},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1542188820932},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1542188820914},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1542188820920},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1542188820925},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1542188820927},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1542188820931},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1542188820917},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1542188820941},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1542188820929},{"_id":"themes/hexo-theme-next/source/images/touxiang.png","hash":"770a14f49e21642e06d6f032e10870159ecada5b","modified":1542188820909},{"_id":"public/about/index.html","hash":"6201702d73ca88b83824c11de4aaafa295c902ec","modified":1542887226139},{"_id":"public/categories/index.html","hash":"9c297a3cbdee3d2b7ba4b5df0e0e3e4b7c7dd133","modified":1542887226139},{"_id":"public/tags/index.html","hash":"c73900a2e2855af53d008defbc6a01e15bc0fa69","modified":1542887226139},{"_id":"public/2018/10/14/塞尔达传说/index.html","hash":"22971747897a03e47cf017712a91b30fbcf35af9","modified":1542887226140},{"_id":"public/2018/09/25/世界变了样/index.html","hash":"8ae6e823e90c08573f449ff868aad1e6fbbb62a9","modified":1542887226140},{"_id":"public/2018/07/15/管理自己/index.html","hash":"2ebb871a0da467bc5d333dd8c45037104ba6c6c3","modified":1542887226140},{"_id":"public/2018/07/07/《编写可维护的JS》笔记/index.html","hash":"379a62e588b5d5172fc211914e7db8391ad94a07","modified":1542887226140},{"_id":"public/2018/05/30/实现一个bind函数/index.html","hash":"37833644196f505aa3cca81be1ee80a78e0c3d8e","modified":1542887226140},{"_id":"public/2018/05/09/JS函数柯里化/index.html","hash":"aa26bc467b5922ad27cab685d68b2068d880b18d","modified":1542887226140},{"_id":"public/2018/04/24/60行代码实现模板引擎/index.html","hash":"e731bb710ecab407ad2c89571af1949822fb8771","modified":1542887226140},{"_id":"public/2018/04/19/富爸爸穷爸爸/index.html","hash":"be6c15d7b80f39de2ecb7bf06e935f0b4128fe16","modified":1542887226140},{"_id":"public/2018/04/18/牡丹亭外/index.html","hash":"b1d0aca71ae577d702a3a79e286da40a04189f26","modified":1542887226140},{"_id":"public/2018/03/25/underscore查找索引函数分析/index.html","hash":"368a90cfbdb421eac712d80ff24fbaa6bd332860","modified":1542887226140},{"_id":"public/2018/03/23/underscore debounce防抖动函数分析/index.html","hash":"35bac9656eadf2dd4bf2ec04b12c7f550fe9cabd","modified":1542887226140},{"_id":"public/2018/03/22/underscore throttle节流函数分析/index.html","hash":"6eae4e8d58e625a282be7da55fc4033d96d0b6b3","modified":1542887226140},{"_id":"public/2018/03/20/underscore源码剖析之数组遍历函数分析（二）/index.html","hash":"ea470cb09bb52d2689a0e8099b90bbc9160cfdf6","modified":1542887226140},{"_id":"public/2018/03/19/深夜思考/index.html","hash":"650c8dcbb4885ef0b2dec7b8eaf0419f20767890","modified":1542887226140},{"_id":"public/2018/03/19/underscore源码剖析之数组遍历函数分析（一）/index.html","hash":"5074b8996ba88972450518401717a2d951ad2423","modified":1542887226140},{"_id":"public/2018/03/16/underscore源码剖析之整体架构/index.html","hash":"c61777a53df33965f5f6cb3499a62918f166af16","modified":1542887226140},{"_id":"public/2018/03/10/流光飞舞/index.html","hash":"cf3a271e021b682ddc6bee072308ff430f04102a","modified":1542887226140},{"_id":"public/2018/02/21/《守望者》观后感/index.html","hash":"d2b4348b4ee279ae289aba93c993e8245b31811b","modified":1542887226140},{"_id":"public/2017/10/04/蔡康永的说话之道/index.html","hash":"96774b46fe762750036f0c446fee097a5078da92","modified":1542887226140},{"_id":"public/2017/07/01/毕业二三事/index.html","hash":"c13a22ec73f63aeef4b2b74551e725a61a7a8dca","modified":1542887226140},{"_id":"public/2015/04/19/梦境小说/index.html","hash":"12302df46eaca2413a2a480944359b8a3004b77f","modified":1542887226141},{"_id":"public/categories/underscore/index.html","hash":"2baf14bc25c7c4068cd972c2719de16dcba97d7d","modified":1542887226141},{"_id":"public/categories/underscore/page/2/index.html","hash":"3b677925ca7fdb6026f756cacbb6b52d757f34b1","modified":1542887226141},{"_id":"public/categories/电影/index.html","hash":"881d3cac26462cfb581f298962cb3bb420b4792d","modified":1542887226141},{"_id":"public/categories/underscore/前端/index.html","hash":"57c35d5bf301088bba7134c8adea88d267522009","modified":1542887226141},{"_id":"public/categories/underscore/前端/page/2/index.html","hash":"8a21816afe194247eb200c5f34b61bf2acc2f866","modified":1542887226141},{"_id":"public/categories/前端/index.html","hash":"0a3f73d2bec18fb6f3d5017ae468d5ebb0fdd9de","modified":1542887226141},{"_id":"public/categories/小说/index.html","hash":"674db74fadfc8211ce4c24f057cec76941a0ee8c","modified":1542887226141},{"_id":"public/categories/生活/index.html","hash":"27e6ac59f02809df68e9e9fe6a194cf5b21db599","modified":1542887226141},{"_id":"public/categories/理财/index.html","hash":"4e860a0a85c482a0a18fa1a43cf9b2af54fb151e","modified":1542887226141},{"_id":"public/categories/音乐/index.html","hash":"9a19977448ae5bb8302105986c1728074eb6e850","modified":1542887226141},{"_id":"public/categories/个人笔记/index.html","hash":"d1ce913773c40ff100794375d596fb655e80ea06","modified":1542887226141},{"_id":"public/categories/函数式编程/index.html","hash":"09984cf77b0e68cb23a4a2ea29c33a5b3795a028","modified":1542887226141},{"_id":"public/categories/函数式编程/前端/index.html","hash":"c36638e116a6f2efd58f6ac57843948576e38910","modified":1542887226141},{"_id":"public/categories/转载/index.html","hash":"b3fc1dae48f9647542cfc4c4440050a8aae1ea6c","modified":1542887226142},{"_id":"public/archives/index.html","hash":"c3d836d3f28bcee5a438d14406dfb0e9a780b151","modified":1542887226142},{"_id":"public/archives/page/2/index.html","hash":"1aedecf13ceb7c380358554b6e0a7d31c9e7c480","modified":1542887226142},{"_id":"public/archives/page/3/index.html","hash":"62b87e578e5f7e3e3b16613790a121558c8b2b13","modified":1542887226142},{"_id":"public/archives/page/4/index.html","hash":"d5fce13bb3288f0a7c973c627a0758dda25d8214","modified":1542887226142},{"_id":"public/archives/page/5/index.html","hash":"2ba9b744e579a6710745ddf7e308d35f7a738c66","modified":1542887226142},{"_id":"public/archives/2015/index.html","hash":"05fb7310e29e13265a5c2200061b1d255ab298ee","modified":1542887226142},{"_id":"public/archives/2015/04/index.html","hash":"e5cc92e39418057573e16491ed31b4246678b32c","modified":1542887226142},{"_id":"public/archives/2017/index.html","hash":"ded1adb6139eee9252dc80b8832608d16779807a","modified":1542887226142},{"_id":"public/archives/2017/07/index.html","hash":"62a73f3b42b70473b52eb056a452658afd9e4312","modified":1542887226142},{"_id":"public/archives/2017/10/index.html","hash":"d60e3df9f17e32f494b0c42676a352fec1a725ac","modified":1542887226142},{"_id":"public/archives/2018/index.html","hash":"f499d12e871044f006a04aef294af0baf72b3396","modified":1542887226143},{"_id":"public/archives/2018/page/2/index.html","hash":"48aceb822dcb2d5019b6f29b4fd048e7f67f958e","modified":1542887226143},{"_id":"public/archives/2018/page/3/index.html","hash":"dbafb2d28ee501bb7db27af62797ebc75751d9f0","modified":1542887226143},{"_id":"public/archives/2018/page/4/index.html","hash":"c27fdccf48e4e7e6f2994c824bc2e2bc87b0803f","modified":1542887226143},{"_id":"public/archives/2018/02/index.html","hash":"9fa65abb1435f9cfd2ce01b16cb1b3659d385c19","modified":1542887226143},{"_id":"public/archives/2018/03/index.html","hash":"8271182fd704d75a0ec28c0d84737169f9af7ce3","modified":1542887226143},{"_id":"public/archives/2018/03/page/2/index.html","hash":"e97430227f040471999a37e962f4a9f674f27474","modified":1542887226143},{"_id":"public/archives/2018/04/index.html","hash":"c90ac56bf66f2f114a4949459bb0b554cd2112d7","modified":1542887226143},{"_id":"public/archives/2018/05/index.html","hash":"4b5268862f5d2a7ff798ef75a7099c9c2ad528b6","modified":1542887226143},{"_id":"public/archives/2018/07/index.html","hash":"ad1b98a436acf280ec03e95391467974c3d7d66c","modified":1542887226143},{"_id":"public/archives/2018/09/index.html","hash":"e26df9fd440850aeafd6b17be097b45fcc999dca","modified":1542887226143},{"_id":"public/archives/2018/10/index.html","hash":"b63e665cbd4cb9ddd6a61e3a1b428e1c5390e3ba","modified":1542887226143},{"_id":"public/index.html","hash":"8040fbe31da27af8b2b2d3ff64ca1f86a64a3ae3","modified":1542887226143},{"_id":"public/page/2/index.html","hash":"f3ebec745c9d537c82b09f1e77bf965dc8687ebd","modified":1542887226143},{"_id":"public/page/3/index.html","hash":"f5f63768ded585911d6da7a7c8cda15c4979fc52","modified":1542887226143},{"_id":"public/page/4/index.html","hash":"22686f06a0f5652de1f8334c2027824360c292d5","modified":1542887226144},{"_id":"public/page/5/index.html","hash":"3b4443e4428ebccb86b177c9efb720512c337dc5","modified":1542887226144},{"_id":"public/tags/underscore/index.html","hash":"9955aa7e756f5ef0eb2970584f7566c317a3be8a","modified":1542887226144},{"_id":"public/tags/underscore/page/2/index.html","hash":"23026981139f87e4d9a651b7c6a12051bd5f49f0","modified":1542887226144},{"_id":"public/tags/前端/index.html","hash":"4ba9a27f24d49609848c49df648340cd35c8da8f","modified":1542887226144},{"_id":"public/tags/前端/page/2/index.html","hash":"8ba3cd29e4b5b3066c7fd21c9ffece38cd23925a","modified":1542887226144},{"_id":"public/tags/前端/page/3/index.html","hash":"9e9dbc3313d6b8f134b44361642600b81bf9ec06","modified":1542887226144},{"_id":"public/tags/模板引擎/index.html","hash":"e591f410ba5a81f6ab40c7d7c258b37fcb8a0f8d","modified":1542887226144},{"_id":"public/tags/编程/index.html","hash":"aad98749799d1813fb7301f93b90737094f06b54","modified":1542887226144},{"_id":"public/tags/编程/page/2/index.html","hash":"795e68bfc5c7be53b8ad7acce0460a351ac8ee7c","modified":1542887226144},{"_id":"public/tags/电影/index.html","hash":"e257f69e78f79acc1c70a1d6ea40bc08a6d8c380","modified":1542887226144},{"_id":"public/tags/观后感/index.html","hash":"142f871938377f18e1a8940d5a1840e6b572f561","modified":1542887226144},{"_id":"public/tags/个人笔记/index.html","hash":"8b377f6e32f454da0a60e092da1fdb7165630b35","modified":1542887226144},{"_id":"public/tags/读书笔记/index.html","hash":"df4bc6e0992d021e731181a7953a6bf45247f6c5","modified":1542887226144},{"_id":"public/tags/思考/index.html","hash":"952b6caff0888a816e78ec609866c8ab6f2b6669","modified":1542887226145},{"_id":"public/tags/生活/index.html","hash":"e7a551bc1187a932f888465293b028a0e57f539f","modified":1542887226145},{"_id":"public/tags/随笔/index.html","hash":"6cd41dd4decc9e79d16492b4f3264dd2f92df296","modified":1542887226145},{"_id":"public/tags/polyfill/index.html","hash":"61479ebe84d7e77b9e0ee5a44edf55ea44571b80","modified":1542887226145},{"_id":"public/tags/理财/index.html","hash":"764d80e8dfb583ebe25235d70432b4a12f85e3e8","modified":1542887226145},{"_id":"public/tags/歌曲/index.html","hash":"113650940fa454da088d28799cd715949db1a0b3","modified":1542887226145},{"_id":"public/tags/陈升/index.html","hash":"3a5f2961e3eb9fac8fba54df207f315ab2658c95","modified":1542887226145},{"_id":"public/tags/说话技巧/index.html","hash":"7e3990aa14b1096cde12e001e2feb1abadceb91f","modified":1542887226145},{"_id":"public/tags/函数式编程/index.html","hash":"0fc41d4686663f823f319f25300aa32b2f512f57","modified":1542887226145},{"_id":"public/tags/javascript/index.html","hash":"c5a226b8b850bf848cf1dcf042137f7c59e87ac7","modified":1542887226145},{"_id":"public/tags/毕业/index.html","hash":"5e2b9c2d1065eff7a50f564320f9dbe1fa413af5","modified":1542887226145},{"_id":"public/CNAME","hash":"c9e531ba4730789adf382049ec17de18a3756492","modified":1542887226153},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1542887226153},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1542887226153},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1542887226153},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1542887226153},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1542887226153},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1542887226153},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1542887226153},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1542887226153},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1542887226153},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1542887226154},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1542887226154},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542887226154},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1542887226154},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1542887226154},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542887226154},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1542887226154},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1542887226154},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1542887226154},{"_id":"public/images/xiong.jpg","hash":"9c3b2868bb9ec01e05ea334ec8f55cb377ea1027","modified":1542887226154},{"_id":"public/images/wechatpay.png","hash":"7d901488caf7480a49f24de97e8a18ec607b94db","modified":1542887226154},{"_id":"public/images/zhihu.svg","hash":"10d7e2940861c8cb5ab45480d1c9d24dac4f08e5","modified":1542887226154},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1542887226154},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1542887226154},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1542887226154},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1542887226154},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1542887226154},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1542887226154},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1542887226154},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1542887226154},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1542887226155},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1542887226155},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1542887226155},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1542887226155},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1542887226155},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1542887226155},{"_id":"public/images/ETH.png","hash":"a7c437c9c0037cd178025f638e51f72ca7e0abe9","modified":1542887226668},{"_id":"public/images/alipay.jpg","hash":"5eb0ecf461d58f9aa862b7d42a9106ec9ea771f4","modified":1542887226668},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1542887226672},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1542887226672},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1542887226672},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1542887226680},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1542887226680},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1542887226680},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1542887226680},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1542887226680},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1542887226681},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1542887226681},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1542887226681},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1542887226681},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1542887226681},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1542887226681},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1542887226681},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1542887226681},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1542887226681},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1542887226681},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1542887226681},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1542887226681},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1542887226681},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1542887226681},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1542887226681},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1542887226681},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1542887226682},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1542887226682},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1542887226682},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1542887226682},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1542887226682},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1542887226683},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1542887226683},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1542887226683},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1542887226683},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1542887226683},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1542887226683},{"_id":"public/css/main.css","hash":"f933eb33ecda7d460f00079356838cab811e1205","modified":1542887226683},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1542887226683},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1542887226683},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1542887226683},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1542887226692},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1542887226692},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1542887226692},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1542887226692},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1542887226692},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1542887226692},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1542887226692},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1542887226693},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1542887226696},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1542887226696},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1542887226702},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"90d46921c8d5bafb0d35ee0a541c67f350361e16","modified":1542887226703},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1542887226713},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1542887226713},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1542887226714},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1542887226714},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1542887226714},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1542887226714},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"7aeb7a3d248bb60f4db84e34a8aa7b394c1bf5bb","modified":1542887226714},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1542887226730},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1542887226730},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1542887226734},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1542887226741},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1542887226743},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1542887226751},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542887226757},{"_id":"public/images/touxiang.png","hash":"770a14f49e21642e06d6f032e10870159ecada5b","modified":1542887226762},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1542887226763},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1542887226770},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1542887226773}],"Category":[{"name":"underscore","_id":"cjosj7rx40004fpzxg86oflu5"},{"name":"电影","_id":"cjosj7rxj000efpzx2r07esee"},{"name":"前端","parent":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rxo000ifpzxgr436pye"},{"name":"前端","_id":"cjosj7rxx000ufpzxoy5cza35"},{"name":"小说","_id":"cjosj7rxz0010fpzxgal4tg9k"},{"name":"生活","_id":"cjosj7ry00019fpzxn3ji9x0z"},{"name":"理财","_id":"cjosj7ry2001hfpzxvn0m03by"},{"name":"音乐","_id":"cjosj7ry4001rfpzx8gcw69sh"},{"name":"个人笔记","_id":"cjosj7ry80023fpzxhdgpfp68"},{"name":"函数式编程","_id":"cjosj7rz5003gfpzxvtj0rio9"},{"name":"前端","parent":"cjosj7rz5003gfpzxvtj0rio9","_id":"cjosj7rza003rfpzxr6sjeakn"},{"name":"转载","_id":"cjosj7s2t004jfpzxs7d8d94t"},{"name":"TypeScript","_id":"cjosj8gqq0001fszxx2w3v47f"},{"name":"react","_id":"cjosj9bx10007fszxlgxvhu3q"}],"Data":[],"Page":[{"title":"关于我","date":"2018-04-18T11:21:24.000Z","_content":"## 学生生涯 ##\n2017年7月我从武汉大学毕业，整整17年的学生生涯结束了，学生时代我学到了很多东西，这些让我受益终生。\n## 程序员 ##\n大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员，人比较宅、死板，写了两年前端，热爱技术，现在还处于初级前端级别。\n## 生活 ##\n我最大的爱好就是吃吃吃，但我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，热爱生活。\n一个人生活了太久，有点内向，不太合群，但还是希望能多接触到不同的人和外面的世界。有些小文艺，偶尔会去外面拍照，喜欢听粤语歌和老歌，被同事调侃已经是个老年人。","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-04-18 19:21:24\n---\n## 学生生涯 ##\n2017年7月我从武汉大学毕业，整整17年的学生生涯结束了，学生时代我学到了很多东西，这些让我受益终生。\n## 程序员 ##\n大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员，人比较宅、死板，写了两年前端，热爱技术，现在还处于初级前端级别。\n## 生活 ##\n我最大的爱好就是吃吃吃，但我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，热爱生活。\n一个人生活了太久，有点内向，不太合群，但还是希望能多接触到不同的人和外面的世界。有些小文艺，偶尔会去外面拍照，喜欢听粤语歌和老歌，被同事调侃已经是个老年人。","updated":"2018-11-14T09:47:00.859Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjosj7rwz0001fpzxym1x0xr8","content":"<h2 id=\"学生生涯\"><a href=\"#学生生涯\" class=\"headerlink\" title=\"学生生涯\"></a>学生生涯</h2><p>2017年7月我从武汉大学毕业，整整17年的学生生涯结束了，学生时代我学到了很多东西，这些让我受益终生。</p>\n<h2 id=\"程序员\"><a href=\"#程序员\" class=\"headerlink\" title=\"程序员\"></a>程序员</h2><p>大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员，人比较宅、死板，写了两年前端，热爱技术，现在还处于初级前端级别。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>我最大的爱好就是吃吃吃，但我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，热爱生活。<br>一个人生活了太久，有点内向，不太合群，但还是希望能多接触到不同的人和外面的世界。有些小文艺，偶尔会去外面拍照，喜欢听粤语歌和老歌，被同事调侃已经是个老年人。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学生生涯\"><a href=\"#学生生涯\" class=\"headerlink\" title=\"学生生涯\"></a>学生生涯</h2><p>2017年7月我从武汉大学毕业，整整17年的学生生涯结束了，学生时代我学到了很多东西，这些让我受益终生。</p>\n<h2 id=\"程序员\"><a href=\"#程序员\" class=\"headerlink\" title=\"程序员\"></a>程序员</h2><p>大学时期我学的是软件工程专业，毕业后也理所当然的做了一名程序员，人比较宅、死板，写了两年前端，热爱技术，现在还处于初级前端级别。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>我最大的爱好就是吃吃吃，但我想吃什么就会自己做什么，做饭给自己吃是最快乐的事情了。由于宅了太久，生活比较单调，现在正在努力改变状态，热爱生活。<br>一个人生活了太久，有点内向，不太合群，但还是希望能多接触到不同的人和外面的世界。有些小文艺，偶尔会去外面拍照，喜欢听粤语歌和老歌，被同事调侃已经是个老年人。</p>\n"},{"title":"categories","date":"2018-04-18T11:21:33.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-18 19:21:33\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-14T09:47:00.859Z","path":"categories/index.html","layout":"page","_id":"cjosj7rx20003fpzxzb6tc82h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-04-18T11:21:16.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-18 19:21:16\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-14T09:47:00.859Z","path":"tags/index.html","layout":"page","_id":"cjosj7rx90007fpzxyx8k8uy3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"60行代码实现模板引擎","date":"2018-04-24T02:35:40.000Z","_content":"不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：[只有20行的Javascript模板引擎][1]\n这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。\n但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。\n恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。\n这个是我参考template后实现的模板，一共只有60行代码。\n<!-- more -->\n```\n(function () {\n    var root = this;\n    // 将字符串中的HTML实体字符转义，可以有效减少xss风险\n    var html2Entity = (function () {\n        var escapeMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '`': '&#x60;'\n        };\n        var escaper = function (match) {\n            return escapeMap[match];\n        };\n        return function (string) {\n            var source = \"(\" + Object.keys(escapeMap).join(\"|\") + \")\";\n            var regexp = RegExp(source), regexpAll = RegExp(source, \"g\");\n            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;\n        }\n    }())\n    // 字符串中的转义字符\n    var escapes = {\n        '\"': '\"',\n        \"'\": \"'\",\n        \"\\\\\": \"\\\\\",\n        '\\n': 'n',\n        '\\r': 'r',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    }\n    var escaper = /\\\\|'|\"|\\r|\\n|\\u2028|\\u2029/g;\n    var convertEscapes = function (match) {\n        return \"\\\\\" + escapes[match];\n    }\n    var template = function (tpl, settings) {\n        // 可以在外部修改template.templateSettings来自定义语法\n        // 一定要保证evaluate在最后，不然会匹配到<%=%>和<%-%>\n        var templateSettings = Object.assign({}, {\n            interpolate: /<%=([\\s\\S]+?)%>/g,\n            escape: /<%-([\\s\\S]+?)%>/g,\n            evaluate: /<%([\\s\\S]+?)%>/g,\n        }, template.templateSettings);\n        settings = Object.assign({}, settings);\n        // /<%=([\\s\\S]+?)%>|<%-([\\s\\S]+?)%>|<%([\\s\\S]+?)%>|$/g\n        // 其中$是为了匹配字符串的最后一个字符\n        var matcher = RegExp(Object.keys(templateSettings).map(function (key) {\n            return templateSettings[key].source\n        }).join(\"|\") + \"|$\", \"g\")\n        var source = \"\", index = 0;\n        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串\n        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) {\n            source += \"__p += '\" + tpl.slice(index, offset).replace(escaper, convertEscapes) + \"'\\n\";\n            index = offset + match.length;\n            if (evaluate) {\n                source += evaluate + \"\\n\"\n            } else if (interpolate) {\n                source += \"__p += (\" + interpolate + \") == null ? '' : \" + interpolate + \";\\n\"\n            } else if (escape) {\n                source += \"__p += (\" + escape + \") == null ? '' : \" + html2Entity(escape) + \";\\n\"\n            }\n            return match;\n        })\n        source = \"var __p = '';\" + source + 'return __p;'\n        // 使用with可以修改作用域\n        if (!settings.variable) source = \"with(obj||{}) {\\n\" + source + \"\\n}\"\n        var render = new Function(settings.variable || \"obj\", source);\n        return render\n    }\n    // 将templateY导出到全局\n    root.templateY = template\n}.call(this))\n```\n## 转义 ##\n我们知道，在字符串中有一些特殊字符是需要转义的，比如\"'\", '\"'，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。\n但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？\n这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：\n```\nvar log = new Function(\"var a = '1\\n23';console.log(a)\");\nlog() // Uncaught SyntaxError: Invalid or unexpected token\n```\n这是因为Function函数在执行的时候，里面的内容被解析成了这样。\n```\nvar a = '1\n23';console.log(a)\n```\n在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。\n## 正则表达式 ##\nunderscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（<%=%>和<%%>）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似\\{\\#\\#\\}的语法了。\n这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/<%=([\\s\\S]+?)%>/g是不会匹配到类似<%=name<%=age%>%>这种语法的，只会匹配到<%=name%>语法。\n## replace ##\n这里我们用到了replace第二个参数是函数的情况。\n```\nvar pattern = /([a-z]+)\\s([a-z]+)/;\nvar str = \"hello world\";\nstr.replace(pattern, function(match, p1, p2, offset) {\n    // p1 is \"hello\"\n    // p2 is \"world\"\n    return match;\n})\n```\n在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是\"hello world\"。\np1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。\n\n## 字符串拼接 ##\nunderscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。\n我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。\n```\nvar arr = [], str = \"\";\nvar i = 0, j = 0\nconsole.time();\nfor(;i<100000;i++) {\n  arr.push(i);\n}\narr.join(\"\");\nconsole.timeEnd()\n\nconsole.time();\nfor(;j<100000;j++) {\n  str+= j\n}\nconsole.timeEnd()\n```\n## setting.variable ##\nunderscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: [Javascript中的with关键字][6]\n你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。\n```\n_.template(\"Using 'with': <%= data.answer %>\", {variable: 'data'})({answer: 'no'});\n```\n\n**参考链接：**\n 1. [js正则进阶][2]\n 2. [JavaScript函数replace揭秘][3]\n 3. [JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾][4]\n 4. [underscore 系列之字符实体与 _.escape][5]\n 5. [Javascript中的with关键字][6]\n 6. [高性能JavaScript模板引擎原理解析][7]\n  [1]: https://segmentfault.com/a/1190000005705169\n  [2]: https://segmentfault.com/a/1190000003497780\n  [3]: http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\n  [4]: https://blog.csdn.net/lihefei_coder/article/details/53022253\n  [5]: https://github.com/mqyqingfeng/Blog/issues/77\n  [6]: http://luopq.com/2016/02/14/js-with-keyword/\n  [7]: https://blog.csdn.net/wangjinyu501/article/details/7675599","source":"_posts/60行代码实现模板引擎.md","raw":"---\ntitle: 60行代码实现模板引擎\ndate: 2018-04-24 10:35:40\ntags:\n- underscore\n- 前端\n- 模板引擎\ncategories: \n- underscore\n---\n不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：[只有20行的Javascript模板引擎][1]\n这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。\n但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。\n恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。\n这个是我参考template后实现的模板，一共只有60行代码。\n<!-- more -->\n```\n(function () {\n    var root = this;\n    // 将字符串中的HTML实体字符转义，可以有效减少xss风险\n    var html2Entity = (function () {\n        var escapeMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '`': '&#x60;'\n        };\n        var escaper = function (match) {\n            return escapeMap[match];\n        };\n        return function (string) {\n            var source = \"(\" + Object.keys(escapeMap).join(\"|\") + \")\";\n            var regexp = RegExp(source), regexpAll = RegExp(source, \"g\");\n            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;\n        }\n    }())\n    // 字符串中的转义字符\n    var escapes = {\n        '\"': '\"',\n        \"'\": \"'\",\n        \"\\\\\": \"\\\\\",\n        '\\n': 'n',\n        '\\r': 'r',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    }\n    var escaper = /\\\\|'|\"|\\r|\\n|\\u2028|\\u2029/g;\n    var convertEscapes = function (match) {\n        return \"\\\\\" + escapes[match];\n    }\n    var template = function (tpl, settings) {\n        // 可以在外部修改template.templateSettings来自定义语法\n        // 一定要保证evaluate在最后，不然会匹配到<%=%>和<%-%>\n        var templateSettings = Object.assign({}, {\n            interpolate: /<%=([\\s\\S]+?)%>/g,\n            escape: /<%-([\\s\\S]+?)%>/g,\n            evaluate: /<%([\\s\\S]+?)%>/g,\n        }, template.templateSettings);\n        settings = Object.assign({}, settings);\n        // /<%=([\\s\\S]+?)%>|<%-([\\s\\S]+?)%>|<%([\\s\\S]+?)%>|$/g\n        // 其中$是为了匹配字符串的最后一个字符\n        var matcher = RegExp(Object.keys(templateSettings).map(function (key) {\n            return templateSettings[key].source\n        }).join(\"|\") + \"|$\", \"g\")\n        var source = \"\", index = 0;\n        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串\n        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) {\n            source += \"__p += '\" + tpl.slice(index, offset).replace(escaper, convertEscapes) + \"'\\n\";\n            index = offset + match.length;\n            if (evaluate) {\n                source += evaluate + \"\\n\"\n            } else if (interpolate) {\n                source += \"__p += (\" + interpolate + \") == null ? '' : \" + interpolate + \";\\n\"\n            } else if (escape) {\n                source += \"__p += (\" + escape + \") == null ? '' : \" + html2Entity(escape) + \";\\n\"\n            }\n            return match;\n        })\n        source = \"var __p = '';\" + source + 'return __p;'\n        // 使用with可以修改作用域\n        if (!settings.variable) source = \"with(obj||{}) {\\n\" + source + \"\\n}\"\n        var render = new Function(settings.variable || \"obj\", source);\n        return render\n    }\n    // 将templateY导出到全局\n    root.templateY = template\n}.call(this))\n```\n## 转义 ##\n我们知道，在字符串中有一些特殊字符是需要转义的，比如\"'\", '\"'，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。\n但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？\n这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：\n```\nvar log = new Function(\"var a = '1\\n23';console.log(a)\");\nlog() // Uncaught SyntaxError: Invalid or unexpected token\n```\n这是因为Function函数在执行的时候，里面的内容被解析成了这样。\n```\nvar a = '1\n23';console.log(a)\n```\n在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。\n## 正则表达式 ##\nunderscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（<%=%>和<%%>）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似\\{\\#\\#\\}的语法了。\n这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/<%=([\\s\\S]+?)%>/g是不会匹配到类似<%=name<%=age%>%>这种语法的，只会匹配到<%=name%>语法。\n## replace ##\n这里我们用到了replace第二个参数是函数的情况。\n```\nvar pattern = /([a-z]+)\\s([a-z]+)/;\nvar str = \"hello world\";\nstr.replace(pattern, function(match, p1, p2, offset) {\n    // p1 is \"hello\"\n    // p2 is \"world\"\n    return match;\n})\n```\n在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是\"hello world\"。\np1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。\n\n## 字符串拼接 ##\nunderscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。\n我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。\n```\nvar arr = [], str = \"\";\nvar i = 0, j = 0\nconsole.time();\nfor(;i<100000;i++) {\n  arr.push(i);\n}\narr.join(\"\");\nconsole.timeEnd()\n\nconsole.time();\nfor(;j<100000;j++) {\n  str+= j\n}\nconsole.timeEnd()\n```\n## setting.variable ##\nunderscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: [Javascript中的with关键字][6]\n你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。\n```\n_.template(\"Using 'with': <%= data.answer %>\", {variable: 'data'})({answer: 'no'});\n```\n\n**参考链接：**\n 1. [js正则进阶][2]\n 2. [JavaScript函数replace揭秘][3]\n 3. [JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾][4]\n 4. [underscore 系列之字符实体与 _.escape][5]\n 5. [Javascript中的with关键字][6]\n 6. [高性能JavaScript模板引擎原理解析][7]\n  [1]: https://segmentfault.com/a/1190000005705169\n  [2]: https://segmentfault.com/a/1190000003497780\n  [3]: http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\n  [4]: https://blog.csdn.net/lihefei_coder/article/details/53022253\n  [5]: https://github.com/mqyqingfeng/Blog/issues/77\n  [6]: http://luopq.com/2016/02/14/js-with-keyword/\n  [7]: https://blog.csdn.net/wangjinyu501/article/details/7675599","slug":"60行代码实现模板引擎","published":1,"updated":"2018-11-22T11:48:08.958Z","_id":"cjosj7rwu0000fpzxmahufq7e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：<a href=\"https://segmentfault.com/a/1190000005705169\" target=\"_blank\" rel=\"noopener\">只有20行的Javascript模板引擎</a><br>这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。<br>但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。<br>恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。<br>这个是我参考template后实现的模板，一共只有60行代码。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var root = this;</span><br><span class=\"line\">    // 将字符串中的HTML实体字符转义，可以有效减少xss风险</span><br><span class=\"line\">    var html2Entity = (function () &#123;</span><br><span class=\"line\">        var escapeMap = &#123;</span><br><span class=\"line\">            &apos;&amp;&apos;: &apos;&amp;amp;&apos;,</span><br><span class=\"line\">            &apos;&lt;&apos;: &apos;&amp;lt;&apos;,</span><br><span class=\"line\">            &apos;&gt;&apos;: &apos;&amp;gt;&apos;,</span><br><span class=\"line\">            &apos;&quot;&apos;: &apos;&amp;quot;&apos;,</span><br><span class=\"line\">            &quot;&apos;&quot;: &apos;&amp;#x27;&apos;,</span><br><span class=\"line\">            &apos;`&apos;: &apos;&amp;#x60;&apos;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var escaper = function (match) &#123;</span><br><span class=\"line\">            return escapeMap[match];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return function (string) &#123;</span><br><span class=\"line\">            var source = &quot;(&quot; + Object.keys(escapeMap).join(&quot;|&quot;) + &quot;)&quot;;</span><br><span class=\"line\">            var regexp = RegExp(source), regexpAll = RegExp(source, &quot;g&quot;);</span><br><span class=\"line\">            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    // 字符串中的转义字符</span><br><span class=\"line\">    var escapes = &#123;</span><br><span class=\"line\">        &apos;&quot;&apos;: &apos;&quot;&apos;,</span><br><span class=\"line\">        &quot;&apos;&quot;: &quot;&apos;&quot;,</span><br><span class=\"line\">        &quot;\\\\&quot;: &quot;\\\\&quot;,</span><br><span class=\"line\">        &apos;\\n&apos;: &apos;n&apos;,</span><br><span class=\"line\">        &apos;\\r&apos;: &apos;r&apos;,</span><br><span class=\"line\">        &apos;\\u2028&apos;: &apos;u2028&apos;,</span><br><span class=\"line\">        &apos;\\u2029&apos;: &apos;u2029&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var escaper = /\\\\|&apos;|&quot;|\\r|\\n|\\u2028|\\u2029/g;</span><br><span class=\"line\">    var convertEscapes = function (match) &#123;</span><br><span class=\"line\">        return &quot;\\\\&quot; + escapes[match];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var template = function (tpl, settings) &#123;</span><br><span class=\"line\">        // 可以在外部修改template.templateSettings来自定义语法</span><br><span class=\"line\">        // 一定要保证evaluate在最后，不然会匹配到&lt;%=%&gt;和&lt;%-%&gt;</span><br><span class=\"line\">        var templateSettings = Object.assign(&#123;&#125;, &#123;</span><br><span class=\"line\">            interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            escape: /&lt;%-([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            evaluate: /&lt;%([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">        &#125;, template.templateSettings);</span><br><span class=\"line\">        settings = Object.assign(&#123;&#125;, settings);</span><br><span class=\"line\">        // /&lt;%=([\\s\\S]+?)%&gt;|&lt;%-([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g</span><br><span class=\"line\">        // 其中$是为了匹配字符串的最后一个字符</span><br><span class=\"line\">        var matcher = RegExp(Object.keys(templateSettings).map(function (key) &#123;</span><br><span class=\"line\">            return templateSettings[key].source</span><br><span class=\"line\">        &#125;).join(&quot;|&quot;) + &quot;|$&quot;, &quot;g&quot;)</span><br><span class=\"line\">        var source = &quot;&quot;, index = 0;</span><br><span class=\"line\">        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串</span><br><span class=\"line\">        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) &#123;</span><br><span class=\"line\">            source += &quot;__p += &apos;&quot; + tpl.slice(index, offset).replace(escaper, convertEscapes) + &quot;&apos;\\n&quot;;</span><br><span class=\"line\">            index = offset + match.length;</span><br><span class=\"line\">            if (evaluate) &#123;</span><br><span class=\"line\">                source += evaluate + &quot;\\n&quot;</span><br><span class=\"line\">            &#125; else if (interpolate) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + interpolate + &quot;) == null ? &apos;&apos; : &quot; + interpolate + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125; else if (escape) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + escape + &quot;) == null ? &apos;&apos; : &quot; + html2Entity(escape) + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return match;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        source = &quot;var __p = &apos;&apos;;&quot; + source + &apos;return __p;&apos;</span><br><span class=\"line\">        // 使用with可以修改作用域</span><br><span class=\"line\">        if (!settings.variable) source = &quot;with(obj||&#123;&#125;) &#123;\\n&quot; + source + &quot;\\n&#125;&quot;</span><br><span class=\"line\">        var render = new Function(settings.variable || &quot;obj&quot;, source);</span><br><span class=\"line\">        return render</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 将templateY导出到全局</span><br><span class=\"line\">    root.templateY = template</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>我们知道，在字符串中有一些特殊字符是需要转义的，比如”‘“, ‘“‘，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。<br>但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？<br>这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log = new Function(&quot;var a = &apos;1\\n23&apos;;console.log(a)&quot;);</span><br><span class=\"line\">log() // Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>\n<p>这是因为Function函数在执行的时候，里面的内容被解析成了这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &apos;1</span><br><span class=\"line\">23&apos;;console.log(a)</span><br></pre></td></tr></table></figure></p>\n<p>在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>underscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（&lt;%=%&gt;和&lt;%%&gt;）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似的语法了。<br>这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/&lt;%=([\\s\\S]+?)%&gt;/g是不会匹配到类似&lt;%=name&lt;%=age%&gt;%&gt;这种语法的，只会匹配到&lt;%=name%&gt;语法。</p>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h2><p>这里我们用到了replace第二个参数是函数的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /([a-z]+)\\s([a-z]+)/;</span><br><span class=\"line\">var str = &quot;hello world&quot;;</span><br><span class=\"line\">str.replace(pattern, function(match, p1, p2, offset) &#123;</span><br><span class=\"line\">    // p1 is &quot;hello&quot;</span><br><span class=\"line\">    // p2 is &quot;world&quot;</span><br><span class=\"line\">    return match;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是”hello world”。<br>p1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。</p>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>underscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。<br>我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [], str = &quot;&quot;;</span><br><span class=\"line\">var i = 0, j = 0</span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;i&lt;100000;i++) &#123;</span><br><span class=\"line\">  arr.push(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.join(&quot;&quot;);</span><br><span class=\"line\">console.timeEnd()</span><br><span class=\"line\"></span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;j&lt;100000;j++) &#123;</span><br><span class=\"line\">  str+= j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.timeEnd()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setting-variable\"><a href=\"#setting-variable\" class=\"headerlink\" title=\"setting.variable\"></a>setting.variable</h2><p>underscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: <a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a><br>你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.template(&quot;Using &apos;with&apos;: &lt;%= data.answer %&gt;&quot;, &#123;variable: &apos;data&apos;&#125;)(&#123;answer: &apos;no&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000003497780\" target=\"_blank\" rel=\"noopener\">js正则进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\" target=\"_blank\" rel=\"noopener\">JavaScript函数replace揭秘</a></li>\n<li><a href=\"https://blog.csdn.net/lihefei_coder/article/details/53022253\" target=\"_blank\" rel=\"noopener\">JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/77\" target=\"_blank\" rel=\"noopener\">underscore 系列之字符实体与 _.escape</a></li>\n<li><a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a></li>\n<li><a href=\"https://blog.csdn.net/wangjinyu501/article/details/7675599\" target=\"_blank\" rel=\"noopener\">高性能JavaScript模板引擎原理解析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>不久前看过一篇不错的文章，作者用了15行代码就实现了一个简单的模板引擎，我觉得很有趣，建议在读这篇文章之前先看一下这个，这里是传送门：<a href=\"https://segmentfault.com/a/1190000005705169\" target=\"_blank\" rel=\"noopener\">只有20行的Javascript模板引擎</a><br>这个模板引擎实现的核心点是利用正则表达式来匹配到模板语法里面的变量和JS语句，再将这些匹配到的字段push到一个数组中，最后连接起来，用Function来解析字符串，最后将执行后的结果放到指定DOM节点的innerHTML里面。<br>但是这个模板引擎还是有很多不足，比如不支持取余运算，不支持自定义模板语法，也不支持if、for、switch之外的JS语句，缺少HTML实体编码。<br>恰好我这阵子也在看underscore源码，于是就参考了一下underscore中template方法的实现。<br>这个是我参考template后实现的模板，一共只有60行代码。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var root = this;</span><br><span class=\"line\">    // 将字符串中的HTML实体字符转义，可以有效减少xss风险</span><br><span class=\"line\">    var html2Entity = (function () &#123;</span><br><span class=\"line\">        var escapeMap = &#123;</span><br><span class=\"line\">            &apos;&amp;&apos;: &apos;&amp;amp;&apos;,</span><br><span class=\"line\">            &apos;&lt;&apos;: &apos;&amp;lt;&apos;,</span><br><span class=\"line\">            &apos;&gt;&apos;: &apos;&amp;gt;&apos;,</span><br><span class=\"line\">            &apos;&quot;&apos;: &apos;&amp;quot;&apos;,</span><br><span class=\"line\">            &quot;&apos;&quot;: &apos;&amp;#x27;&apos;,</span><br><span class=\"line\">            &apos;`&apos;: &apos;&amp;#x60;&apos;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var escaper = function (match) &#123;</span><br><span class=\"line\">            return escapeMap[match];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return function (string) &#123;</span><br><span class=\"line\">            var source = &quot;(&quot; + Object.keys(escapeMap).join(&quot;|&quot;) + &quot;)&quot;;</span><br><span class=\"line\">            var regexp = RegExp(source), regexpAll = RegExp(source, &quot;g&quot;);</span><br><span class=\"line\">            return regexp.test(string) ? string.replace(regexpAll, escaper) : string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    // 字符串中的转义字符</span><br><span class=\"line\">    var escapes = &#123;</span><br><span class=\"line\">        &apos;&quot;&apos;: &apos;&quot;&apos;,</span><br><span class=\"line\">        &quot;&apos;&quot;: &quot;&apos;&quot;,</span><br><span class=\"line\">        &quot;\\\\&quot;: &quot;\\\\&quot;,</span><br><span class=\"line\">        &apos;\\n&apos;: &apos;n&apos;,</span><br><span class=\"line\">        &apos;\\r&apos;: &apos;r&apos;,</span><br><span class=\"line\">        &apos;\\u2028&apos;: &apos;u2028&apos;,</span><br><span class=\"line\">        &apos;\\u2029&apos;: &apos;u2029&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var escaper = /\\\\|&apos;|&quot;|\\r|\\n|\\u2028|\\u2029/g;</span><br><span class=\"line\">    var convertEscapes = function (match) &#123;</span><br><span class=\"line\">        return &quot;\\\\&quot; + escapes[match];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var template = function (tpl, settings) &#123;</span><br><span class=\"line\">        // 可以在外部修改template.templateSettings来自定义语法</span><br><span class=\"line\">        // 一定要保证evaluate在最后，不然会匹配到&lt;%=%&gt;和&lt;%-%&gt;</span><br><span class=\"line\">        var templateSettings = Object.assign(&#123;&#125;, &#123;</span><br><span class=\"line\">            interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            escape: /&lt;%-([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">            evaluate: /&lt;%([\\s\\S]+?)%&gt;/g,</span><br><span class=\"line\">        &#125;, template.templateSettings);</span><br><span class=\"line\">        settings = Object.assign(&#123;&#125;, settings);</span><br><span class=\"line\">        // /&lt;%=([\\s\\S]+?)%&gt;|&lt;%-([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g</span><br><span class=\"line\">        // 其中$是为了匹配字符串的最后一个字符</span><br><span class=\"line\">        var matcher = RegExp(Object.keys(templateSettings).map(function (key) &#123;</span><br><span class=\"line\">            return templateSettings[key].source</span><br><span class=\"line\">        &#125;).join(&quot;|&quot;) + &quot;|$&quot;, &quot;g&quot;)</span><br><span class=\"line\">        var source = &quot;&quot;, index = 0;</span><br><span class=\"line\">        // 字符串拼接，要拼接上没有匹配到的字符串和替换匹配到的字符串</span><br><span class=\"line\">        tpl.replace(matcher, function (match, interpolate, escape, evaluate, offset) &#123;</span><br><span class=\"line\">            source += &quot;__p += &apos;&quot; + tpl.slice(index, offset).replace(escaper, convertEscapes) + &quot;&apos;\\n&quot;;</span><br><span class=\"line\">            index = offset + match.length;</span><br><span class=\"line\">            if (evaluate) &#123;</span><br><span class=\"line\">                source += evaluate + &quot;\\n&quot;</span><br><span class=\"line\">            &#125; else if (interpolate) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + interpolate + &quot;) == null ? &apos;&apos; : &quot; + interpolate + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125; else if (escape) &#123;</span><br><span class=\"line\">                source += &quot;__p += (&quot; + escape + &quot;) == null ? &apos;&apos; : &quot; + html2Entity(escape) + &quot;;\\n&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return match;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        source = &quot;var __p = &apos;&apos;;&quot; + source + &apos;return __p;&apos;</span><br><span class=\"line\">        // 使用with可以修改作用域</span><br><span class=\"line\">        if (!settings.variable) source = &quot;with(obj||&#123;&#125;) &#123;\\n&quot; + source + &quot;\\n&#125;&quot;</span><br><span class=\"line\">        var render = new Function(settings.variable || &quot;obj&quot;, source);</span><br><span class=\"line\">        return render</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 将templateY导出到全局</span><br><span class=\"line\">    root.templateY = template</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>我们知道，在字符串中有一些特殊字符是需要转义的，比如”‘“, ‘“‘，不然就会和预期展示不一致，甚至是报错，所以我们一般会用反斜杠来表示转义，常见的转义字符有\\n, \\t, \\r等等。<br>但是这里的convertEscapes里面我们为什么要多加一个反斜杠呢？<br>这是因为在执行new Function里面的语句时，也需要对字符进行一次转义，可以看一下下面这行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log = new Function(&quot;var a = &apos;1\\n23&apos;;console.log(a)&quot;);</span><br><span class=\"line\">log() // Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>\n<p>这是因为Function函数在执行的时候，里面的内容被解析成了这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &apos;1</span><br><span class=\"line\">23&apos;;console.log(a)</span><br></pre></td></tr></table></figure></p>\n<p>在JS里面是不允许字符串换行出现的，只能使用转义字符\\n。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>underscore中摒弃了用正则表达式匹配for/if/switch/{/}等语句的做法，而是使用了不同的模板语法（&lt;%=%&gt;和&lt;%%&gt;）来区分当前是变量还是JS语句，这样虽然需要用户自己区分语法，但是给开发者减少了很多不必要的麻烦，因为如果用正则来匹配，那么后面就无法使用类似的语法了。<br>这里正则表达式的重点是+?，+?是惰性匹配，表示以最少的次数匹配到[\\s\\S]，所以我们/&lt;%=([\\s\\S]+?)%&gt;/g是不会匹配到类似&lt;%=name&lt;%=age%&gt;%&gt;这种语法的，只会匹配到&lt;%=name%&gt;语法。</p>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h2><p>这里我们用到了replace第二个参数是函数的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /([a-z]+)\\s([a-z]+)/;</span><br><span class=\"line\">var str = &quot;hello world&quot;;</span><br><span class=\"line\">str.replace(pattern, function(match, p1, p2, offset) &#123;</span><br><span class=\"line\">    // p1 is &quot;hello&quot;</span><br><span class=\"line\">    // p2 is &quot;world&quot;</span><br><span class=\"line\">    return match;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在JS正则表达式中，使用()包起来的叫着捕获性分组，而使用(?:)的叫着非捕获性分组，在replace的第二个参数是函数时，每次匹配都会执行一次这个函数，这个函数第一个参数是pattern匹配到的字符串，在这个里面是”hello world”。<br>p1是第一个分组([a-z]+)匹配到的字符串，p2是第二个分组([a-z]+)匹配到的字符串，如果有更多的分组，那还会有更多参数p3, p4, p5等等，offset是最后一个参数，指的是在第几个索引处匹配到了，这里的offset是0，因为是从一开始就刚好匹配到了hello world。</p>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>underscore中使用+=字符串拼接的方式代替了数组push的方式，这样是因为+=相比push的性能会更高。<br>我这里进行了一下测试，在新版chrome中，下面这段代码中，push的效率要远远好于+=，但是在v8中结果却是相反。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [], str = &quot;&quot;;</span><br><span class=\"line\">var i = 0, j = 0</span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;i&lt;100000;i++) &#123;</span><br><span class=\"line\">  arr.push(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.join(&quot;&quot;);</span><br><span class=\"line\">console.timeEnd()</span><br><span class=\"line\"></span><br><span class=\"line\">console.time();</span><br><span class=\"line\">for(;j&lt;100000;j++) &#123;</span><br><span class=\"line\">  str+= j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.timeEnd()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setting-variable\"><a href=\"#setting-variable\" class=\"headerlink\" title=\"setting.variable\"></a>setting.variable</h2><p>underscore这里使用with来改变了作用域，但是with会导致性能比较差，关于with的弊端可以参考一下这篇文章: <a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a><br>你还可以在variable设置里指定一个变量名，这样能显著提升模板的渲染速度。不过语法也和之前有一些不同，模板里面必须要用你指定的变量名来访问，而不能直接用answer这种形式，这种形式下没有使用with实现，所以性能会高很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.template(&quot;Using &apos;with&apos;: &lt;%= data.answer %&gt;&quot;, &#123;variable: &apos;data&apos;&#125;)(&#123;answer: &apos;no&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考链接：</strong></p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000003497780\" target=\"_blank\" rel=\"noopener\">js正则进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/whitewolf/archive/2013/03/14/2958720.html\" target=\"_blank\" rel=\"noopener\">JavaScript函数replace揭秘</a></li>\n<li><a href=\"https://blog.csdn.net/lihefei_coder/article/details/53022253\" target=\"_blank\" rel=\"noopener\">JavaScript正则表达式分组模式：捕获性分组与非捕获性分组及前瞻后顾</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/77\" target=\"_blank\" rel=\"noopener\">underscore 系列之字符实体与 _.escape</a></li>\n<li><a href=\"http://luopq.com/2016/02/14/js-with-keyword/\" target=\"_blank\" rel=\"noopener\">Javascript中的with关键字</a></li>\n<li><a href=\"https://blog.csdn.net/wangjinyu501/article/details/7675599\" target=\"_blank\" rel=\"noopener\">高性能JavaScript模板引擎原理解析</a></li>\n</ol>"},{"title":"underscore debounce防抖动函数分析","date":"2018-03-23T14:15:06.000Z","_content":"本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。\nthrottle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。\n## 电梯 ##\n\n假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。\n## 应用场景 ##\n除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。\n<!-- more -->\n未使用debounce的输入：\n![未使用debounce][2]\n使用debounce的输入：\n![使用debounce][3]\n## 简单的debounce ##\n知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。\n```\nfunction debounce(func, wait) {\n\tvar timeout,\n\t\targs, \n\t\tcontext\n\tvar later = function() {\n\t\tfunc.apply(context, args)\n\t\ttimeout = context = args = null\n\t}\n\treturn function() {\n\t\tcontext = this\n\t\targs = arguments\n\t\t// 每次触发都清理掉前一次的定时器\n\t\tclearTimeout(timeout)\n\t\t// 只有最后一次触发后才会调用later\n\t\ttimeout = setTimeout(later, wait)\n\t}\n}\n```\n麻雀虽小，五脏俱全。\n不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。\n## underscore debounce ##\n```\n// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate\n// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func\n// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用\n_.debounce = function (func, wait, immediate) {\n\t\tvar timeout, args, context, timestamp, result;\n\n\t\tvar later = function () {\n\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp\n\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的\n\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait\n\t\t    // last是执行later的时间和上一次触发的时间差\n\t\t\tvar last = _.now() - timestamp;\n            // 如果在later执行前还有其他触发，那么就会重新设置定时器\n            // last >= 0应该是防止客户端系统时间被调整\n\t\t\tif (last < wait && last >= 0) {\n\t\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过\n\t\t\t} else {\n\t\t\t\ttimeout = null;\n\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发\n\t\t\t\tif (!immediate) {\n\t\t\t\t\tresult = func.apply(context, args);\n\t\t\t\t\t// 解除引用\n\t\t\t\t\tif (!timeout) context = args = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn function () {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// 每次触发都用timestamp记录时间戳\n\t\t\ttimestamp = _.now();\n\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func\n\t\t\tvar callNow = immediate && !timeout;\n\t\t\t// 第一次进来的时候会设置一个定时器\n\t\t\tif (!timeout) timeout = setTimeout(later, wait);\n\t\t\tif (callNow) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tcontext = args = null;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t};\n```\nunderscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。\n\n同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。\n\n**参考链接：**\n1、[浅谈throttle以及debounce的原理和实现\n][1]\n\n\n  [1]: https://segmentfault.com/a/1190000010983733\n  [2]: http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\n  [3]: http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore debounce防抖动函数分析.md","raw":"---\ntitle: underscore debounce防抖动函数分析\ndate: 2018-03-23 22:15:06\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n\t- underscore\n---\n本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。\nthrottle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。\n## 电梯 ##\n\n假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。\n## 应用场景 ##\n除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。\n<!-- more -->\n未使用debounce的输入：\n![未使用debounce][2]\n使用debounce的输入：\n![使用debounce][3]\n## 简单的debounce ##\n知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。\n```\nfunction debounce(func, wait) {\n\tvar timeout,\n\t\targs, \n\t\tcontext\n\tvar later = function() {\n\t\tfunc.apply(context, args)\n\t\ttimeout = context = args = null\n\t}\n\treturn function() {\n\t\tcontext = this\n\t\targs = arguments\n\t\t// 每次触发都清理掉前一次的定时器\n\t\tclearTimeout(timeout)\n\t\t// 只有最后一次触发后才会调用later\n\t\ttimeout = setTimeout(later, wait)\n\t}\n}\n```\n麻雀虽小，五脏俱全。\n不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。\n## underscore debounce ##\n```\n// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate\n// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func\n// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用\n_.debounce = function (func, wait, immediate) {\n\t\tvar timeout, args, context, timestamp, result;\n\n\t\tvar later = function () {\n\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp\n\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的\n\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait\n\t\t    // last是执行later的时间和上一次触发的时间差\n\t\t\tvar last = _.now() - timestamp;\n            // 如果在later执行前还有其他触发，那么就会重新设置定时器\n            // last >= 0应该是防止客户端系统时间被调整\n\t\t\tif (last < wait && last >= 0) {\n\t\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过\n\t\t\t} else {\n\t\t\t\ttimeout = null;\n\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发\n\t\t\t\tif (!immediate) {\n\t\t\t\t\tresult = func.apply(context, args);\n\t\t\t\t\t// 解除引用\n\t\t\t\t\tif (!timeout) context = args = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn function () {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// 每次触发都用timestamp记录时间戳\n\t\t\ttimestamp = _.now();\n\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func\n\t\t\tvar callNow = immediate && !timeout;\n\t\t\t// 第一次进来的时候会设置一个定时器\n\t\t\tif (!timeout) timeout = setTimeout(later, wait);\n\t\t\tif (callNow) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tcontext = args = null;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t};\n```\nunderscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。\n\n同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。\n\n**参考链接：**\n1、[浅谈throttle以及debounce的原理和实现\n][1]\n\n\n  [1]: https://segmentfault.com/a/1190000010983733\n  [2]: http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\n  [3]: http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore debounce防抖动函数分析","published":1,"updated":"2018-11-22T11:48:22.736Z","_id":"cjosj7rx10002fpzxr18uar93","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。<br>throttle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。</p>\n<h2 id=\"电梯\"><a href=\"#电梯\" class=\"headerlink\" title=\"电梯\"></a>电梯</h2><p>假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。<br><a id=\"more\"></a><br>未使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\" alt=\"未使用debounce\"><br>使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\" alt=\"使用debounce\"></p>\n<h2 id=\"简单的debounce\"><a href=\"#简单的debounce\" class=\"headerlink\" title=\"简单的debounce\"></a>简单的debounce</h2><p>知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">\tvar timeout,</span><br><span class=\"line\">\t\targs, </span><br><span class=\"line\">\t\tcontext</span><br><span class=\"line\">\tvar later = function() &#123;</span><br><span class=\"line\">\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\ttimeout = context = args = null</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tcontext = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 每次触发都清理掉前一次的定时器</span><br><span class=\"line\">\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t// 只有最后一次触发后才会调用later</span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>麻雀虽小，五脏俱全。<br>不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。</p>\n<h2 id=\"underscore-debounce\"><a href=\"#underscore-debounce\" class=\"headerlink\" title=\"underscore debounce\"></a>underscore debounce</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate</span><br><span class=\"line\">// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func</span><br><span class=\"line\">// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用</span><br><span class=\"line\">_.debounce = function (func, wait, immediate) &#123;</span><br><span class=\"line\">\t\tvar timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp</span><br><span class=\"line\">\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的</span><br><span class=\"line\">\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait</span><br><span class=\"line\">\t\t    // last是执行later的时间和上一次触发的时间差</span><br><span class=\"line\">\t\t\tvar last = _.now() - timestamp;</span><br><span class=\"line\">            // 如果在later执行前还有其他触发，那么就会重新设置定时器</span><br><span class=\"line\">            // last &gt;= 0应该是防止客户端系统时间被调整</span><br><span class=\"line\">\t\t\tif (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, wait - last);</span><br><span class=\"line\">\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发</span><br><span class=\"line\">\t\t\t\tif (!immediate) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// 每次触发都用timestamp记录时间戳</span><br><span class=\"line\">\t\t\ttimestamp = _.now();</span><br><span class=\"line\">\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func</span><br><span class=\"line\">\t\t\tvar callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\t\t// 第一次进来的时候会设置一个定时器</span><br><span class=\"line\">\t\t\tif (!timeout) timeout = setTimeout(later, wait);</span><br><span class=\"line\">\t\t\tif (callNow) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tcontext = args = null;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>underscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。</p>\n<p>同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。</p>\n<p><strong>参考链接：</strong><br>1、<a href=\"https://segmentfault.com/a/1190000010983733\" target=\"_blank\" rel=\"noopener\">浅谈throttle以及debounce的原理和实现\n</a></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>本文是underscore源码剖析系列第六篇文章，上节我们介绍了throttle节流函数的实现，这节将会介绍一下节流函数的兄弟 —— debounce防抖动函数。<br>throttle函数是在高频率触发的情况下，为了防止函数的频繁调用，将其限制在一段时间内只会调用一次。而debounce函数则是在频繁触发的情况下，只在触发的最后一次调用一次，想像一下如果我们用手按住一个弹簧，那么只有等到我们把手松开，弹簧才会弹起来，下面我用一个电梯的例子来介绍debounce函数。</p>\n<h2 id=\"电梯\"><a href=\"#电梯\" class=\"headerlink\" title=\"电梯\"></a>电梯</h2><p>假如我下班的时候去坐电梯，等了一段时间后，电梯正准备关上门下降，这个时候一个同事走了过来，电梯门被打开，这样电梯就会继续等一段时间，如果中间一直有人进来，那么电梯就一直不会下降，直到最后一个人进来后过了一定时间后还没有下一个人进来，这时电梯才会下降。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>除了电梯，事实上我们还有很多应用场景，比如我用键盘不断输入文字，我希望等最后一次输入结束后才会调用接口来请求展示联想词，如果每次输入一个字的时候就会调用接口，这样调用未免太过于频繁了。<br>","more":"<br>未使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/89lhbpusryy84o7ss1mqm9or/no%20debounce.gif\" alt=\"未使用debounce\"><br>使用debounce的输入：<br><img src=\"http://static.zybuluo.com/gyyin/0mz3o57q6k2wjv3cyx0zgf4s/debounce.gif\" alt=\"使用debounce\"></p>\n<h2 id=\"简单的debounce\"><a href=\"#简单的debounce\" class=\"headerlink\" title=\"简单的debounce\"></a>简单的debounce</h2><p>知道debounce的工作原理了，我们可以先自己实现一个比较简单的debounce函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">\tvar timeout,</span><br><span class=\"line\">\t\targs, </span><br><span class=\"line\">\t\tcontext</span><br><span class=\"line\">\tvar later = function() &#123;</span><br><span class=\"line\">\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\ttimeout = context = args = null</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tcontext = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 每次触发都清理掉前一次的定时器</span><br><span class=\"line\">\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t// 只有最后一次触发后才会调用later</span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>麻雀虽小，五脏俱全。<br>不过这个函数还是有很多问题，比如每次触发都要反复的清除和设置定时器，我们来看一下underscore的实现。</p>\n<h2 id=\"underscore-debounce\"><a href=\"#underscore-debounce\" class=\"headerlink\" title=\"underscore debounce\"></a>underscore debounce</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// debounce函数传入三个参数，分别是要执行的函数func，延迟时间wait，是否立即执行immediate</span><br><span class=\"line\">// 如果immediate为true，那么就会在wait时间段一开始就执行一次func，之后不管触发多少次都不会再执行func</span><br><span class=\"line\">// 在类似不小心点了提交按钮两下而提交了两次的情况下很有用</span><br><span class=\"line\">_.debounce = function (func, wait, immediate) &#123;</span><br><span class=\"line\">\t\tvar timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t    // 这个是最关键的一步，因为每次触发的时候都要记录当前timestamp</span><br><span class=\"line\">\t\t    // 但是later是第一次触发后wait时间后执行的，_now()减去第一次触发时的时间当然是等于wait的</span><br><span class=\"line\">\t\t    // 但是如果后续继续触发，那么_.now() - timestamp肯定会小于wait</span><br><span class=\"line\">\t\t    // last是执行later的时间和上一次触发的时间差</span><br><span class=\"line\">\t\t\tvar last = _.now() - timestamp;</span><br><span class=\"line\">            // 如果在later执行前还有其他触发，那么就会重新设置定时器</span><br><span class=\"line\">            // last &gt;= 0应该是防止客户端系统时间被调整</span><br><span class=\"line\">\t\t\tif (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, wait - last);</span><br><span class=\"line\">\t\t\t// 如果last大于等于wait，也就是说设置timeout定时器后没有再触发过</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t// 这个时候如果immediate不为true，就会立即执行func函数，这也是为什么immediate为true的时候只会执行第一次触发</span><br><span class=\"line\">\t\t\t\tif (!immediate) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// 每次触发都用timestamp记录时间戳</span><br><span class=\"line\">\t\t\ttimestamp = _.now();</span><br><span class=\"line\">\t\t\t// 第一次进来的时候，如果immediate为true，那么会立即执行func</span><br><span class=\"line\">\t\t\tvar callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\t\t// 第一次进来的时候会设置一个定时器</span><br><span class=\"line\">\t\t\tif (!timeout) timeout = setTimeout(later, wait);</span><br><span class=\"line\">\t\t\tif (callNow) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tcontext = args = null;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>underscore的实现比较巧妙，为了防止出现我们上面那种不停地清除、设置定时器的情况，underscore则会在每次触发时都记录时间戳，在wait时间后定时器触发执行later函数时计算当前时间和时间戳之差，如果小于wait时间，那么在之后肯定还有其他触发，这时再重新设置定时器，这样不仅解决了上面的问题，也保证了最后一次触发后wait时间才会执行func。</p>\n<p>同时，在我们的基础之上，underscore加入了immediate参数。如果传入的immediate为true，那么只会在第一次进来的时候立即执行。很明显在上面代码中func执行只有两处，一个是callNow判断里面，一个是!immediate判断里面，所以这样保证了后续触发不会再执行func。</p>\n<p><strong>参考链接：</strong><br>1、<a href=\"https://segmentfault.com/a/1190000010983733\" target=\"_blank\" rel=\"noopener\">浅谈throttle以及debounce的原理和实现\n</a></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"《守望者》观后感","date":"2018-02-21T07:11:12.000Z","_content":"在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。\n我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房却靠特效砸，完全没有给观众留下任何值得思考回味的价值。\n<!-- more -->\n在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。\n而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。\n即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。\n法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。\n现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下\n《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。\n","source":"_posts/《守望者》观后感.md","raw":"---\ntitle: 《守望者》观后感\ndate: 2018-02-21 15:11:12\ntags:\n    - 电影\n    - 观后感\n    - 个人笔记\ncategories:\n    - 电影\n---\n在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。\n我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房却靠特效砸，完全没有给观众留下任何值得思考回味的价值。\n<!-- more -->\n在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。\n而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。\n即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。\n法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。\n现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下\n《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。\n","slug":"《守望者》观后感","published":1,"updated":"2018-11-14T09:47:00.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rx60006fpzxtyiw7lgj","content":"<p>在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。<br>我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房却靠特效砸，完全没有给观众留下任何值得思考回味的价值。<br><a id=\"more\"></a><br>在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。<br>而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。<br>即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。<br>法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。<br>现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下<br>《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。</p>\n","site":{"data":{}},"excerpt":"<p>在高铁上看完了《守望者》，一部充满了现实主义的超级英雄电影。<br>我一向对超级英雄类的电影充满鄙夷，因为我觉得这些为了迎合观众口味而诞生的爆米花电影，票房却靠特效砸，完全没有给观众留下任何值得思考回味的价值。<br>","more":"<br>在这些超级英雄电影中，以往我唯一喜欢的一部就是诺兰的《侠影之谜》，相比剧情更加紧凑的《黑暗骑士》，我更喜欢看《侠影之谜》是因为描述了一个超级英雄的成长以及蝙蝠侠作为普通人的一面。<br>而《守望者》则是展示了他们更加人性的一面。他们可以肆意杀人、玩弄女性，甚至制造阴谋杀害了几千万人，人性的丑陋展现的淋漓尽致。<br>即使是在基调压抑的《黑暗骑士》中，被小丑绑架的两艘船上的人最终也没有选择牺牲对方来换取自己的存活，而《守望者》最后的结局有点让人有些突兀并且让人无法接受。<br>法老王做的是正确的吗？但是他杀死了几千万无辜的人。那是错误的吗？可他确确实实阻止了美苏大战，拯救了全世界。<br>现实是残酷的，绝对的正义不会存在，即使是超级英雄，也只能屈服于现实之下<br>《侠影之谜》中影武者联盟做法也是类似，我不赞同这种做法，但也不觉得有更好的办法。人性本恶，约束人们的是法律和道德，法律又是人制定的，用列宁的话来说，国家只是一个阶级统治另一个阶级的机器，法律也只是掌权者的工具而已。然而希望自己能够凌驾于法律之上对罪恶做出惩罚的人，往往要么是个英雄，要么就是个疯子。</p>"},{"title":"underscore源码剖析之数组遍历函数分析（二）","date":"2018-03-20T14:13:12.000Z","_content":"## 用法 ##\n\n上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。\n在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。\n```\nvar arr = [1, 2, 3, 4];\n_.reduce(arr, function(result, item) {\n    result += item;\n    console.log(result); // 1, 3, 6, 10\n    return result;\n}, 0)\n_.reduceRight(arr, function(result, item) {\n    result += item;\n    console.log(result); // 4, 7, 9, 10\n    return result;\n}, 0)\n```\nreduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：[reduce的用法][1]\n<!-- more -->\n## createReduce实现 ##\n\n```\n_.reduce = _.foldl = _.inject = createReduce(1);\n_.reduceRight = _.foldr = createReduce(-1);\n// createReduce会根据dir的值来控制遍历方向\nfunction createReduce(dir) {\n\tfunction iterator(obj, iteratee, memo, keys, index, length) {\n\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        \n\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn memo;\n\t}\n\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文\n\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）\n\t// 如果memo有值，那么就从obj第一个元素迭代\n\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值\n\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代\n\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代\n\treturn function (obj, iteratee, memo, context) {\n\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee\n\t\titeratee = optimizeCb(iteratee, context, 4);\n\t\t\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tindex = dir > 0 ? 0 : length - 1;\n\t\t// 如果没有memo和context\n\t\tif (arguments.length < 3) {\n\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去\n\t\t\tmemo = obj[keys ? keys[index] : index];\n\t\t\tindex += dir;\n\t\t}\n\t\treturn iterator(obj, iteratee, memo, keys, index, length);\n\t};\n}\n```\ncreateReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。\n\n如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。\n\n一共就是下面四种情况：\n\n 1. 如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。\n 2. 如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。\n 3. 如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。\n 4. 如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。\n## 应用场景 ##\nreduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？\n### 深层取值 ###\n我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。\n```\nvar obj = {\n    info1: {\n        age: 20\n    }\n}\nvar age = obj.info1.age\nvar name = obj.info2.name // Cannot read property 'name' of undefined\n```\n我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 && obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&&，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。\n```\nvar get = function(obj, attrArr) {\n    return _.reduce(attrArr, function(obj, attr) {\n        return obj && obj[attr]\n    }, obj)\n}\n\n```\n我们找个例子来试试看：\n```\nvar obj = {\n\tcountry: {\n\t\tname: \"china\",\n\t\tcity: {\n\t\t\tname: \"shanghai\",\n\t\t\tstreet: {\n\t\t\t\tname: \"changning\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nget(obj, [\"name\", \"name\"]) // undefined\nget(obj, [\"country\", \"city\", \"name\"]) // \"shanghai\"\nget(obj, [\"country\", \"city\", \"street\", \"name\"]) // \"changning\"\n```\n### 数组扁平化 ###\n这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？\n```\n    var arr = [1, [2, [3, [4]]]]\n    var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]\n```\n我们可以用reduce这样写。\n```\n    var flatten = function(arr) {  \n        return _.reduce(arr, function(originArr, item) {\n            return originArr.concat(Array.isArray(item) ? flatten(item) : item)\n        }, [])\n    }\n```\n这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。\n\n  [1]: http://www.bootcss.com/p/underscore/#reduce\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之数组遍历函数分析（二）.md","raw":"---\ntitle: underscore源码剖析之数组遍历函数分析（二）\ndate: 2018-03-20 22:13:12\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n\t- underscore\n---\n## 用法 ##\n\n上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。\n在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。\n```\nvar arr = [1, 2, 3, 4];\n_.reduce(arr, function(result, item) {\n    result += item;\n    console.log(result); // 1, 3, 6, 10\n    return result;\n}, 0)\n_.reduceRight(arr, function(result, item) {\n    result += item;\n    console.log(result); // 4, 7, 9, 10\n    return result;\n}, 0)\n```\nreduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：[reduce的用法][1]\n<!-- more -->\n## createReduce实现 ##\n\n```\n_.reduce = _.foldl = _.inject = createReduce(1);\n_.reduceRight = _.foldr = createReduce(-1);\n// createReduce会根据dir的值来控制遍历方向\nfunction createReduce(dir) {\n\tfunction iterator(obj, iteratee, memo, keys, index, length) {\n\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        \n\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn memo;\n\t}\n\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文\n\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）\n\t// 如果memo有值，那么就从obj第一个元素迭代\n\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值\n\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代\n\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代\n\treturn function (obj, iteratee, memo, context) {\n\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee\n\t\titeratee = optimizeCb(iteratee, context, 4);\n\t\t\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tindex = dir > 0 ? 0 : length - 1;\n\t\t// 如果没有memo和context\n\t\tif (arguments.length < 3) {\n\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去\n\t\t\tmemo = obj[keys ? keys[index] : index];\n\t\t\tindex += dir;\n\t\t}\n\t\treturn iterator(obj, iteratee, memo, keys, index, length);\n\t};\n}\n```\ncreateReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。\n\n如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。\n\n一共就是下面四种情况：\n\n 1. 如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。\n 2. 如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。\n 3. 如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。\n 4. 如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。\n## 应用场景 ##\nreduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？\n### 深层取值 ###\n我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。\n```\nvar obj = {\n    info1: {\n        age: 20\n    }\n}\nvar age = obj.info1.age\nvar name = obj.info2.name // Cannot read property 'name' of undefined\n```\n我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 && obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&&，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。\n```\nvar get = function(obj, attrArr) {\n    return _.reduce(attrArr, function(obj, attr) {\n        return obj && obj[attr]\n    }, obj)\n}\n\n```\n我们找个例子来试试看：\n```\nvar obj = {\n\tcountry: {\n\t\tname: \"china\",\n\t\tcity: {\n\t\t\tname: \"shanghai\",\n\t\t\tstreet: {\n\t\t\t\tname: \"changning\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nget(obj, [\"name\", \"name\"]) // undefined\nget(obj, [\"country\", \"city\", \"name\"]) // \"shanghai\"\nget(obj, [\"country\", \"city\", \"street\", \"name\"]) // \"changning\"\n```\n### 数组扁平化 ###\n这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？\n```\n    var arr = [1, [2, [3, [4]]]]\n    var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]\n```\n我们可以用reduce这样写。\n```\n    var flatten = function(arr) {  \n        return _.reduce(arr, function(originArr, item) {\n            return originArr.concat(Array.isArray(item) ? flatten(item) : item)\n        }, [])\n    }\n```\n这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。\n\n  [1]: http://www.bootcss.com/p/underscore/#reduce\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之数组遍历函数分析（二）","published":1,"updated":"2018-11-22T11:48:35.606Z","_id":"cjosj7rxb0008fpzxros8ffly","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。<br>在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">_.reduce(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 1, 3, 6, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">_.reduceRight(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 4, 7, 9, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br></pre></td></tr></table></figure></p>\n<p>reduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：<a href=\"http://www.bootcss.com/p/underscore/#reduce\" target=\"_blank\" rel=\"noopener\">reduce的用法</a><br><a id=\"more\"></a></p>\n<h2 id=\"createReduce实现\"><a href=\"#createReduce实现\" class=\"headerlink\" title=\"createReduce实现\"></a>createReduce实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.reduce = _.foldl = _.inject = createReduce(1);</span><br><span class=\"line\">_.reduceRight = _.foldr = createReduce(-1);</span><br><span class=\"line\">// createReduce会根据dir的值来控制遍历方向</span><br><span class=\"line\">function createReduce(dir) &#123;</span><br><span class=\"line\">\tfunction iterator(obj, iteratee, memo, keys, index, length) &#123;</span><br><span class=\"line\">\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        </span><br><span class=\"line\">\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn memo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文</span><br><span class=\"line\">\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）</span><br><span class=\"line\">\t// 如果memo有值，那么就从obj第一个元素迭代</span><br><span class=\"line\">\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值</span><br><span class=\"line\">\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代</span><br><span class=\"line\">\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代</span><br><span class=\"line\">\treturn function (obj, iteratee, memo, context) &#123;</span><br><span class=\"line\">\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context, 4);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tindex = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 如果没有memo和context</span><br><span class=\"line\">\t\tif (arguments.length &lt; 3) &#123;</span><br><span class=\"line\">\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去</span><br><span class=\"line\">\t\t\tmemo = obj[keys ? keys[index] : index];</span><br><span class=\"line\">\t\t\tindex += dir;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn iterator(obj, iteratee, memo, keys, index, length);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>createReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。</p>\n<p>如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。</p>\n<p>一共就是下面四种情况：</p>\n<ol>\n<li>如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。</li>\n<li>如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。</li>\n<li>如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。</li>\n<li>如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2>reduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？<h3 id=\"深层取值\"><a href=\"#深层取值\" class=\"headerlink\" title=\"深层取值\"></a>深层取值</h3>我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    info1: &#123;</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = obj.info1.age</span><br><span class=\"line\">var name = obj.info2.name // Cannot read property &apos;name&apos; of undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 &amp;&amp; obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&amp;&amp;，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var get = function(obj, attrArr) &#123;</span><br><span class=\"line\">    return _.reduce(attrArr, function(obj, attr) &#123;</span><br><span class=\"line\">        return obj &amp;&amp; obj[attr]</span><br><span class=\"line\">    &#125;, obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们找个例子来试试看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\tcountry: &#123;</span><br><span class=\"line\">\t\tname: &quot;china&quot;,</span><br><span class=\"line\">\t\tcity: &#123;</span><br><span class=\"line\">\t\t\tname: &quot;shanghai&quot;,</span><br><span class=\"line\">\t\t\tstreet: &#123;</span><br><span class=\"line\">\t\t\t\tname: &quot;changning&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">get(obj, [&quot;name&quot;, &quot;name&quot;]) // undefined</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;name&quot;]) // &quot;shanghai&quot;</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;street&quot;, &quot;name&quot;]) // &quot;changning&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><p>这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, [2, [3, [4]]]]</span><br><span class=\"line\">var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]</span><br></pre></td></tr></table></figure></p>\n<p>我们可以用reduce这样写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flatten = function(arr) &#123;  </span><br><span class=\"line\">    return _.reduce(arr, function(originArr, item) &#123;</span><br><span class=\"line\">        return originArr.concat(Array.isArray(item) ? flatten(item) : item)</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>上一篇主要介绍了each和map这些函数的实现，本篇继续分析reduce的源码。<br>在underscore中有reduce和reduceRight两个方法，reduce是从数组或对象第一项开始遍历，reduceRight则是从最后一项开始遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">_.reduce(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 1, 3, 6, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">_.reduceRight(arr, function(result, item) &#123;</span><br><span class=\"line\">    result += item;</span><br><span class=\"line\">    console.log(result); // 4, 7, 9, 10</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;, 0)</span><br></pre></td></tr></table></figure></p>\n<p>reduce函数有四个参数，分别是list（数组或对象）、iteratee（函数）、memo（初始值）、context（上下文），func函数则会接收四个参数，分别是memo执行后的结果、数组项/对象value、index/key，list，具体用法可以看这里：<a href=\"http://www.bootcss.com/p/underscore/#reduce\" target=\"_blank\" rel=\"noopener\">reduce的用法</a><br>","more":"</p>\n<h2 id=\"createReduce实现\"><a href=\"#createReduce实现\" class=\"headerlink\" title=\"createReduce实现\"></a>createReduce实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.reduce = _.foldl = _.inject = createReduce(1);</span><br><span class=\"line\">_.reduceRight = _.foldr = createReduce(-1);</span><br><span class=\"line\">// createReduce会根据dir的值来控制遍历方向</span><br><span class=\"line\">function createReduce(dir) &#123;</span><br><span class=\"line\">\tfunction iterator(obj, iteratee, memo, keys, index, length) &#123;</span><br><span class=\"line\">\t\t// 从第index个值开始迭代，dir为1的时候从左往右跌代，dir为-1的时候从右往左跌代        </span><br><span class=\"line\">\t\t// 将每次返回的值赋给memo，以便于下次继续调用，直到走完这个循环，最后返回memo</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tmemo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn memo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// _.reduce传参分别是对象/数组, 函数，初始值，上下文</span><br><span class=\"line\">\t// 根据dir的值来判断index的值（从第一个元素还是最后一个元素开始迭代）</span><br><span class=\"line\">\t// 如果memo有值，那么就从obj第一个元素迭代</span><br><span class=\"line\">\t// 如果没有传入memo和context两个值的时候，需要对memo赋个初始值</span><br><span class=\"line\">\t// 也就是说将第一个元素作为初始值给memo，从obj第二个元素开始迭代</span><br><span class=\"line\">\t// 或者将最后一个元素作为初始值给memo，从obj倒数第二个元素开始迭代</span><br><span class=\"line\">\treturn function (obj, iteratee, memo, context) &#123;</span><br><span class=\"line\">\t    // 调用optimizeCb，返回一个绑定了context上下文的iteratee</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context, 4);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tindex = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 如果没有memo和context</span><br><span class=\"line\">\t\tif (arguments.length &lt; 3) &#123;</span><br><span class=\"line\">\t\t\t// 如果这里没有传入第三个初始值，那么会把obj里面第一个或最后一个值赋过去</span><br><span class=\"line\">\t\t\tmemo = obj[keys ? keys[index] : index];</span><br><span class=\"line\">\t\t\tindex += dir;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn iterator(obj, iteratee, memo, keys, index, length);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>createReduce函数是一个高阶函数，接收了一个dir，通过dir来判断是从list是从左往右遍历还是从右往左遍历，之所以用1和-1是为了后续遍历的时候，直接让index加上dir来实现循环，如果是从左往右遍历，那么dir为1，在for循环中index每次加1，通过访问index或key[index]就可以实现从左往右遍历。如果是从右往左遍历，那么dir为-1，在for循环中index每次减1，这样就实现了从右往左遍历。</p>\n<p>如果没有给reduce传memo这个初始值，则会将list中的第一项或者最后一项赋给memo，之后的迭代从第二项或者倒数第二项开始。</p>\n<p>一共就是下面四种情况：</p>\n<ol>\n<li>如果dir为1，也就是调用reduce的时候，如果传入了memo，那么会从list的第一项开始遍历，将memo和循环中当前的项传给iteratee函数执行，并且将执行结束后的结果重新赋值给memo，这样一直迭代下去，得到最后的memo值。</li>\n<li>如果dir为1，并且没有传入memo，那么会将list中的第一项赋给memo，之后从第二项再开始遍历list。</li>\n<li>如果dir为-1，也就是调用reduceRight的时候，如果传入了memo，那么会从list的最后一项开始遍历。</li>\n<li>如果dir为-1，并且没有传入memo，那么会将list中的最后一项赋给memo，之后从倒数第二项再开始遍历list。<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2>reduce可以有很多很巧妙的用法，某些情况下代替each、map循环也会更加方便，比如计算一个数组中所有项之和的时候，那么reduce还有其他什么用法呢？<h3 id=\"深层取值\"><a href=\"#深层取值\" class=\"headerlink\" title=\"深层取值\"></a>深层取值</h3>我们在平时写代码的时候经常会遇到给对象内部某个属性赋值，但是这个属性在很深的层级里面，如果直接使用.来赋值，只要前面有一个是undefined，后面必报错。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    info1: &#123;</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = obj.info1.age</span><br><span class=\"line\">var name = obj.info2.name // Cannot read property &apos;name&apos; of undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们想获取obj下面info2属性的name，但是因为obj里面没有info2，所以obj.info2是undefined，我们访问的是undefined.name，这个时候肯定会报错的，我们只能用obj.info2 &amp;&amp; obj.info2.name的丑陋形式来取值，如果是更深的层级，就需要写更多的&amp;&amp;，所以我们可以使用reduce来封装一个get方法来优雅的深层取值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var get = function(obj, attrArr) &#123;</span><br><span class=\"line\">    return _.reduce(attrArr, function(obj, attr) &#123;</span><br><span class=\"line\">        return obj &amp;&amp; obj[attr]</span><br><span class=\"line\">    &#125;, obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们找个例子来试试看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\tcountry: &#123;</span><br><span class=\"line\">\t\tname: &quot;china&quot;,</span><br><span class=\"line\">\t\tcity: &#123;</span><br><span class=\"line\">\t\t\tname: &quot;shanghai&quot;,</span><br><span class=\"line\">\t\t\tstreet: &#123;</span><br><span class=\"line\">\t\t\t\tname: &quot;changning&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">get(obj, [&quot;name&quot;, &quot;name&quot;]) // undefined</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;name&quot;]) // &quot;shanghai&quot;</span><br><span class=\"line\">get(obj, [&quot;country&quot;, &quot;city&quot;, &quot;street&quot;, &quot;name&quot;]) // &quot;changning&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><p>这是之前在一篇博客里面看到的面试题，怎么将下面数组拍平？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, [2, [3, [4]]]]</span><br><span class=\"line\">var arr2 = [[1, 2, 3], [4], [5 ,6 , [7, 8]]]</span><br></pre></td></tr></table></figure></p>\n<p>我们可以用reduce这样写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flatten = function(arr) &#123;  </span><br><span class=\"line\">    return _.reduce(arr, function(originArr, item) &#123;</span><br><span class=\"line\">        return originArr.concat(Array.isArray(item) ? flatten(item) : item)</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里主要是对数组里面的项进行判断，如果是数组，那么就进行递归，一直到返回一个非数组的值，这样时候将这些值用一个空数组concat起来，最后就得到了一个新的扁平的数组。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"《编写可维护的JS》笔记","date":"2018-07-07T15:28:19.000Z","_content":"\n这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。\n## 编程风格\n### 格式化\n\n 1. 一行代码长度一般不超过80个字符\n 2. JS语句在换行的时候一般需要两个缩进\n 3. 在语义不相关的JS语句之间空行\n 4. 避免没有意义的函数/变量命名，如foo、tmp等等\n 5. 使用大写来定义常量\n\n### 注释\n 1. 多行注释使用/* */\n 2. hack注释\n<!-- more -->\n### 语句和表达式\n\n 1. 语句最好不要不带花括号\n 2. 严格模式下使用with语句会报错\n 3. 尽量避免在循环中使用continue\n 4. for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链\n 5. 严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中\n 6. 如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==\n 7. 避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中\n 8. 避免使用原始包装类型，如new String\n\n## 编程实践\n### UI层的松耦合\n\n 1. 避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替\n\n### 避免使用全局变量\n\n 1. 尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试\n 2. 尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面\n```javascript\n// 创建命名空间\nvar yourGlobal = {\n    namespace: function(ns) {\n        var paths = ns && ns.split(\".\") || [],\n            self = this\n        paths.reduce(function(result, currentAttr) {\n            self[result] = self[result] || {}\n            return self[result][currentAttr] = self[result][currentAttr] || {}\n        })  \n    }\n}\n// yourGlobal.a.b就是一个命名空间\nyourGlobal.namespace(\"a.b\")\nyourGlobal.a.b.c = 0\nconsole.log(yourGlobal.a.b)\n```\n\n### 事件处理\n\n 1. 事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试\n 2. 不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试\n\n### 避免空比较\n\n 1. 避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型\n 2. 检查引用值类型的时候使用instanceof方法\n\n### 将配置数据从代码中抽离\n### 抛出自定义错误\n\n 1. 针对会引发错误的场景，将错误抛出（throw），有利于调试\n\n### 不是你的对象不要动\n\n 1. 不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象\n 2. 对待已存在的对象应该不覆盖方法、不新增方法、不删除方法\n 3. 如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作\n 4. 使用[门面模式][1]，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为\n 5. 禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展\n 6. 密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封\n 7. 冻结对象Object.freeze()，禁止删除、增加和修改对象\n\n### 浏览器嗅探\n\n 1. 不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById\n 2. 避免使用浏览器推断和特性推断，尽量使用特性检测\n\n### 自动化\n### 文件和目录结构\n\n 1. 保持一个文件只有一个对象（组件？类？）\n 2. 相关的文件用目录分组\n 3. 保持第三方代码独立（npm了解一下？）\n 4. 目录结构（build、src、test）\n### 校验\n这几章使用的工具比较过时了，建议直接学习webpack\n### 压缩\n 5. 现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型\n 6. apache2和nginx内置了gzip作为http压缩\n### 文档化\n### 自动化测试\n书上的内容也比较老的，建议使用jest和mocha\n### 组装到一起\n 1. 编制打包计划\n 2. 开发版本的构建\n 3. 集成版本的构建\n 4. 发布版本的构建\n 5. 使用CI系统\n\n  [1]: http://www.cnblogs.com/skywang/articles/1375447.html","source":"_posts/《编写可维护的JS》笔记.md","raw":"---\ntitle: 《编写可维护的JS》笔记\ndate: 2018-07-07 23:28:19\ntags:\n    - 读书笔记\n    - 前端\ncategories:\n    - 前端\n---\n\n这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。\n## 编程风格\n### 格式化\n\n 1. 一行代码长度一般不超过80个字符\n 2. JS语句在换行的时候一般需要两个缩进\n 3. 在语义不相关的JS语句之间空行\n 4. 避免没有意义的函数/变量命名，如foo、tmp等等\n 5. 使用大写来定义常量\n\n### 注释\n 1. 多行注释使用/* */\n 2. hack注释\n<!-- more -->\n### 语句和表达式\n\n 1. 语句最好不要不带花括号\n 2. 严格模式下使用with语句会报错\n 3. 尽量避免在循环中使用continue\n 4. for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链\n 5. 严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中\n 6. 如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==\n 7. 避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中\n 8. 避免使用原始包装类型，如new String\n\n## 编程实践\n### UI层的松耦合\n\n 1. 避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替\n\n### 避免使用全局变量\n\n 1. 尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试\n 2. 尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面\n```javascript\n// 创建命名空间\nvar yourGlobal = {\n    namespace: function(ns) {\n        var paths = ns && ns.split(\".\") || [],\n            self = this\n        paths.reduce(function(result, currentAttr) {\n            self[result] = self[result] || {}\n            return self[result][currentAttr] = self[result][currentAttr] || {}\n        })  \n    }\n}\n// yourGlobal.a.b就是一个命名空间\nyourGlobal.namespace(\"a.b\")\nyourGlobal.a.b.c = 0\nconsole.log(yourGlobal.a.b)\n```\n\n### 事件处理\n\n 1. 事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试\n 2. 不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试\n\n### 避免空比较\n\n 1. 避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型\n 2. 检查引用值类型的时候使用instanceof方法\n\n### 将配置数据从代码中抽离\n### 抛出自定义错误\n\n 1. 针对会引发错误的场景，将错误抛出（throw），有利于调试\n\n### 不是你的对象不要动\n\n 1. 不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象\n 2. 对待已存在的对象应该不覆盖方法、不新增方法、不删除方法\n 3. 如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作\n 4. 使用[门面模式][1]，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为\n 5. 禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展\n 6. 密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封\n 7. 冻结对象Object.freeze()，禁止删除、增加和修改对象\n\n### 浏览器嗅探\n\n 1. 不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById\n 2. 避免使用浏览器推断和特性推断，尽量使用特性检测\n\n### 自动化\n### 文件和目录结构\n\n 1. 保持一个文件只有一个对象（组件？类？）\n 2. 相关的文件用目录分组\n 3. 保持第三方代码独立（npm了解一下？）\n 4. 目录结构（build、src、test）\n### 校验\n这几章使用的工具比较过时了，建议直接学习webpack\n### 压缩\n 5. 现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型\n 6. apache2和nginx内置了gzip作为http压缩\n### 文档化\n### 自动化测试\n书上的内容也比较老的，建议使用jest和mocha\n### 组装到一起\n 1. 编制打包计划\n 2. 开发版本的构建\n 3. 集成版本的构建\n 4. 发布版本的构建\n 5. 使用CI系统\n\n  [1]: http://www.cnblogs.com/skywang/articles/1375447.html","slug":"《编写可维护的JS》笔记","published":1,"updated":"2018-11-14T09:51:26.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxc0009fpzxhw6dyncr","content":"<p>这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。</p>\n<h2 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h2><h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><ol>\n<li>一行代码长度一般不超过80个字符</li>\n<li>JS语句在换行的时候一般需要两个缩进</li>\n<li>在语义不相关的JS语句之间空行</li>\n<li>避免没有意义的函数/变量命名，如foo、tmp等等</li>\n<li>使用大写来定义常量</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ol>\n<li>多行注释使用/<em> </em>/</li>\n<li><p>hack注释</p>\n<a id=\"more\"></a>\n<h3 id=\"语句和表达式\"><a href=\"#语句和表达式\" class=\"headerlink\" title=\"语句和表达式\"></a>语句和表达式</h3></li>\n<li><p>语句最好不要不带花括号</p>\n</li>\n<li>严格模式下使用with语句会报错</li>\n<li>尽量避免在循环中使用continue</li>\n<li>for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链</li>\n<li>严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中</li>\n<li>如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==</li>\n<li>避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中</li>\n<li>避免使用原始包装类型，如new String</li>\n</ol>\n<h2 id=\"编程实践\"><a href=\"#编程实践\" class=\"headerlink\" title=\"编程实践\"></a>编程实践</h2><h3 id=\"UI层的松耦合\"><a href=\"#UI层的松耦合\" class=\"headerlink\" title=\"UI层的松耦合\"></a>UI层的松耦合</h3><ol>\n<li>避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替</li>\n</ol>\n<h3 id=\"避免使用全局变量\"><a href=\"#避免使用全局变量\" class=\"headerlink\" title=\"避免使用全局变量\"></a>避免使用全局变量</h3><ol>\n<li>尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试</li>\n<li>尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> yourGlobal = &#123;</span><br><span class=\"line\">    namespace: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ns</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> paths = ns &amp;&amp; ns.split(<span class=\"string\">\".\"</span>) || [],</span><br><span class=\"line\">            self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        paths.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, currentAttr</span>) </span>&#123;</span><br><span class=\"line\">            self[result] = self[result] || &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[result][currentAttr] = self[result][currentAttr] || &#123;&#125;</span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// yourGlobal.a.b就是一个命名空间</span></span><br><span class=\"line\">yourGlobal.namespace(<span class=\"string\">\"a.b\"</span>)</span><br><span class=\"line\">yourGlobal.a.b.c = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(yourGlobal.a.b)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><ol>\n<li>事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试</li>\n<li>不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试</li>\n</ol>\n<h3 id=\"避免空比较\"><a href=\"#避免空比较\" class=\"headerlink\" title=\"避免空比较\"></a>避免空比较</h3><ol>\n<li>避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型</li>\n<li>检查引用值类型的时候使用instanceof方法</li>\n</ol>\n<h3 id=\"将配置数据从代码中抽离\"><a href=\"#将配置数据从代码中抽离\" class=\"headerlink\" title=\"将配置数据从代码中抽离\"></a>将配置数据从代码中抽离</h3><h3 id=\"抛出自定义错误\"><a href=\"#抛出自定义错误\" class=\"headerlink\" title=\"抛出自定义错误\"></a>抛出自定义错误</h3><ol>\n<li>针对会引发错误的场景，将错误抛出（throw），有利于调试</li>\n</ol>\n<h3 id=\"不是你的对象不要动\"><a href=\"#不是你的对象不要动\" class=\"headerlink\" title=\"不是你的对象不要动\"></a>不是你的对象不要动</h3><ol>\n<li>不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象</li>\n<li>对待已存在的对象应该不覆盖方法、不新增方法、不删除方法</li>\n<li>如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作</li>\n<li>使用<a href=\"http://www.cnblogs.com/skywang/articles/1375447.html\" target=\"_blank\" rel=\"noopener\">门面模式</a>，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为</li>\n<li>禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展</li>\n<li>密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封</li>\n<li>冻结对象Object.freeze()，禁止删除、增加和修改对象</li>\n</ol>\n<h3 id=\"浏览器嗅探\"><a href=\"#浏览器嗅探\" class=\"headerlink\" title=\"浏览器嗅探\"></a>浏览器嗅探</h3><ol>\n<li>不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById</li>\n<li>避免使用浏览器推断和特性推断，尽量使用特性检测</li>\n</ol>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><h3 id=\"文件和目录结构\"><a href=\"#文件和目录结构\" class=\"headerlink\" title=\"文件和目录结构\"></a>文件和目录结构</h3><ol>\n<li>保持一个文件只有一个对象（组件？类？）</li>\n<li>相关的文件用目录分组</li>\n<li>保持第三方代码独立（npm了解一下？）</li>\n<li>目录结构（build、src、test）<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3>这几章使用的工具比较过时了，建议直接学习webpack<h3 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h3></li>\n<li>现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型</li>\n<li>apache2和nginx内置了gzip作为http压缩<h3 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3>书上的内容也比较老的，建议使用jest和mocha<h3 id=\"组装到一起\"><a href=\"#组装到一起\" class=\"headerlink\" title=\"组装到一起\"></a>组装到一起</h3></li>\n<li>编制打包计划</li>\n<li>开发版本的构建</li>\n<li>集成版本的构建</li>\n<li>发布版本的构建</li>\n<li>使用CI系统</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这里只记录了对自己有用的部分，更详细的内容请看《编写可维护的Javascipt》原书。</p>\n<h2 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h2><h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><ol>\n<li>一行代码长度一般不超过80个字符</li>\n<li>JS语句在换行的时候一般需要两个缩进</li>\n<li>在语义不相关的JS语句之间空行</li>\n<li>避免没有意义的函数/变量命名，如foo、tmp等等</li>\n<li>使用大写来定义常量</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ol>\n<li>多行注释使用/<em> </em>/</li>\n<li><p>hack注释</p>","more":"<h3 id=\"语句和表达式\"><a href=\"#语句和表达式\" class=\"headerlink\" title=\"语句和表达式\"></a>语句和表达式</h3></li>\n<li><p>语句最好不要不带花括号</p>\n</li>\n<li>严格模式下使用with语句会报错</li>\n<li>尽量避免在循环中使用continue</li>\n<li>for in循环的时候最好使用hasOwnProperty判断，除非你想查找原型链</li>\n<li>严格模式（use strict;）最好不要用在全局中，如果想在多个函数使用，可以放到立即执行函数中</li>\n<li>如果布尔值和数字比较，会把布尔值转换为数字，如果一个值是对象，那会调用对象的valueOf方法，如果没有valueOf，那就调用toString方法，得到原始类型值后再比较，通常不建议使用==和!=，推荐===和!==</li>\n<li>避免使用Function和eval，尽管eval可以用在某些JSON操作中，Function则可以用在lodash/underscore的template中</li>\n<li>避免使用原始包装类型，如new String</li>\n</ol>\n<h2 id=\"编程实践\"><a href=\"#编程实践\" class=\"headerlink\" title=\"编程实践\"></a>编程实践</h2><h3 id=\"UI层的松耦合\"><a href=\"#UI层的松耦合\" class=\"headerlink\" title=\"UI层的松耦合\"></a>UI层的松耦合</h3><ol>\n<li>避免在JS中写HTML，可以考虑使用客户端/服务端模板来代替</li>\n</ol>\n<h3 id=\"避免使用全局变量\"><a href=\"#避免使用全局变量\" class=\"headerlink\" title=\"避免使用全局变量\"></a>避免使用全局变量</h3><ol>\n<li>尽量不要去创建全局变量，函数尽量不要依赖全局变量，这样会让你的测试更容易测试</li>\n<li>尽量使用单变量（对象），将需要定义的全局变量都放到它的属性下面<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> yourGlobal = &#123;</span><br><span class=\"line\">    namespace: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ns</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> paths = ns &amp;&amp; ns.split(<span class=\"string\">\".\"</span>) || [],</span><br><span class=\"line\">            self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        paths.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, currentAttr</span>) </span>&#123;</span><br><span class=\"line\">            self[result] = self[result] || &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[result][currentAttr] = self[result][currentAttr] || &#123;&#125;</span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// yourGlobal.a.b就是一个命名空间</span></span><br><span class=\"line\">yourGlobal.namespace(<span class=\"string\">\"a.b\"</span>)</span><br><span class=\"line\">yourGlobal.a.b.c = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(yourGlobal.a.b)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><ol>\n<li>事件触发的时候隔离应用逻辑，将应用逻辑从事件处理程序中抽离出来，便于测试</li>\n<li>不要分发事件对象event，应用逻辑不应该依赖于event对象，如果需要event中的某属性，那么直接传入这个属性，不应该传入event对象，这样也便于测试</li>\n</ol>\n<h3 id=\"避免空比较\"><a href=\"#避免空比较\" class=\"headerlink\" title=\"避免空比较\"></a>避免空比较</h3><ol>\n<li>避免空比较，多使用typeof来判断类型，除非可以确定期望值的类型</li>\n<li>检查引用值类型的时候使用instanceof方法</li>\n</ol>\n<h3 id=\"将配置数据从代码中抽离\"><a href=\"#将配置数据从代码中抽离\" class=\"headerlink\" title=\"将配置数据从代码中抽离\"></a>将配置数据从代码中抽离</h3><h3 id=\"抛出自定义错误\"><a href=\"#抛出自定义错误\" class=\"headerlink\" title=\"抛出自定义错误\"></a>抛出自定义错误</h3><ol>\n<li>针对会引发错误的场景，将错误抛出（throw），有利于调试</li>\n</ol>\n<h3 id=\"不是你的对象不要动\"><a href=\"#不是你的对象不要动\" class=\"headerlink\" title=\"不是你的对象不要动\"></a>不是你的对象不要动</h3><ol>\n<li>不是你创建的对象，那么就不要修改，比如原生对象、DOM对象、BOM对象和类库的对象</li>\n<li>对待已存在的对象应该不覆盖方法、不新增方法、不删除方法</li>\n<li>如果不得不修改，可以继承或复制这个对象得到一个自己的对象，再对自己的这个对象进行操作</li>\n<li>使用<a href=\"http://www.cnblogs.com/skywang/articles/1375447.html\" target=\"_blank\" rel=\"noopener\">门面模式</a>，门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为</li>\n<li>禁止扩展对象Object.preventExtension()，禁止为对象增加属性，但是可以删除和修改已有的属性，Object.isExtensible函数可以检查是否不可扩展</li>\n<li>密封对象Object.seal()，禁止删除和增加属性，但是可以修改已有的属性，Object.isSealed函数可以检查是否密封</li>\n<li>冻结对象Object.freeze()，禁止删除、增加和修改对象</li>\n</ol>\n<h3 id=\"浏览器嗅探\"><a href=\"#浏览器嗅探\" class=\"headerlink\" title=\"浏览器嗅探\"></a>浏览器嗅探</h3><ol>\n<li>不能根据一个特性去推断另一个特性，比如支持getElementsByTagName就一定支持getElementById</li>\n<li>避免使用浏览器推断和特性推断，尽量使用特性检测</li>\n</ol>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><h3 id=\"文件和目录结构\"><a href=\"#文件和目录结构\" class=\"headerlink\" title=\"文件和目录结构\"></a>文件和目录结构</h3><ol>\n<li>保持一个文件只有一个对象（组件？类？）</li>\n<li>相关的文件用目录分组</li>\n<li>保持第三方代码独立（npm了解一下？）</li>\n<li>目录结构（build、src、test）<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3>这几章使用的工具比较过时了，建议直接学习webpack<h3 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h3></li>\n<li>现代浏览器都支持http压缩，并且会发送一个http头作为请求的一部分来指名压缩类型的，比如：Accept-Encoding: gzip, deflate，服务器在http请求头中发现这些信息，会明白浏览器是支持通过gzip或者deflate对压缩后的文件执行解压缩的，会返回Content-Encoding: gzip来指名压缩的类型</li>\n<li>apache2和nginx内置了gzip作为http压缩<h3 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3>书上的内容也比较老的，建议使用jest和mocha<h3 id=\"组装到一起\"><a href=\"#组装到一起\" class=\"headerlink\" title=\"组装到一起\"></a>组装到一起</h3></li>\n<li>编制打包计划</li>\n<li>开发版本的构建</li>\n<li>集成版本的构建</li>\n<li>发布版本的构建</li>\n<li>使用CI系统</li>\n</ol>"},{"title":"塞尔达传说","date":"2018-10-14T09:48:46.000Z","_content":"## 海拉鲁王国\n### 海拉鲁\n位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。\n在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。\n相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。（待续…）\n## 预言\n## 林克\n## 神兽\n## 英杰\n## 盖侬来袭\n## 背叛\n## end","source":"_posts/塞尔达传说.md","raw":"---\ntitle: 塞尔达传说\ndate: 2018-10-14 17:48:46\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: \n    - 小说\n---\n## 海拉鲁王国\n### 海拉鲁\n位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。\n在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。\n相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。（待续…）\n## 预言\n## 林克\n## 神兽\n## 英杰\n## 盖侬来袭\n## 背叛\n## end","slug":"塞尔达传说","published":1,"updated":"2018-11-22T11:29:17.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxe000cfpzxxomas6be","content":"<h2 id=\"海拉鲁王国\"><a href=\"#海拉鲁王国\" class=\"headerlink\" title=\"海拉鲁王国\"></a>海拉鲁王国</h2><h3 id=\"海拉鲁\"><a href=\"#海拉鲁\" class=\"headerlink\" title=\"海拉鲁\"></a>海拉鲁</h3><p>位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。<br>在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。<br>相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。（待续…）</p>\n<h2 id=\"预言\"><a href=\"#预言\" class=\"headerlink\" title=\"预言\"></a>预言</h2><h2 id=\"林克\"><a href=\"#林克\" class=\"headerlink\" title=\"林克\"></a>林克</h2><h2 id=\"神兽\"><a href=\"#神兽\" class=\"headerlink\" title=\"神兽\"></a>神兽</h2><h2 id=\"英杰\"><a href=\"#英杰\" class=\"headerlink\" title=\"英杰\"></a>英杰</h2><h2 id=\"盖侬来袭\"><a href=\"#盖侬来袭\" class=\"headerlink\" title=\"盖侬来袭\"></a>盖侬来袭</h2><h2 id=\"背叛\"><a href=\"#背叛\" class=\"headerlink\" title=\"背叛\"></a>背叛</h2><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"海拉鲁王国\"><a href=\"#海拉鲁王国\" class=\"headerlink\" title=\"海拉鲁王国\"></a>海拉鲁王国</h2><h3 id=\"海拉鲁\"><a href=\"#海拉鲁\" class=\"headerlink\" title=\"海拉鲁\"></a>海拉鲁</h3><p>位于海拉鲁地区中央的海拉鲁王国，迄今为止已经经历了上万年的岁月，这里经济繁荣，人民生活安逸。<br>在海拉鲁王国数万年的历史长河中，流传着许多勇者的故事，其中以灾厄盖侬与剑士、公主战斗的故事深入人心。海拉鲁的历史，也是和灾厄盖侬的抗争史，拥有驱魔之剑的勇士和拥有女神之血的公主多次封印复活的盖侬。<br>相传盖侬在数万年前突然出现，毁灭了无数城镇，海拉鲁大地遭受破坏后一片狼藉。就在人们绝望之时，一位勇敢的剑士挺身而出与盖侬展开了战斗，海拉鲁王国的公主在他们战斗的时候趁机封印了盖侬，王国得以安宁。（待续…）</p>\n<h2 id=\"预言\"><a href=\"#预言\" class=\"headerlink\" title=\"预言\"></a>预言</h2><h2 id=\"林克\"><a href=\"#林克\" class=\"headerlink\" title=\"林克\"></a>林克</h2><h2 id=\"神兽\"><a href=\"#神兽\" class=\"headerlink\" title=\"神兽\"></a>神兽</h2><h2 id=\"英杰\"><a href=\"#英杰\" class=\"headerlink\" title=\"英杰\"></a>英杰</h2><h2 id=\"盖侬来袭\"><a href=\"#盖侬来袭\" class=\"headerlink\" title=\"盖侬来袭\"></a>盖侬来袭</h2><h2 id=\"背叛\"><a href=\"#背叛\" class=\"headerlink\" title=\"背叛\"></a>背叛</h2><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>"},{"title":"世界变了样","date":"2018-09-25T09:51:51.000Z","top":1000,"_content":"## 2018.09.25\n下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁百感交集。\n初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。\n那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。\n\n## 2018.09.30\n十一长假的第一天，一个人茕茕地坐了一天高铁。\n与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。\n自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。\n可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。\n古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。\n\n## 2018.10.07\n在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。\n在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。\n也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。\n所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。\n\n","source":"_posts/世界变了样.md","raw":"---\ntitle: 世界变了样\ndate: 2018-09-25 17:51:51\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\ntop: 1000\n---\n## 2018.09.25\n下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁百感交集。\n初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。\n那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。\n\n## 2018.09.30\n十一长假的第一天，一个人茕茕地坐了一天高铁。\n与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。\n自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。\n可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。\n古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。\n\n## 2018.10.07\n在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。\n在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。\n也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。\n所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。\n\n","slug":"世界变了样","published":1,"updated":"2018-11-14T09:55:59.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxh000dfpzxx45qgwyh","content":"<h2 id=\"2018-09-25\"><a href=\"#2018-09-25\" class=\"headerlink\" title=\"2018.09.25\"></a>2018.09.25</h2><p>下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁百感交集。<br>初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。<br>那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。</p>\n<h2 id=\"2018-09-30\"><a href=\"#2018-09-30\" class=\"headerlink\" title=\"2018.09.30\"></a>2018.09.30</h2><p>十一长假的第一天，一个人茕茕地坐了一天高铁。<br>与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。<br>自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。<br>可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。<br>古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。</p>\n<h2 id=\"2018-10-07\"><a href=\"#2018-10-07\" class=\"headerlink\" title=\"2018.10.07\"></a>2018.10.07</h2><p>在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。<br>在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。<br>也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。<br>所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2018-09-25\"><a href=\"#2018-09-25\" class=\"headerlink\" title=\"2018.09.25\"></a>2018.09.25</h2><p>下午的时候，我在办公楼里听到外面传来时断时续的音乐，回忆随音乐涌上心头，不禁百感交集。<br>初中时期的生活，即使学业繁重，大家也能忙里偷闲，不知什么是愁，毕竟不用操心事业，也不会担心未来，唯一困扰着我们的就只有考试。<br>那时我们每个月都会有一次全校规模的月考，偶尔我也会被分到更靠近校外的考场。大家坐在教室里埋头思索着试卷上的题目，从教室外传来嘈杂的音乐和小摊小贩的叫卖声，有时我会突然停下笔来闭着眼睛深吸一口气，用心去感受市井生活的气息。也许舒适闲暇的生活只有在失去后才懂得去珍惜回味吧。</p>\n<h2 id=\"2018-09-30\"><a href=\"#2018-09-30\" class=\"headerlink\" title=\"2018.09.30\"></a>2018.09.30</h2><p>十一长假的第一天，一个人茕茕地坐了一天高铁。<br>与之前心心念叨想要回家的心情不同，到家之后反而想早点儿离开了。原本只是想回家放松一下，每隔一段时间我都需要释放一下生活和工作上的压力，这种日复一日的生活让我早已疲倦。<br>自从长大后，我似乎就不怎么喜欢回家了，唯一牵挂的只有家人，这也是我和家乡仅有的纽带。<br>可是对于一个怀旧的人来说，我也经常会在深夜回想起一些往事，沉浸在其中不能自拔。我非常害怕时间流逝，害怕眼前的人和事都变成回忆。也许在几年后的一个深夜，我想起了现在的生活，可是却再也无法亲身体验，只留下很多遗憾。<br>古人告诫我们要珍惜眼前，可什么才是珍惜呢？珍惜了就不会有遗憾了吗？我也常常思考，如果当初选了另一条路现在又会看到怎样的风景呢？也许正是因为人生不能重来，我们才会有很多遗憾。遗憾是美好的，完美的事物让人觉得不够真实，带有遗憾的事物才会让人刻骨铭心。</p>\n<h2 id=\"2018-10-07\"><a href=\"#2018-10-07\" class=\"headerlink\" title=\"2018.10.07\"></a>2018.10.07</h2><p>在我哥家里不经意间瞥到嫂子上课的英语周报，不禁想起来我的高中岁月。<br>在这个无所事事又迷茫的年纪，我愈发怀念高中的那段生活，只要努力耕耘就会有收获，这种为了目标努力奋斗的岁月也许一辈子都没有几次。<br>也许几年后我也会走上买房、结婚、生子这条道路，也许十年后某天我会突然想到刚毕业后的这几年，没有约束，也没有那么大的压力和责任，拥有更多的个人时间，还没有成为油腻中年大叔，甚至可以不要脸的称自己还是个少年。<br>所以，从现在开始不要再浪费自己仅剩的青春了，不要把自己局限在出租屋中，要多出去看看外面的世界，不要熬夜，饮食要清淡，多锻炼保持身体健康。</p>\n"},{"title":"实现一个bind函数","date":"2018-05-30T14:26:14.000Z","_content":"目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。\n## bind函数 ##\nbind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。\n```\nvar a = 10;\nvar test = function() {\n    console.log(this.a);\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest = test.bind({a: \"111\"})\nbindTest(); // 111\n```\n从上面这个例子可以看出来，bind函数改变了test函数中this的指向。\n除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。\n<!-- more -->\n### 柯里化 ###\nbind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。\n```\nvar test = function(b) {\n    return this.a + b;\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest1 = test.bind({a: 20});\nbindTest1(10); // 30\n// 这里的bind是个柯里化的函数\nvar bindTest2 = test.bind({a: 20}, 10);\nbindTest2(); // 30;\n```\n### 构造函数无效 ###\n其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。\n```\nvar a = 10;\nvar Test = function(a) {\n    console.log(this.a);\n}\nvar bindTest = Test.bind({a: 20});\nbindTest(); // 20\n// 在new的时候，Test中的this并没有指向bind中的对象\nnew bindTest(); // undefined\n```\n## 实现一个bind ##\n我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。\n\n然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。\n```\nFunction.prototype.bind = function() {\n    var args = arguments;\n    // 获取到新的上下文\n    var context = args[0];\n    // 保存当前的函数\n    var func = this;\n    // 获取其他的参数\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n        // 将两次获取到的参数合并\n        Array.prototype.push.apply(thisArgs, arguments)\n        // 使用apply改变上下文\n        return func.apply(context, thisArgs);\n    }\n    return returnFunc;\n}\n```\n这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。\n\n这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？\n\n所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？\n\n关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：[在js里面当new了一个对象时，这中间发生了什么？][1]\n\n所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。\n\n但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n  \tvar returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof returnFunc ? this : context, thisArgs);\n    }\n    return returnFunc\n}\nfunction foo(c) {\n    this.b = 100;\n    console.log(c);\n    return this.a;\n}\n\nvar func =  foo.bind({a:1});\nvar newFunc = new func() // undefined\n```\n但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。\n所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof func ? this : context, thisArgs);\n    }\n    returnFunc.prototype = new func()\n    return returnFunc\n}\n```\n这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：[Function.prototype.bind()][2]\n\n参考链接：\n+ [MDN：Function.prototype.bind()\n][2]\n+ [手写bind()函数，理解MDN上的标准Polyfill][3]\n\n\n  [1]: https://segmentfault.com/q/1010000006670906\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n  [3]: https://blog.csdn.net/u010552788/article/details/50850453","source":"_posts/实现一个bind函数.md","raw":"---\ntitle: 实现一个bind函数\ndate: 2018-05-30 22:26:14\ntags:\n- polyfill\n- 前端\n- 编程\ncategories: \n    - 前端\n---\n目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。\n## bind函数 ##\nbind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。\n```\nvar a = 10;\nvar test = function() {\n    console.log(this.a);\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest = test.bind({a: \"111\"})\nbindTest(); // 111\n```\n从上面这个例子可以看出来，bind函数改变了test函数中this的指向。\n除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。\n<!-- more -->\n### 柯里化 ###\nbind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。\n```\nvar test = function(b) {\n    return this.a + b;\n}\n// 如果直接执行test，最终打印的是10.\nvar bindTest1 = test.bind({a: 20});\nbindTest1(10); // 30\n// 这里的bind是个柯里化的函数\nvar bindTest2 = test.bind({a: 20}, 10);\nbindTest2(); // 30;\n```\n### 构造函数无效 ###\n其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。\n```\nvar a = 10;\nvar Test = function(a) {\n    console.log(this.a);\n}\nvar bindTest = Test.bind({a: 20});\nbindTest(); // 20\n// 在new的时候，Test中的this并没有指向bind中的对象\nnew bindTest(); // undefined\n```\n## 实现一个bind ##\n我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。\n\n然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。\n```\nFunction.prototype.bind = function() {\n    var args = arguments;\n    // 获取到新的上下文\n    var context = args[0];\n    // 保存当前的函数\n    var func = this;\n    // 获取其他的参数\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n        // 将两次获取到的参数合并\n        Array.prototype.push.apply(thisArgs, arguments)\n        // 使用apply改变上下文\n        return func.apply(context, thisArgs);\n    }\n    return returnFunc;\n}\n```\n这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。\n\n这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？\n\n所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？\n\n关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：[在js里面当new了一个对象时，这中间发生了什么？][1]\n\n所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。\n\n但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n  \tvar returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof returnFunc ? this : context, thisArgs);\n    }\n    return returnFunc\n}\nfunction foo(c) {\n    this.b = 100;\n    console.log(c);\n    return this.a;\n}\n\nvar func =  foo.bind({a:1});\nvar newFunc = new func() // undefined\n```\n但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。\n所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。\n```\nFunction.prototype.bind = function() {\n    var args = arguments || [];\n    var context = args[0];\n    var func = this;\n    var thisArgs = Array.prototype.slice.call(args, 1);\n    var returnFunc = function() {\n      Array.prototype.push.apply(thisArgs, arguments);\n      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）\n      return func.apply(this instanceof func ? this : context, thisArgs);\n    }\n    returnFunc.prototype = new func()\n    return returnFunc\n}\n```\n这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：[Function.prototype.bind()][2]\n\n参考链接：\n+ [MDN：Function.prototype.bind()\n][2]\n+ [手写bind()函数，理解MDN上的标准Polyfill][3]\n\n\n  [1]: https://segmentfault.com/q/1010000006670906\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n  [3]: https://blog.csdn.net/u010552788/article/details/50850453","slug":"实现一个bind函数","published":1,"updated":"2018-11-22T11:28:58.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxk000gfpzxo3kep36u","content":"<p>目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。</p>\n<h2 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h2><p>bind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var test = function() &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest = test.bind(&#123;a: &quot;111&quot;&#125;)</span><br><span class=\"line\">bindTest(); // 111</span><br></pre></td></tr></table></figure></p>\n<p>从上面这个例子可以看出来，bind函数改变了test函数中this的指向。<br>除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。<br><a id=\"more\"></a></p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>bind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test = function(b) &#123;</span><br><span class=\"line\">    return this.a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest1 = test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest1(10); // 30</span><br><span class=\"line\">// 这里的bind是个柯里化的函数</span><br><span class=\"line\">var bindTest2 = test.bind(&#123;a: 20&#125;, 10);</span><br><span class=\"line\">bindTest2(); // 30;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"构造函数无效\"><a href=\"#构造函数无效\" class=\"headerlink\" title=\"构造函数无效\"></a>构造函数无效</h3><p>其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var Test = function(a) &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bindTest = Test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest(); // 20</span><br><span class=\"line\">// 在new的时候，Test中的this并没有指向bind中的对象</span><br><span class=\"line\">new bindTest(); // undefined</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现一个bind\"><a href=\"#实现一个bind\" class=\"headerlink\" title=\"实现一个bind\"></a>实现一个bind</h2><p>我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。</p>\n<p>然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments;</span><br><span class=\"line\">    // 获取到新的上下文</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    // 保存当前的函数</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    // 获取其他的参数</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">        // 将两次获取到的参数合并</span><br><span class=\"line\">        Array.prototype.push.apply(thisArgs, arguments)</span><br><span class=\"line\">        // 使用apply改变上下文</span><br><span class=\"line\">        return func.apply(context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。</p>\n<p>这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？</p>\n<p>所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？</p>\n<p>关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：<a href=\"https://segmentfault.com/q/1010000006670906\" target=\"_blank\" rel=\"noopener\">在js里面当new了一个对象时，这中间发生了什么？</a></p>\n<p>所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。</p>\n<p>但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">  \tvar returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof returnFunc ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo(c) &#123;</span><br><span class=\"line\">    this.b = 100;</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">    return this.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var func =  foo.bind(&#123;a:1&#125;);</span><br><span class=\"line\">var newFunc = new func() // undefined</span><br></pre></td></tr></table></figure></p>\n<p>但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。<br>所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof func ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    returnFunc.prototype = new func()</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN：Function.prototype.bind()\n</a></li>\n<li><a href=\"https://blog.csdn.net/u010552788/article/details/50850453\" target=\"_blank\" rel=\"noopener\">手写bind()函数，理解MDN上的标准Polyfill</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>目前的打算还是继续深入前端基础知识，所以打算从polyfill开始做起。</p>\n<h2 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h2><p>bind函数最常见的用法是绑定函数的上下文，比如在setTimeout中的this一般都是指向window，如果我们想改变上下文，这里可以使用bind函数来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var test = function() &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest = test.bind(&#123;a: &quot;111&quot;&#125;)</span><br><span class=\"line\">bindTest(); // 111</span><br></pre></td></tr></table></figure></p>\n<p>从上面这个例子可以看出来，bind函数改变了test函数中this的指向。<br>除此之外，bind函数还有两个特殊的用法，一个是柯里化，一个是绑定构造函数无效。<br>","more":"</p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>bind函数的柯里化其实是不完全的，其实只做了一次柯里化，看过MDN的polyfill实现后也就理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test = function(b) &#123;</span><br><span class=\"line\">    return this.a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 如果直接执行test，最终打印的是10.</span><br><span class=\"line\">var bindTest1 = test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest1(10); // 30</span><br><span class=\"line\">// 这里的bind是个柯里化的函数</span><br><span class=\"line\">var bindTest2 = test.bind(&#123;a: 20&#125;, 10);</span><br><span class=\"line\">bindTest2(); // 30;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"构造函数无效\"><a href=\"#构造函数无效\" class=\"headerlink\" title=\"构造函数无效\"></a>构造函数无效</h3><p>其实准确的来说，bind并不是对构造函数无效，只是对new的时候无效，如果直接执行构造函数，那么还是有效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 10;</span><br><span class=\"line\">var Test = function(a) &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bindTest = Test.bind(&#123;a: 20&#125;);</span><br><span class=\"line\">bindTest(); // 20</span><br><span class=\"line\">// 在new的时候，Test中的this并没有指向bind中的对象</span><br><span class=\"line\">new bindTest(); // undefined</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现一个bind\"><a href=\"#实现一个bind\" class=\"headerlink\" title=\"实现一个bind\"></a>实现一个bind</h2><p>我们可以先实现一个简易版本的bind，再不断完善。由于是在函数上调用bind，所以bind方法肯定存在于Function.prototype上面，其次bind函数要有改变上下文的作用，我们想一想，怎么才能改变上下文？没错，就是call和apply方法。</p>\n<p>然后还要可以柯里化，还好这里只是简单的柯里化，我们只要在bind中返回一个新的函数，并且将前后两次的参数收集起来就可以做到了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments;</span><br><span class=\"line\">    // 获取到新的上下文</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    // 保存当前的函数</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    // 获取其他的参数</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">        // 将两次获取到的参数合并</span><br><span class=\"line\">        Array.prototype.push.apply(thisArgs, arguments)</span><br><span class=\"line\">        // 使用apply改变上下文</span><br><span class=\"line\">        return func.apply(context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实现了一个简单的bind函数，可以支持简单的柯里化，也可以改变上下文作用域，但是在new一个构造函数的时候还是会改变上下文。</p>\n<p>这里我们需要考虑一下，怎么做才能让在new的时候无效，而其他时候有效？</p>\n<p>所以我们需要在returnFunc里面的apply第一个参数进行判断，如果是用new调用构造函数的时候应该传入函数本身，否则才应该传入context，那么该怎么判断是new调用呢？</p>\n<p>关于在new一个构造函数的时候，这中间做了什么，建议参考这个问题：<a href=\"https://segmentfault.com/q/1010000006670906\" target=\"_blank\" rel=\"noopener\">在js里面当new了一个对象时，这中间发生了什么？</a></p>\n<p>所以我们很容易得出，由于最终返回的是returnFunc，所以最终是new的这个函数，而在new的过程中，会执行一遍这个函数，所以这个过程中returnFunc里面的this指向new的时候创建的那个对象，而那个新对象指向returnFunc函数。</p>\n<p>但是我们希望调用后的结果只是new的func函数，和我们正常new func一样，所以这里猜想，在returnFunc中，一定会将其this传入func函数中执行，这样才能满足这几个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">  \tvar returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof returnFunc ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo(c) &#123;</span><br><span class=\"line\">    this.b = 100;</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">    return this.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var func =  foo.bind(&#123;a:1&#125;);</span><br><span class=\"line\">var newFunc = new func() // undefined</span><br></pre></td></tr></table></figure></p>\n<p>但是这样还是不够的，如果foo函数原型上面还有更多的方法和属性，这里的newFunc是没法获取到的，因为foo.prototype不在newFunc的原型链上面。<br>所以这里我们需要做一些改动，由于传入apply的是returnFunc的一个实例（this），所以我们应该让returnFunc继承func函数，最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function() &#123;</span><br><span class=\"line\">    var args = arguments || [];</span><br><span class=\"line\">    var context = args[0];</span><br><span class=\"line\">    var func = this;</span><br><span class=\"line\">    var thisArgs = Array.prototype.slice.call(args, 1);</span><br><span class=\"line\">    var returnFunc = function() &#123;</span><br><span class=\"line\">      Array.prototype.push.apply(thisArgs, arguments);</span><br><span class=\"line\">      // 最关键的一步，this是new returnFunc中创建的那个新对象，此时将其传给func函数，其实相当于做了new操作最后一步（执行构造函数）</span><br><span class=\"line\">      return func.apply(this instanceof func ? this : context, thisArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    returnFunc.prototype = new func()</span><br><span class=\"line\">    return returnFunc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就完成了一个bind函数，这与MDN上面的polyfill实现方式大同小异，这里可以参考一下MDN的实现：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN：Function.prototype.bind()\n</a></li>\n<li><a href=\"https://blog.csdn.net/u010552788/article/details/50850453\" target=\"_blank\" rel=\"noopener\">手写bind()函数，理解MDN上的标准Polyfill</a></li>\n</ul>"},{"title":"富爸爸穷爸爸","date":"2018-04-19T14:39:02.000Z","_content":"去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。\n## 笔记 ##\n这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：\n+ 穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。\n+ 穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。\n+ 只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。\n+ 学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。\n+ 净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。\n+ 通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。\n+ 关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。\n<!-- more -->\n\n![2][2]\n\n![3][3]\n知乎大V温酒有更简单的总结: [《富爸爸，穷爸爸》这本书有何价值？][1]\n## 老鼠赛跑 ##\n前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。\n活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。\n这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。\n怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。\n游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。\n这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。\n如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。\n## 游戏心得 ##\n我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。\n游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。\n还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。\n## 总结 ##\n两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？\n之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。\n所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。\n\n[1]: https://www.zhihu.com/question/20528677/answer/169582274\n[2]: https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\n[3]: https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\n<head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/富爸爸穷爸爸.md","raw":"---\ntitle: 富爸爸穷爸爸\ndate: 2018-04-19 22:39:02\ntags:\n- 理财\n- 思考\ncategories: \n    - 理财\n---\n去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。\n## 笔记 ##\n这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：\n+ 穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。\n+ 穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。\n+ 只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。\n+ 学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。\n+ 净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。\n+ 通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。\n+ 关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。\n<!-- more -->\n\n![2][2]\n\n![3][3]\n知乎大V温酒有更简单的总结: [《富爸爸，穷爸爸》这本书有何价值？][1]\n## 老鼠赛跑 ##\n前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。\n活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。\n这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。\n怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。\n游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。\n这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。\n如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。\n## 游戏心得 ##\n我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。\n游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。\n还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。\n## 总结 ##\n两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？\n之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。\n所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。\n\n[1]: https://www.zhihu.com/question/20528677/answer/169582274\n[2]: https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\n[3]: https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\n<head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"富爸爸穷爸爸","published":1,"updated":"2018-11-22T11:29:05.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxn000hfpzxr40nhcpc","content":"<p>去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。</p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：</p>\n<ul>\n<li>穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。</li>\n<li>穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。</li>\n<li>只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。</li>\n<li>学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。</li>\n<li>净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。</li>\n<li>通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。</li>\n<li>关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。<a id=\"more\"></a>\n</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\" alt=\"2\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\" alt=\"3\"><br>知乎大V温酒有更简单的总结: <a href=\"https://www.zhihu.com/question/20528677/answer/169582274\" target=\"_blank\" rel=\"noopener\">《富爸爸，穷爸爸》这本书有何价值？</a></p>\n<h2 id=\"老鼠赛跑\"><a href=\"#老鼠赛跑\" class=\"headerlink\" title=\"老鼠赛跑\"></a>老鼠赛跑</h2><p>前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。<br>活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。<br>这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。<br>怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。<br>游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。<br>这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。<br>如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。</p>\n<h2 id=\"游戏心得\"><a href=\"#游戏心得\" class=\"headerlink\" title=\"游戏心得\"></a>游戏心得</h2><p>我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。<br>游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。<br>还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？<br>之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。<br>所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>去年在知乎上看到很多人推荐《富爸爸，穷爸爸》这本书，我就利用中午在公司食堂排队时间看完了这本书，这才算是理财入了门。</p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>这本书虽然很不错，但是中间废话较多，我这里总结了几个重要的点：</p>\n<ul>\n<li>穷人和中产阶级无法分清楚资产和负债的区别，经常把房子等负债误当做资产，这里我的理解是在你能力范围之内的才叫资产，在你能力范围之外的叫负债。</li>\n<li>穷人和中产阶级一般只有工资的收入，又由于房子等负债的拖累，导致收入全部流向支出和负债，当有宝贵的机会来临的时候，这些人没有闲钱导致无法抓住，他们过于追求安稳。</li>\n<li>只买入可以带来收入的资产，并且注意降低负债和支出，这让你有更多的钱投入资产项。</li>\n<li>学校只是教你成为一个伟大的雇员，而不是雇主，为别人打工实际上给自己带来的收益很小，甚至永远不够你的负债。</li>\n<li>净资产包括非现金资产，财富则衡量着你的钱能够挣多少钱，以及你的财务生存能力。</li>\n<li>通过投资等方式让你的钱不断生钱，这样可以让自己的财富源源不断的增加，如果想支出更多，就要想办法让自己的钱生更多的钱。</li>\n<li>关于自己的事业，而不是职业，比如我的职业是程序员，但我的事业是什么？我拥有一个公司吗？不，并没有。","more":"</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5de47cded978ea5351594f55793a9271_hd.jpg\" alt=\"2\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9eeb398ae82dc67f2218e0f5dca7cb9a_hd.jpg\" alt=\"3\"><br>知乎大V温酒有更简单的总结: <a href=\"https://www.zhihu.com/question/20528677/answer/169582274\" target=\"_blank\" rel=\"noopener\">《富爸爸，穷爸爸》这本书有何价值？</a></p>\n<h2 id=\"老鼠赛跑\"><a href=\"#老鼠赛跑\" class=\"headerlink\" title=\"老鼠赛跑\"></a>老鼠赛跑</h2><p>前几天参加了互动吧上的老鼠赛跑现金流游戏，去年看完了《富爸爸穷爸爸》后一直很想参加这样的线下活动，但是苦于一直找不到途径，终于让我在互动吧找到了。<br>活动在上海啤酒高速的一个小酒吧里面，游戏规则和大富翁很类似，但是比大富翁更公平一些，玩过大富翁的人都知道先走的人相对于后走的人先天优势非常巨大，大到你几乎没办法追上来，这个确实和当今社会比较像，家庭条件好的人确实比家庭条件不好的人起点更高。<br>这个游戏的目标是实现财务自由，从而从老鼠赛跑的跑道走到快车道，实现人生理想。<br>怎么才能实现财务自由呢？只要让你的被动收入超过总支出，那你就已经实现财务自由了，看起来很简单，但是实际上自己的抉择和运气都非常重要。<br>游戏一开始，大家会抽卡片选择一个职业，不同的职业工资不一样，比如我是飞行员，月薪9000多，尧尧是小学教师，工资只有1000多，虽然收入差距巨大，但是我每个月支出高达6900多块，他每个月支出只有几百块，我想实现财务自由就需要被动收入达到6900，而他只要达到几百块就ok了。<br>这个游戏中可以投资的东西只有股票和房子，房子有很多种，有的收益率很低，有的收益率很高，我们一开始都有一个月的工资，这部分钱可以拿来买房地产和股票，把握住什么时候买入，什么时候卖出才是这里面最难的。<br>如果一开始就花很多钱，这样会导致自己手里没有流动现金，如果后面遇到更好的机会，那就没法抓住。银行贷款太多的话也会导致自己负债很多，负债多意味着你离实现财务自由就更远一步。</p>\n<h2 id=\"游戏心得\"><a href=\"#游戏心得\" class=\"headerlink\" title=\"游戏心得\"></a>游戏心得</h2><p>我个人觉得这个游戏的玩法应该是这样的，一开始大家需要通过买卖股票和房地产来增加自己手里的钱，有足够的资金才能买更多的房子，一般来说，越贵的房子能给你带来的月现金流就会越多。<br>游戏中我印象比较深刻的一个场景是，我卖掉了一个每月能给我带来950块现金流的房子，之后我才恍然大悟，我手里明明已经有很多钱了，为什么我还要卖掉这个？我才意识到这个游戏的终极目的是增加自己的被动收入。但是塞翁失马，焉知非福，正是因为我卖了这个房子，我才能在后面遇到一家披萨店的时候有足够的钱买下来，这个店每个月给我带来了5000块的现金流。<br>还有一个就是我和尧尧竞价争夺一处房产的时候，当时我来不及思考，直接出高价竞争到了，但是在我思考了几分钟后我又低价转手卖了，当时大家都很不理解，因为我已经快实现财务自由了，只要购入这个房子，离实现目标就很近了，可是我自己算了一下，如果我把自己所有的钱都买了这个房产，我每个月是可以获得一些收入，但是我手里没有流动资金了，甚至还要背负银行贷款，这样我后面就很难和别人竞争了，毕竟我离财务自由还有一段距离。还好和我想的一样，后来我又找到机会廉价买下了两处房产，最终实现了财务自由。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两位老师让我们最后总结了一下，为什么这个游戏强调被动收入呢？<br>之前尧尧一不小心失业了，但是失业的时候还要继续支付那些支出项，这个让我想起来那个因为失业而跳楼的中兴程序员，负债太多会给未来带来很多不确定的风险和因素，股票可以增加你的现金流，而房产可以增加你的被动收入。不管是为了应对突发状况还是通货膨胀，多种收入来源都是很重要的。如果收入来源只是很单一的来自工资，真的很难实现财务自由，就像我最后总结的时候说的一样，个人所得税和五险一金太高了，就算你在一个行业做到顶尖，就算你年薪百万，税后你也才只能拿到60w，何况我国的通货膨胀还是非常厉害的，靠工资是很难翻身的，程序员随着年龄下降竞争力也会下降，一旦失业后果就不堪设想。<br>所以我觉得我们年轻人应该多去学习一些理财和投资的知识，减少不必要的支出，好好攒钱，在职业中不断提高自己，增加工资收入（相同工作强度下），主动去寻找机会，不要盲目的涉足自己不了解的领域，早点儿从老鼠赛跑中走出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"梦境小说","date":"2015-04-19T04:54:09.000Z","_content":"“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。\n大家都胆战心惊的看着他以及旁边那具腐烂的尸体，所有人都知道再过不久他也会变成这样。\n此时，在一个公寓里面，潘琳珊刚刚醒来，”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，就像发高烧一样。\n他走到阳台，想透透气，但是眼前这噩梦般的一幕让他两腿发软。\n马路上随时都有呕吐不止并且晕倒的人，救护车来来往往，简直就像是世界末日。\nHE病毒！！！他突然想起来了什么，赶紧回到房间，大笑着对蔡汶宾说：”世界要灭亡了，HE病毒无药可治”\n\n“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！让我进去！！快让我进去！！不然我要撞开了！！”，门外那人大嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。\n\n“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。\n\n“以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。\n\n潘琳珊上气不接下气的跟在蔡汶宾的身后。\n\n“我的车就停在前面，我们快上车”。蔡汶宾边说边不时回头看。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/梦境小说.md","raw":"---\ntitle: 梦境小说\ndate: 2015-04-19 12:54:09\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: \n    - 小说\n---\n“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。\n大家都胆战心惊的看着他以及旁边那具腐烂的尸体，所有人都知道再过不久他也会变成这样。\n此时，在一个公寓里面，潘琳珊刚刚醒来，”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，就像发高烧一样。\n他走到阳台，想透透气，但是眼前这噩梦般的一幕让他两腿发软。\n马路上随时都有呕吐不止并且晕倒的人，救护车来来往往，简直就像是世界末日。\nHE病毒！！！他突然想起来了什么，赶紧回到房间，大笑着对蔡汶宾说：”世界要灭亡了，HE病毒无药可治”\n\n“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！让我进去！！快让我进去！！不然我要撞开了！！”，门外那人大嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。\n\n“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。\n\n“以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。\n\n潘琳珊上气不接下气的跟在蔡汶宾的身后。\n\n“我的车就停在前面，我们快上车”。蔡汶宾边说边不时回头看。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"梦境小说","published":1,"updated":"2018-11-22T11:29:11.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxp000kfpzx3cl0npoz","content":"<p>“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。<br>大家都胆战心惊的看着他以及旁边那具腐烂的尸体，所有人都知道再过不久他也会变成这样。<br>此时，在一个公寓里面，潘琳珊刚刚醒来，”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，就像发高烧一样。<br>他走到阳台，想透透气，但是眼前这噩梦般的一幕让他两腿发软。<br>马路上随时都有呕吐不止并且晕倒的人，救护车来来往往，简直就像是世界末日。<br>HE病毒！！！他突然想起来了什么，赶紧回到房间，大笑着对蔡汶宾说：”世界要灭亡了，HE病毒无药可治”</p>\n<p>“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！让我进去！！快让我进去！！不然我要撞开了！！”，门外那人大嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。</p>\n<p>“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。</p>\n<p>“以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。</p>\n<p>潘琳珊上气不接下气的跟在蔡汶宾的身后。</p>\n<p>“我的车就停在前面，我们快上车”。蔡汶宾边说边不时回头看。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"","more":"<p>“哈哈哈哈！”随着一声怪笑，他的脸变得愈发狰狞。<br>大家都胆战心惊的看着他以及旁边那具腐烂的尸体，所有人都知道再过不久他也会变成这样。<br>此时，在一个公寓里面，潘琳珊刚刚醒来，”你已经昏迷了很久了”，蔡汶宾冷冷的说。潘琳珊忘记了发生了什么，只是感觉浑身无力，头痛欲裂，就像发高烧一样。<br>他走到阳台，想透透气，但是眼前这噩梦般的一幕让他两腿发软。<br>马路上随时都有呕吐不止并且晕倒的人，救护车来来往往，简直就像是世界末日。<br>HE病毒！！！他突然想起来了什么，赶紧回到房间，大笑着对蔡汶宾说：”世界要灭亡了，HE病毒无药可治”</p>\n<p>“不，并不是无药可救，只有……”，蔡汶宾还没说完，门突然被敲响了。”开门！！！让我进去！！快让我进去！！不然我要撞开了！！”，门外那人大嚷着。”糟糕！他们居然这么快就找来了，你快跟我走，我们从这里跳下去。”，蔡汶宾拉着潘琳珊走到阳台。</p>\n<p>“只有什么？你还没有说完呢”，潘琳珊疑惑的问道。</p>\n<p>“以后再给你讲，现在快走。”，蔡汶宾拉着潘琳珊跳出阳台，”还好这里是二楼，不过他们马上也会追过来的，我们快走”。</p>\n<p>潘琳珊上气不接下气的跟在蔡汶宾的身后。</p>\n<p>“我的车就停在前面，我们快上车”。蔡汶宾边说边不时回头看。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"流光飞舞","date":"2018-03-10T06:02:18.000Z","_content":"**[流光飞舞 - 陈淑桦][1]**\n\n**作词： 黄霑**\n**作曲： 雷颂德**\n**演唱： 陈淑桦**\n\n半冷半暖的秋\n静静烫贴身边\n\n默默看着流光飞舞\n晚风中几片红叶\n惹得身心酥软绵绵\n\n半醉半醒之间\n盈盈笑眼千千\n\n就让我像云端飘雪\n以冰清轻轻吻面\n带出一波一波缠绵\n\n留人间几回爱\n迎浮生千重变\n\n与有情人 做快乐事\n未问是劫是缘\n\n似柳也似春风\n伴着你过春天\n\n就让你埋首烟波里\n放出心底狂热\n抱一身春雨绵绵\n\n  [1]: https://music.163.com/song?id=92634&userid=45188587","source":"_posts/流光飞舞.md","raw":"---\ntitle: 流光飞舞\ndate: 2018-03-10 14:02:18\ntags:\n- 歌曲\n- 电影\ncategories: 音乐\n---\n**[流光飞舞 - 陈淑桦][1]**\n\n**作词： 黄霑**\n**作曲： 雷颂德**\n**演唱： 陈淑桦**\n\n半冷半暖的秋\n静静烫贴身边\n\n默默看着流光飞舞\n晚风中几片红叶\n惹得身心酥软绵绵\n\n半醉半醒之间\n盈盈笑眼千千\n\n就让我像云端飘雪\n以冰清轻轻吻面\n带出一波一波缠绵\n\n留人间几回爱\n迎浮生千重变\n\n与有情人 做快乐事\n未问是劫是缘\n\n似柳也似春风\n伴着你过春天\n\n就让你埋首烟波里\n放出心底狂热\n抱一身春雨绵绵\n\n  [1]: https://music.163.com/song?id=92634&userid=45188587","slug":"流光飞舞","published":1,"updated":"2018-11-14T09:47:00.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxr000mfpzxk38fwyhr","content":"<p><strong><a href=\"https://music.163.com/song?id=92634&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">流光飞舞 - 陈淑桦</a></strong></p>\n<p><strong>作词： 黄霑</strong><br><strong>作曲： 雷颂德</strong><br><strong>演唱： 陈淑桦</strong></p>\n<p>半冷半暖的秋<br>静静烫贴身边</p>\n<p>默默看着流光飞舞<br>晚风中几片红叶<br>惹得身心酥软绵绵</p>\n<p>半醉半醒之间<br>盈盈笑眼千千</p>\n<p>就让我像云端飘雪<br>以冰清轻轻吻面<br>带出一波一波缠绵</p>\n<p>留人间几回爱<br>迎浮生千重变</p>\n<p>与有情人 做快乐事<br>未问是劫是缘</p>\n<p>似柳也似春风<br>伴着你过春天</p>\n<p>就让你埋首烟波里<br>放出心底狂热<br>抱一身春雨绵绵</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong><a href=\"https://music.163.com/song?id=92634&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">流光飞舞 - 陈淑桦</a></strong></p>\n<p><strong>作词： 黄霑</strong><br><strong>作曲： 雷颂德</strong><br><strong>演唱： 陈淑桦</strong></p>\n<p>半冷半暖的秋<br>静静烫贴身边</p>\n<p>默默看着流光飞舞<br>晚风中几片红叶<br>惹得身心酥软绵绵</p>\n<p>半醉半醒之间<br>盈盈笑眼千千</p>\n<p>就让我像云端飘雪<br>以冰清轻轻吻面<br>带出一波一波缠绵</p>\n<p>留人间几回爱<br>迎浮生千重变</p>\n<p>与有情人 做快乐事<br>未问是劫是缘</p>\n<p>似柳也似春风<br>伴着你过春天</p>\n<p>就让你埋首烟波里<br>放出心底狂热<br>抱一身春雨绵绵</p>\n"},{"title":"深夜思考","date":"2018-03-19T15:53:26.000Z","_content":"很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。\n\n人之所以不快乐，是因为能力配不上自己的欲望。\n\n最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。\n\n以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。\n\n还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。\n<!-- more -->\n那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。\n\n大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。\n\n学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。\n\n整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。\n\n可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？\n\n曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。\n\n当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。\n\n前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？\n\n我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？\n\n年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。\n\n我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？\n\n很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。\n\n哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。\n<head>    \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/深夜思考.md","raw":"---\ntitle: 深夜思考\ndate: 2018-03-19 23:53:26\ntags:\n- 思考\n- 生活\n- 随笔\ncategories: 生活\n---\n很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。\n\n人之所以不快乐，是因为能力配不上自己的欲望。\n\n最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。\n\n以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。\n\n还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。\n<!-- more -->\n那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。\n\n大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。\n\n学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。\n\n整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。\n\n可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？\n\n曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。\n\n当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。\n\n前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？\n\n我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？\n\n年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。\n\n我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？\n\n很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。\n\n哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。\n<head>    \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"深夜思考","published":1,"updated":"2018-11-14T09:47:00.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxu000rfpzxkxxff5zz","content":"<p>很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。</p>\n<p>人之所以不快乐，是因为能力配不上自己的欲望。</p>\n<p>最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。</p>\n<p>以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。</p>\n<p>还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。<br><a id=\"more\"></a><br>那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。</p>\n<p>大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。</p>\n<p>学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。</p>\n<p>整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。</p>\n<p>可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？</p>\n<p>曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。</p>\n<p>当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。</p>\n<p>前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？</p>\n<p>我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？</p>\n<p>年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。</p>\n<p>我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？</p>\n<p>很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。</p>\n<p>哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>很久以前看过一句话，用来描述我最近的状态可能会比较合适吧。</p>\n<p>人之所以不快乐，是因为能力配不上自己的欲望。</p>\n<p>最近几个月我的生活状态和大二有点像，每天都活在焦虑之中，很清楚自己的目标是什么，但是却不知道该怎么做，或者说目标太多，让我迷失了方向。</p>\n<p>以前我常常说，一个人最重要的就是知道自己该做什么，该怎么做。</p>\n<p>还记得高三的时候，我在书摊上偶然看到了《乔布斯传》，这本书帮我开启了互联网的大门，看完后我才知道原来互联网的世界这么有趣，作为一个高中甚至都没怎么碰过电脑的孩子，我深深地沦陷在对互联网的无限遐想中。我被乔布斯的人格魅力深深折服，他很清楚自己要做什么，也就像他对斯卡利说的那句”你是想卖一辈子糖水，还是想改变世界”一样，后来苹果公司确实改变了整个世界。<br>","more":"<br>那段时间我疯狂的迷恋阅读IT大佬们的各种事迹和自传，受到了乔布斯和李开复很深的影响。高考成绩出来后，我毫不犹豫的就报了软件工程专业，因为我梦想着自己像乔布斯一样伟大，我想改变世界。</p>\n<p>大三之前我经历过一段很长时间的迷茫，我不知道自己喜欢什么，我对上课学的东西都没什么兴趣，每天都处在焦虑之中，但是又不知道该怎么改变，或者说不愿意改变，直到后来我意识到自己该找工作了，我才决定打算好好学习前端。</p>\n<p>学前端的过程是漫长而幸福的，每次我能做出一个特效的时候我就会很开心很有成就感。我为了仿联想的官网，曾经在图书馆一直呆到晚上九点多才去吃晚饭，那段时间我的技术提升很快，几乎是每过一个月都有质的突破，这样的状态一直维持到17年初。</p>\n<p>整个17年我都没能突破自己的技术瓶颈，后来在知乎看到Roy li的一篇关于成长的文章，我决定重新从基础开始做起，努力提高自己的技术，到现在为止我差不多看完了underscore的源码，还打算自己重写一遍，一切看起来都很美好啊。</p>\n<p>可是总觉得哪里不对劲，我到底在做什么，我的生活里难道已经单调到只剩下代码了吗？</p>\n<p>曾看到这样一句话：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。</p>\n<p>当你对现状心满意足，日复一日的去做同样的事情，不再将时间花在提升自己，那么你的成长见识将永远停留在原来的那块区域里。</p>\n<p>前几天小新学长他们几个在群里”共谋大业”，他们打算从微信小程序作为创业的切入点，看到他们积极讨论的氛围我觉得我好差劲。为什么我像个傻瓜一样什么都不懂？为什么我就是条没有梦想的咸鱼？</p>\n<p>我梦想着在40岁前实现财务自由，只靠上班是做不到的，一夜暴富也是不现实的，只能靠投资和创业才能实现这个目标，但我一直都安于现状，不敢去挑战有风险的事情，更不知道具体该怎么做。前段时间我想学习一下经济学，研究一下炒股，但是又觉得自己连本职都做不好，我怎么还能去学其他的东西呢？</p>\n<p>年前我想着周末去学习烘焙，但是又觉得会占用自己太多的空闲时间，可是这些空闲时间我还是什么都没做，我很清楚我的自制力和执行力太差了。我一直都是那种对什么事情都只有三分钟热度，很难在一条路上坚持下去的人。</p>\n<p>我总是把自己局限在一个特定的圈子里面，从来都不会去主动认识人，扩大自己的交友圈。之前一个朋友催促我去找女朋友，推荐我使用柏拉图，他说就算你不想找妹纸，找个妹纸聊聊天，分享一下别人的人生和见识不也是很好的吗？</p>\n<p>很多时候我闭上眼睛，在脑海里想像未来的自己，可是我一眼就能看到十年后的自己，我真的很不安很害怕，害怕自己过了十年依然没有什么改变，还是这副死气沉沉的样子。</p>\n<p>哎，希望我能在18年做出改变吧，努力突破自己的技术瓶颈，走出阶段的迷茫。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"牡丹亭外","date":"2018-04-18T02:22:48.000Z","_content":"**[牡丹亭外 - 陈升][1]**\n\n**作词： 陈升**\n**作曲： 陈升**\n**演唱： 陈升**\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n李郎一梦已过往\n风流人儿如今在何方\n\n从古到今说来话\n不过是情而已\n\n这人间苦什么\n怕不能遇见你\n\n这世界有点假\n可我莫名爱上她\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n牡丹亭外雨纷纷\n谁是归人说不准\n是归人啊你说分明\n你把我心放哪儿\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n可我最爱是天然\n风流人儿如今在何方\n\n不管是谁啊\n躲不过 还是情而已\n\n你问我怕什么\n怕不能遇见你\n\n是否你走过了我身边\n恍恍惑惑一瞬间\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人断了魂啊\n听歌的人最无情\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n  [1]: https://music.163.com/dj?id=1368759629&userid=45188587","source":"_posts/牡丹亭外.md","raw":"---\ntitle: 牡丹亭外\ndate: 2018-04-18 10:22:48\ntags:\n- 歌曲\n- 陈升\ncategories: 音乐\n---\n**[牡丹亭外 - 陈升][1]**\n\n**作词： 陈升**\n**作曲： 陈升**\n**演唱： 陈升**\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n李郎一梦已过往\n风流人儿如今在何方\n\n从古到今说来话\n不过是情而已\n\n这人间苦什么\n怕不能遇见你\n\n这世界有点假\n可我莫名爱上她\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n牡丹亭外雨纷纷\n谁是归人说不准\n是归人啊你说分明\n你把我心放哪儿\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人假正经啊\n听歌的人最无情\n\n可我最爱是天然\n风流人儿如今在何方\n\n不管是谁啊\n躲不过 还是情而已\n\n你问我怕什么\n怕不能遇见你\n\n是否你走过了我身边\n恍恍惑惑一瞬间\n\n黄粱一梦二十年\n依旧是不懂爱也不懂情\n写歌的人断了魂啊\n听歌的人最无情\n\n为救李郎离家园\n谁料皇榜中状元\n\n中状元 着红袍\n帽插宫花好啊\n好新鲜\n\n  [1]: https://music.163.com/dj?id=1368759629&userid=45188587","slug":"牡丹亭外","published":1,"updated":"2018-11-14T09:47:00.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxw000tfpzxiz46gops","content":"<p><strong><a href=\"https://music.163.com/dj?id=1368759629&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">牡丹亭外 - 陈升</a></strong></p>\n<p><strong>作词： 陈升</strong><br><strong>作曲： 陈升</strong><br><strong>演唱： 陈升</strong></p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n<p>李郎一梦已过往<br>风流人儿如今在何方</p>\n<p>从古到今说来话<br>不过是情而已</p>\n<p>这人间苦什么<br>怕不能遇见你</p>\n<p>这世界有点假<br>可我莫名爱上她</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>牡丹亭外雨纷纷<br>谁是归人说不准<br>是归人啊你说分明<br>你把我心放哪儿</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>可我最爱是天然<br>风流人儿如今在何方</p>\n<p>不管是谁啊<br>躲不过 还是情而已</p>\n<p>你问我怕什么<br>怕不能遇见你</p>\n<p>是否你走过了我身边<br>恍恍惑惑一瞬间</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人断了魂啊<br>听歌的人最无情</p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong><a href=\"https://music.163.com/dj?id=1368759629&amp;userid=45188587\" target=\"_blank\" rel=\"noopener\">牡丹亭外 - 陈升</a></strong></p>\n<p><strong>作词： 陈升</strong><br><strong>作曲： 陈升</strong><br><strong>演唱： 陈升</strong></p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n<p>李郎一梦已过往<br>风流人儿如今在何方</p>\n<p>从古到今说来话<br>不过是情而已</p>\n<p>这人间苦什么<br>怕不能遇见你</p>\n<p>这世界有点假<br>可我莫名爱上她</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>牡丹亭外雨纷纷<br>谁是归人说不准<br>是归人啊你说分明<br>你把我心放哪儿</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人假正经啊<br>听歌的人最无情</p>\n<p>可我最爱是天然<br>风流人儿如今在何方</p>\n<p>不管是谁啊<br>躲不过 还是情而已</p>\n<p>你问我怕什么<br>怕不能遇见你</p>\n<p>是否你走过了我身边<br>恍恍惑惑一瞬间</p>\n<p>黄粱一梦二十年<br>依旧是不懂爱也不懂情<br>写歌的人断了魂啊<br>听歌的人最无情</p>\n<p>为救李郎离家园<br>谁料皇榜中状元</p>\n<p>中状元 着红袍<br>帽插宫花好啊<br>好新鲜</p>\n"},{"title":"蔡康永的说话之道","date":"2017-10-04T07:21:10.000Z","_content":"1. 在别人眼里的形象取决于你说的话。\n从现在开始做起，每周关心问候一下朋友试试看？\n一定要开心，阳光。\n\n2. 外表永远不是最重要的，是不是讨人喜欢才是最重要的。\n不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的\n\n3. 学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。\n\n4. 和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。\n遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。\n<!-- more -->\n5. 把对方看在眼里，放到心里。\n约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。\n6. 对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。\n\n7. 如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。\n\n8. 问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。\n    先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。\n\n    而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。\n\n    结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。\n9. 和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说\"我\"，而是多说\"你\",\"他\"，尽量让别人说，你倾听。\n10. 很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。\n所以不如根据想问的问题倒推回去三四步？比如直接问\"你今天怎么不开心\"，不如问\"你最近课多吗？\"，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。\n\n    如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。\n    比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。\n\n11. 说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和\n\n12. 谈话的时候不要踩地雷。\n地雷是指：\n+ 对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。\n+ 对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。\n\n13. 别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。\n\n14. 说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易\"撩\"到别人。\n说话适当有空当，可以让别人有时间去想你的话，体会你的感情。\n\n15. 练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。\n\n16. 有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。\n\n17. 讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。\n\n18. 不要不懂装懂，有时候不要抢答，说话要分清场合。\n\n19. 认真观察别人希望被赞赏的方面，然后进行赞赏。\n    用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。\n    比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。\n\n20. 自问自答，站在对方的角度上来考虑。\n尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？\n\n21. 不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。\n\n22. 尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。\n\n23. 有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。\n\n24. 当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已\n\n25. 找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。\n\n26. 当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。\n\n27. 有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。\n\n28. 别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。\n\n29. 擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。\n\n30. 招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。\n\n31. 传达感情，不仅仅要会说。\n    很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。\n    说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。\n    说的多不如说的准，做得到。\n","source":"_posts/蔡康永的说话之道.md","raw":"---\ntitle: 蔡康永的说话之道\ndate: 2017-10-04 15:21:10\ntags:\n- 读书笔记\n- 说话技巧\ncategories:\n- 个人笔记\n---\n1. 在别人眼里的形象取决于你说的话。\n从现在开始做起，每周关心问候一下朋友试试看？\n一定要开心，阳光。\n\n2. 外表永远不是最重要的，是不是讨人喜欢才是最重要的。\n不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的\n\n3. 学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。\n\n4. 和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。\n遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。\n<!-- more -->\n5. 把对方看在眼里，放到心里。\n约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。\n6. 对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。\n\n7. 如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。\n\n8. 问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。\n    先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。\n\n    而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。\n\n    结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。\n9. 和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说\"我\"，而是多说\"你\",\"他\"，尽量让别人说，你倾听。\n10. 很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。\n所以不如根据想问的问题倒推回去三四步？比如直接问\"你今天怎么不开心\"，不如问\"你最近课多吗？\"，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。\n\n    如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。\n    比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。\n\n11. 说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和\n\n12. 谈话的时候不要踩地雷。\n地雷是指：\n+ 对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。\n+ 对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。\n\n13. 别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。\n\n14. 说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易\"撩\"到别人。\n说话适当有空当，可以让别人有时间去想你的话，体会你的感情。\n\n15. 练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。\n\n16. 有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。\n\n17. 讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。\n\n18. 不要不懂装懂，有时候不要抢答，说话要分清场合。\n\n19. 认真观察别人希望被赞赏的方面，然后进行赞赏。\n    用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。\n    比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。\n\n20. 自问自答，站在对方的角度上来考虑。\n尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？\n\n21. 不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。\n\n22. 尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。\n\n23. 有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。\n\n24. 当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已\n\n25. 找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。\n\n26. 当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。\n\n27. 有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。\n\n28. 别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。\n\n29. 擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。\n\n30. 招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。\n\n31. 传达感情，不仅仅要会说。\n    很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。\n    说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。\n    说的多不如说的准，做得到。\n","slug":"蔡康永的说话之道","published":1,"updated":"2018-11-14T09:47:00.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rxx000xfpzx1me2xvdv","content":"<ol>\n<li><p>在别人眼里的形象取决于你说的话。<br>从现在开始做起，每周关心问候一下朋友试试看？<br>一定要开心，阳光。</p>\n</li>\n<li><p>外表永远不是最重要的，是不是讨人喜欢才是最重要的。<br>不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的</p>\n</li>\n<li><p>学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。</p>\n</li>\n<li><p>和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。<br>遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。</p>\n<a id=\"more\"></a></li>\n<li>把对方看在眼里，放到心里。<br>约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。</li>\n<li><p>对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。</p>\n</li>\n<li><p>如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。</p>\n</li>\n<li><p>问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。<br> 先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。</p>\n<p> 而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。</p>\n<p> 结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。</p>\n</li>\n<li>和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说”我”，而是多说”你”,”他”，尽量让别人说，你倾听。</li>\n<li><p>很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。<br>所以不如根据想问的问题倒推回去三四步？比如直接问”你今天怎么不开心”，不如问”你最近课多吗？”，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。</p>\n<p>如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。<br>比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。</p>\n</li>\n<li><p>说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和</p>\n</li>\n<li><p>谈话的时候不要踩地雷。<br>地雷是指：</p>\n</li>\n</ol>\n<ul>\n<li>对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。</li>\n<li>对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。</li>\n</ul>\n<ol start=\"13\">\n<li><p>别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。</p>\n</li>\n<li><p>说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易”撩”到别人。<br>说话适当有空当，可以让别人有时间去想你的话，体会你的感情。</p>\n</li>\n<li><p>练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。</p>\n</li>\n<li><p>有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。</p>\n</li>\n<li><p>讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。</p>\n</li>\n<li><p>不要不懂装懂，有时候不要抢答，说话要分清场合。</p>\n</li>\n<li><p>认真观察别人希望被赞赏的方面，然后进行赞赏。<br>用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。<br>比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。</p>\n</li>\n<li><p>自问自答，站在对方的角度上来考虑。<br>尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？</p>\n</li>\n<li><p>不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。</p>\n</li>\n<li><p>尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。</p>\n</li>\n<li><p>有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。</p>\n</li>\n<li><p>当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已</p>\n</li>\n<li><p>找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。</p>\n</li>\n<li><p>当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。</p>\n</li>\n<li><p>有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。</p>\n</li>\n<li><p>别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。</p>\n</li>\n<li><p>擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。</p>\n</li>\n<li><p>招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。</p>\n</li>\n<li><p>传达感情，不仅仅要会说。<br>很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。<br>说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。<br>说的多不如说的准，做得到。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>在别人眼里的形象取决于你说的话。<br>从现在开始做起，每周关心问候一下朋友试试看？<br>一定要开心，阳光。</p>\n</li>\n<li><p>外表永远不是最重要的，是不是讨人喜欢才是最重要的。<br>不要给别人找麻烦，尽量自己想办法解决，别人不是为了伺候自己才存在的</p>\n</li>\n<li><p>学会享受沉默，有时候不需要拼命找话题，有时候可以放首音乐来缓和气氛。</p>\n</li>\n<li><p>和别人意见不同的时候，不要非要让别人听你的，你可以对对方观点表示适当赞同，同时提出自己的观点。<br>遇到强势的人的时候，你可能需要认输，淡然一笑比什么都好。</p>","more":"</li>\n<li>把对方看在眼里，放到心里。<br>约会的时候，时不时充满感情的看对方几眼，吃饭时讲讲自己之前吃饭遇到的笑话，自己旅行时候见到的风俗民情。</li>\n<li><p>对方提起了一个你完全不想接的话题，不必急着抗拒·，而是把对方的话题连接到一个很生活的方向。</p>\n</li>\n<li><p>如果说话的时候在一个话题上卡住了，那么就赶紧转移其他话题，有机会再转移回来这个话题，即使之前很尴尬，只要新话题能让人很开心，就可以了。</p>\n</li>\n<li><p>问别人问题的时候，最好问更具体的，比如一起看电影肯定不如和我一起去看奇异博士吧好。<br> 先用几个是非题来探索出对方的兴趣范围，然后往下聊，人都希望找到知己。</p>\n<p> 而且一般问的问题最好有退路，即使对方答得很扫兴，你也有相关话题的问题可以问。</p>\n<p> 结合上一条，我的理解是，说话题之前最好多准备相关的问题，如果实在没有，而且卡住了，再换个话题。</p>\n</li>\n<li>和人说话的时候，一定要装作很认真听的样子，这样即使你没认真听，在别人看来，你也是很值得依赖的朋友，所以想让别人喜欢，说话的时候，尽量不要说”我”，而是多说”你”,”他”，尽量让别人说，你倾听。</li>\n<li><p>很多时候，直接问别人某个问题会显得很尖锐，而且不一定得到诚实的回答。<br>所以不如根据想问的问题倒推回去三四步？比如直接问”你今天怎么不开心”，不如问”你最近课多吗？”，然后对方吐槽结束后，再说今天不开心是因为这个吗？这样会比较好。</p>\n<p>如果有时候必须要问具体的问题时，不如用抽象的第三方来当替死鬼。<br>比如:“蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字……”比直接问是否抄袭得体很多。</p>\n</li>\n<li><p>说话的时候不能只是附和别人，有时候需要适当的挑衅，对方希望自己说的话被重视，而不是你敷衍的点头附和</p>\n</li>\n<li><p>谈话的时候不要踩地雷。<br>地雷是指：</p>\n</li>\n</ol>\n<ul>\n<li>对方有苦衷的，不方便或者不愿意给别人讲的，比如感情史，财务状况等等。</li>\n<li>对方很容易有强硬立场的，比如支持哪支球队，之前杨金晶认为上课远比自学强。</li>\n</ul>\n<ol start=\"13\">\n<li><p>别人问你生日的时候，其实你直接说出生日日期，其实别人不能记住，有时候说一下生日那年发生的大事，比如我是香港回归那年的生日啊。</p>\n</li>\n<li><p>说话要有空当，不应该喋喋不休，这样别人就不想听了，说话有时轻，有时重，抑扬顿挫富有感情，很容易”撩”到别人。<br>说话适当有空当，可以让别人有时间去想你的话，体会你的感情。</p>\n</li>\n<li><p>练习悬疑式说话，这样有利于引起别人的兴趣，说的时候停顿一下，如果别人问接下来呢，就说明已经吸引到了，如果对方转移了话题，就说明对方对这个不感兴趣。</p>\n</li>\n<li><p>有时候可以适当的把故事的爆点放到故事前面，这样可以吸引注意力，如果只是放到后面，大家可能一开始就没有兴趣了。</p>\n</li>\n<li><p>讲话幽默不代表就是会讲笑话，幽默是走路，讲笑话是翻跟头，很多时候翻不好，还会终结话题，很多时候分享自己生活中有意思的事情会更好。</p>\n</li>\n<li><p>不要不懂装懂，有时候不要抢答，说话要分清场合。</p>\n</li>\n<li><p>认真观察别人希望被赞赏的方面，然后进行赞赏。<br>用心去观察她平时的言行之类的，她提到什么越多，说明她注意什么越多。<br>比如女孩子比较注意自己外在表现，所以可以从这些方面去夸奖她，表扬她。</p>\n</li>\n<li><p>自问自答，站在对方的角度上来考虑。<br>尤其是当你请求别人帮助的时候，自己先演示一遍，如果你是对方，你会借给自己吗？</p>\n</li>\n<li><p>不能为了讨好一个人就去攻击其他人，你应该努力去疏导对方情绪，不应该讲很多不该讲的话，免得对方以后用这个去搬弄是非。</p>\n</li>\n<li><p>尽量避免烂话题，不要去讲一些别人不感兴趣的，记得及时打住，如果有人讲烂话题的时候，想办法赞美对方，然后顺其自然的转移到其他话题上面。</p>\n</li>\n<li><p>有时候不要刻意出风头，即使是为了让大家印象深刻，也不必惊扰大家。</p>\n</li>\n<li><p>当别人来向你抱怨的时候，永远不要说我理解你，我也经历过之类的，因为一个人是不可能理解另一个人的，对方也不是真的要你理解，他们只是找个熟人哭诉而已</p>\n</li>\n<li><p>找别人帮忙时，不要一股脑的把事情甩给对方，要大事化小，把事情分成一步步去做，这样别人更容易接受一些。</p>\n</li>\n<li><p>当自己犯错的时候，应该主动道歉，先在脑海里面想一遍自己哪里做的不好，哪里需要道歉，然后自己先想好补救方法。最好在道歉前先夸奖对方一波。</p>\n</li>\n<li><p>有时候不要只听别人字面上的意思，然后做出决断，要深入揣摩对方的意思，并且及时问话，这样可以得到更多的答案。</p>\n</li>\n<li><p>别人骂你一句，你回骂他一句，这叫吵架：别人赞美你一句，你回一句赞美，这就叫社交 。</p>\n</li>\n<li><p>擅长掌握气氛。比如在KTV的时候，负责调节气氛，给大家点歌，切歌，照顾到没有点歌的同学。</p>\n</li>\n<li><p>招待别人要用心，而不是只用钱。要多关心对方的需求，多和对方聊天，多让对方倾诉，要多活跃气氛。</p>\n</li>\n<li><p>传达感情，不仅仅要会说。<br>很多时候，你说一件具体的事而不是抽象的道理，会更容易让人接受。<br>说话无非就是表达自己，打动别人。有时候大家不喜欢口才流利的人，因为他们说话过于空洞，很无聊，也不会考虑别人的感受。<br>说的多不如说的准，做得到。</p>\n</li>\n</ol>"},{"title":"JS函数柯里化","date":"2018-05-09T10:13:05.000Z","_content":"## js函数柯里化\n\n&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。\n### 概念\n&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。\n### 实例\n&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：\n### 柯里化求和函数\n```\n    // 普通方式\n    var add1 = function(a, b, c){\n        return a + b + c;\n    }\n    // 柯里化\n    var add2 = function(a) {\n        return function(b) {\n            return function(c) {\n                return a + b + c;\n            }\n        }\n    }\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。\n<!-- more -->\n```\nvar add = function() {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return _args.reduce(function(a, b) {\n                return a + b;\n            })\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar sum = add();\nsum(100, 200)(300);\nsum(400);\nsum(); // 1000\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。\n\n### 通用柯里化函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？\n```\nvar curry = function(fn) {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return fn.apply(fn, _args);\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar multi = function() {\n    return [].reduce.call(arguments, function(a, b) {\n        return a + b;\n    })\n}\nvar add = curry(multi);\nadd(100, 200, 300)(400);\nadd(1000);\nadd(); // 2000\n\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。\n&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？\n```\nvar curry = function(fn) {\n\tvar len = fn.length,\n\t\targs = [];\n\treturn function() {\n\t\tArray.prototype.push.apply(args, arguments)\n\t\tvar argsLen = args.length;\n\t\tif(argsLen < len) {\n\t\t\treturn arguments.callee;\n\t\t}\n\t\treturn fn.apply(fn, args);\n\t}\n}\nvar add = function(a, b, c) {\n\treturn a + b + c;\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。\n&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。\n```\n// 简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。\n```\nadd(1)(2)(3)(2);\nadd(1, 2, 3, 4, 5);\n```\n&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。\n```\nvar num = function() {\n}\nnum.toString = num.valueOf = function() {\n\treturn 10;\n}\nvar anonymousNum = (function() { // 10\n\treturn num;\n}())\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。\n```\nvar curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\nvar add = function() {\n\treturn [].reduce.call(arguments, function(a, b) {\n\t\treturn a + b;\n\t})\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？\n#### 预加载\n&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。\n```\nvar match = curry(function(what, str) {\n  return str.match(what);\n});\n\nmatch(/\\s+/g, \"hello world\");\n// [ ' ' ]\n\nmatch(/\\s+/g)(\"hello world\");\n// [ ' ' ]\n\nvar hasSpaces = match(/\\s+/g);\n// function(x) { return x.match(/\\s+/g) }\n\nhasSpaces(\"hello world\");\n// [ ' ' ]\n\nhasSpaces(\"spaceless\");\n// null\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。\n#### 动态创建函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。\n```\n var addEvent = function(el, type, fn, capture) {\n     if (window.addEventListener) {\n         el.addEventListener(type, function(e) {\n             fn.call(el, e);\n         }, capture);\n     } else if (window.attachEvent) {\n         el.attachEvent(\"on\" + type, function(e) {\n             fn.call(el, e);\n         });\n     } \n };\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。\n```\nvar addEventHandler = function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\nvar addEvent = addEventHandler();\naddEvent(document.body, \"click\", function() {}, false);\naddEvent(document.getElementById(\"test\"), \"click\", function() {}, false);\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。\n```\nvar addEvent = function(el, sType, fn, capture){\n    if (window.addEventListener) {\n        addEvent =  function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        addEvent = function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。\n#### React\n&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？\n```\n    var curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\n\nvar hoc = function(WrappedComponent) {\n\treturn function() {\n\t\tvar len = arguments.length;\n\t\tvar NewComponent = WrappedComponent;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tNewComponent = arguments[i](NewComponent)\n\t\t}\n\t\treturn NewComponent;\n\t}\n}\nvar MyComponent = hoc(PageList);\ncurry(MyComponent)(addStyle)(addLoading)\n```\n这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。\n```\nvar enhance = compose(addLoading, addStyle);\nenhance(MyComponent)\n```\n### 总结\n&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。","source":"_posts/JS函数柯里化.md","raw":"---\ntitle: JS函数柯里化\ndate: 2018-05-09 18:13:05\ntags:\n    - 前端\n    - 函数式编程\n    - javascript\ncategories:\n    - 函数式编程\n---\n## js函数柯里化\n\n&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。\n### 概念\n&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。\n### 实例\n&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：\n### 柯里化求和函数\n```\n    // 普通方式\n    var add1 = function(a, b, c){\n        return a + b + c;\n    }\n    // 柯里化\n    var add2 = function(a) {\n        return function(b) {\n            return function(c) {\n                return a + b + c;\n            }\n        }\n    }\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。\n<!-- more -->\n```\nvar add = function() {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return _args.reduce(function(a, b) {\n                return a + b;\n            })\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar sum = add();\nsum(100, 200)(300);\nsum(400);\nsum(); // 1000\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。\n\n### 通用柯里化函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？\n```\nvar curry = function(fn) {\n    var _args = [];\n    return function() {\n        if(arguments.length === 0) {\n            return fn.apply(fn, _args);\n        }\n        [].push.apply(_args, arguments);\n        return arguments.callee;\n    }\n}\nvar multi = function() {\n    return [].reduce.call(arguments, function(a, b) {\n        return a + b;\n    })\n}\nvar add = curry(multi);\nadd(100, 200, 300)(400);\nadd(1000);\nadd(); // 2000\n\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。\n&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？\n```\nvar curry = function(fn) {\n\tvar len = fn.length,\n\t\targs = [];\n\treturn function() {\n\t\tArray.prototype.push.apply(args, arguments)\n\t\tvar argsLen = args.length;\n\t\tif(argsLen < len) {\n\t\t\treturn arguments.callee;\n\t\t}\n\t\treturn fn.apply(fn, args);\n\t}\n}\nvar add = function(a, b, c) {\n\treturn a + b + c;\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。\n&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。\n```\n// 简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。\n```\nadd(1)(2)(3)(2);\nadd(1, 2, 3, 4, 5);\n```\n&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。\n```\nvar num = function() {\n}\nnum.toString = num.valueOf = function() {\n\treturn 10;\n}\nvar anonymousNum = (function() { // 10\n\treturn num;\n}())\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。\n```\nvar curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\nvar add = function() {\n\treturn [].reduce.call(arguments, function(a, b) {\n\t\treturn a + b;\n\t})\n}\n\nvar adder = curry(add)\nadder(1)(2)(3)\n```\n&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？\n#### 预加载\n&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。\n```\nvar match = curry(function(what, str) {\n  return str.match(what);\n});\n\nmatch(/\\s+/g, \"hello world\");\n// [ ' ' ]\n\nmatch(/\\s+/g)(\"hello world\");\n// [ ' ' ]\n\nvar hasSpaces = match(/\\s+/g);\n// function(x) { return x.match(/\\s+/g) }\n\nhasSpaces(\"hello world\");\n// [ ' ' ]\n\nhasSpaces(\"spaceless\");\n// null\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。\n#### 动态创建函数\n&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。\n```\n var addEvent = function(el, type, fn, capture) {\n     if (window.addEventListener) {\n         el.addEventListener(type, function(e) {\n             fn.call(el, e);\n         }, capture);\n     } else if (window.attachEvent) {\n         el.attachEvent(\"on\" + type, function(e) {\n             fn.call(el, e);\n         });\n     } \n };\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。\n```\nvar addEventHandler = function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\nvar addEvent = addEventHandler();\naddEvent(document.body, \"click\", function() {}, false);\naddEvent(document.getElementById(\"test\"), \"click\", function() {}, false);\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。\n```\nvar addEvent = function(el, sType, fn, capture){\n    if (window.addEventListener) {\n        addEvent =  function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        addEvent = function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n}\n```\n&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。\n#### React\n&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？\n```\n    var curry = function(fn) {\n\tvar func = function() {\n\t\tvar _args = [].slice.call(arguments, 0);\n\t\tvar func1 = function() {\n\t\t\t[].push.apply(_args, arguments)\n\t\t\treturn func1;\n\t\t}\n\t\tfunc1.toString = func1.valueOf = function() {\n\t\t\treturn fn.apply(fn, _args);\n\t\t}\n\t\treturn func1;\n\t}\n\treturn func;\n}\n\nvar hoc = function(WrappedComponent) {\n\treturn function() {\n\t\tvar len = arguments.length;\n\t\tvar NewComponent = WrappedComponent;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tNewComponent = arguments[i](NewComponent)\n\t\t}\n\t\treturn NewComponent;\n\t}\n}\nvar MyComponent = hoc(PageList);\ncurry(MyComponent)(addStyle)(addLoading)\n```\n这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。\n```\nvar enhance = compose(addLoading, addStyle);\nenhance(MyComponent)\n```\n### 总结\n&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。","slug":"JS函数柯里化","published":1,"updated":"2018-11-22T11:47:49.230Z","_id":"cjosj7rz3003efpzx825cw978","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"js函数柯里化\"><a href=\"#js函数柯里化\" class=\"headerlink\" title=\"js函数柯里化\"></a>js函数柯里化</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：</p>\n<h3 id=\"柯里化求和函数\"><a href=\"#柯里化求和函数\" class=\"headerlink\" title=\"柯里化求和函数\"></a>柯里化求和函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通方式</span><br><span class=\"line\">var add1 = function(a, b, c)&#123;</span><br><span class=\"line\">    return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 柯里化</span><br><span class=\"line\">var add2 = function(a) &#123;</span><br><span class=\"line\">    return function(b) &#123;</span><br><span class=\"line\">        return function(c) &#123;</span><br><span class=\"line\">            return a + b + c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。<br>&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return _args.reduce(function(a, b) &#123;</span><br><span class=\"line\">                return a + b;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum = add();</span><br><span class=\"line\">sum(100, 200)(300);</span><br><span class=\"line\">sum(400);</span><br><span class=\"line\">sum(); // 1000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。</p>\n<h3 id=\"通用柯里化函数\"><a href=\"#通用柯里化函数\" class=\"headerlink\" title=\"通用柯里化函数\"></a>通用柯里化函数</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return fn.apply(fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var multi = function() &#123;</span><br><span class=\"line\">    return [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = curry(multi);</span><br><span class=\"line\">add(100, 200, 300)(400);</span><br><span class=\"line\">add(1000);</span><br><span class=\"line\">add(); // 2000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。<br>&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar len = fn.length,</span><br><span class=\"line\">\t\targs = [];</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tArray.prototype.push.apply(args, arguments)</span><br><span class=\"line\">\t\tvar argsLen = args.length;</span><br><span class=\"line\">\t\tif(argsLen &lt; len) &#123;</span><br><span class=\"line\">\t\t\treturn arguments.callee;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn fn.apply(fn, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function(a, b, c) &#123;</span><br><span class=\"line\">\treturn a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。<br>&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 简单实现，参数只能从右到左传递</span><br><span class=\"line\">function createCurry(func, args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var arity = func.length;</span><br><span class=\"line\">    var args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var _args = [].slice.call(arguments);</span><br><span class=\"line\">        [].push.apply(_args, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class=\"line\">        if (_args.length &lt; arity) &#123;</span><br><span class=\"line\">            return createCurry.call(this, func, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 参数收集完毕，则执行func</span><br><span class=\"line\">        return func.apply(this, _args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1)(2)(3)(2);</span><br><span class=\"line\">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">num.toString = num.valueOf = function() &#123;</span><br><span class=\"line\">\treturn 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var anonymousNum = (function() &#123; // 10</span><br><span class=\"line\">\treturn num;</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">\treturn [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">\t\treturn a + b;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？</p>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var match = curry(function(what, str) &#123;</span><br><span class=\"line\">  return str.match(what);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g, &quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g)(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var hasSpaces = match(/\\s+/g);</span><br><span class=\"line\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;spaceless&quot;);</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。</p>\n<h4 id=\"动态创建函数\"><a href=\"#动态创建函数\" class=\"headerlink\" title=\"动态创建函数\"></a>动态创建函数</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, type, fn, capture) &#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        el.addEventListener(type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;, capture);</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        el.attachEvent(&quot;on&quot; + type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEventHandler = function()&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var addEvent = addEventHandler();</span><br><span class=\"line\">addEvent(document.body, &quot;click&quot;, function() &#123;&#125;, false);</span><br><span class=\"line\">addEvent(document.getElementById(&quot;test&quot;), &quot;click&quot;, function() &#123;&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, sType, fn, capture)&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        addEvent =  function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        addEvent = function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hoc = function(WrappedComponent) &#123;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tvar len = arguments.length;</span><br><span class=\"line\">\t\tvar NewComponent = WrappedComponent;</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\tNewComponent = arguments[i](NewComponent)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn NewComponent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var MyComponent = hoc(PageList);</span><br><span class=\"line\">curry(MyComponent)(addStyle)(addLoading)</span><br></pre></td></tr></table></figure></p>\n<p>这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhance = compose(addLoading, addStyle);</span><br><span class=\"line\">enhance(MyComponent)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"js函数柯里化\"><a href=\"#js函数柯里化\" class=\"headerlink\" title=\"js函数柯里化\"></a>js函数柯里化</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;最近一阵子利用上班的空暇时间看了看函数式编程相关的东西，有什么错误的地方希望能够指出来。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;用我自己的话来总结一下，函数柯里化的意思就是你可以一次传很多参数给curry函数，也可以分多次传递，curry函数每次都会返回一个函数去处理剩下的参数，一直到返回最后的结果。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里还是举几个例子来说明一下：</p>\n<h3 id=\"柯里化求和函数\"><a href=\"#柯里化求和函数\" class=\"headerlink\" title=\"柯里化求和函数\"></a>柯里化求和函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通方式</span><br><span class=\"line\">var add1 = function(a, b, c)&#123;</span><br><span class=\"line\">    return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 柯里化</span><br><span class=\"line\">var add2 = function(a) &#123;</span><br><span class=\"line\">    return function(b) &#123;</span><br><span class=\"line\">        return function(c) &#123;</span><br><span class=\"line\">            return a + b + c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里每次传入参数都会返回一个新的函数，这样一直执行到最后一次返回a+b+c的值。<br>&nbsp; &nbsp; &nbsp; &nbsp; 但是这种实现还是有问题的，这里只有三个参数，如果哪天产品经理告诉我们需要改成100次？我们就重新写100次？这很明显不符合开闭原则，所以我们需要对函数进行一次修改。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return _args.reduce(function(a, b) &#123;</span><br><span class=\"line\">                return a + b;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum = add();</span><br><span class=\"line\">sum(100, 200)(300);</span><br><span class=\"line\">sum(400);</span><br><span class=\"line\">sum(); // 1000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们通过判断下一次是否传进来参数来决定函数是否运行，如果继续传进了参数，那我们继续把参数都保存起来，等运行的时候全部一次性运行，这样我们就初步完成了一个柯里化的函数。</p>\n<h3 id=\"通用柯里化函数\"><a href=\"#通用柯里化函数\" class=\"headerlink\" title=\"通用柯里化函数\"></a>通用柯里化函数</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里只是一个求和的函数，如果换成求乘积呢？我们是不是又需要重新写一遍？仔细观察一下我们的add函数，如果我们将if里面的代码换成一个函数执行代码，是不是就可以变成一个通用函数了？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">    var _args = [];</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if(arguments.length === 0) &#123;</span><br><span class=\"line\">            return fn.apply(fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [].push.apply(_args, arguments);</span><br><span class=\"line\">        return arguments.callee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var multi = function() &#123;</span><br><span class=\"line\">    return [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = curry(multi);</span><br><span class=\"line\">add(100, 200, 300)(400);</span><br><span class=\"line\">add(1000);</span><br><span class=\"line\">add(); // 2000</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在之前的方法上面，我们进行了扩展，这样我们就已经实现了一个比较通用的柯里化函数了。<br>&nbsp; &nbsp; &nbsp; &nbsp;  也许你想问，我不想每次都使用那个丑陋的括号结尾怎么办？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar len = fn.length,</span><br><span class=\"line\">\t\targs = [];</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tArray.prototype.push.apply(args, arguments)</span><br><span class=\"line\">\t\tvar argsLen = args.length;</span><br><span class=\"line\">\t\tif(argsLen &lt; len) &#123;</span><br><span class=\"line\">\t\t\treturn arguments.callee;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn fn.apply(fn, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function(a, b, c) &#123;</span><br><span class=\"line\">\treturn a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里根据函数fn的参数数量进行判断，直到传入的数量等于fn函数需要的参数数量才会返回fn函数的最终运行结果，和上面那种方法原理其实是一样的，但是这两种方式都太依赖参数数量了。<br>&nbsp; &nbsp; &nbsp; &nbsp; 我在简书还看到别人的另一种递归实现方法，其实实现思路和我的差不多吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 简单实现，参数只能从右到左传递</span><br><span class=\"line\">function createCurry(func, args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var arity = func.length;</span><br><span class=\"line\">    var args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var _args = [].slice.call(arguments);</span><br><span class=\"line\">        [].push.apply(_args, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class=\"line\">        if (_args.length &lt; arity) &#123;</span><br><span class=\"line\">            return createCurry.call(this, func, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 参数收集完毕，则执行func</span><br><span class=\"line\">        return func.apply(this, _args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这里是对参数个数进行了计算，如果需要无限参数怎么办？比如下面这种场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1)(2)(3)(2);</span><br><span class=\"line\">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;这里主要有一个知识点，那就是函数的隐式转换，涉及到toString和valueOf两个方法，如果直接对函数进行计算，那么会先把函数转换为字符串，之后再参与到计算中，利用这两个方法我们可以对函数进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">num.toString = num.valueOf = function() &#123;</span><br><span class=\"line\">\treturn 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var anonymousNum = (function() &#123; // 10</span><br><span class=\"line\">\treturn num;</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 经过修改，我们的函数最终版是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var add = function() &#123;</span><br><span class=\"line\">\treturn [].reduce.call(arguments, function(a, b) &#123;</span><br><span class=\"line\">\t\treturn a + b;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var adder = curry(add)</span><br><span class=\"line\">adder(1)(2)(3)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;  那么我们说了那么多，柯里化究竟有什么用呢？</p>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在很多场景下，我们需要的函数参数很可能有一部分一样，这个时候再重复写就比较浪费了，我们提前加载好一部分参数，再传入剩下的参数，这里主要是利用了闭包的特性，通过闭包可以保持着原有的作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var match = curry(function(what, str) &#123;</span><br><span class=\"line\">  return str.match(what);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g, &quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">match(/\\s+/g)(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var hasSpaces = match(/\\s+/g);</span><br><span class=\"line\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;hello world&quot;);</span><br><span class=\"line\">// [ &apos; &apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">hasSpaces(&quot;spaceless&quot;);</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 上面例子中，使用hasSpaces函数来保存正则表达式规则，这样可以有效的实现参数的复用。</p>\n<h4 id=\"动态创建函数\"><a href=\"#动态创建函数\" class=\"headerlink\" title=\"动态创建函数\"></a>动态创建函数</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个其实也是一种惰性函数的思想，我们可以提前执行判断条件，通过闭包将其保存在有效的作用域中，来看一种我们平时写代码常见的场景。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, type, fn, capture) &#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        el.addEventListener(type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;, capture);</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        el.attachEvent(&quot;on&quot; + type, function(e) &#123;</span><br><span class=\"line\">            fn.call(el, e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在这个例子中，我们每次调用addEvent的时候都会重新进行if语句进行判断，但是实际上浏览器的条件不可能会变化，你判断一次和判断N次结果都是一样的，所以这个可以将判断条件提前加载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEventHandler = function()&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        return function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var addEvent = addEventHandler();</span><br><span class=\"line\">addEvent(document.body, &quot;click&quot;, function() &#123;&#125;, false);</span><br><span class=\"line\">addEvent(document.getElementById(&quot;test&quot;), &quot;click&quot;, function() &#123;&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 但是这样做还是有一种缺点，因为我们无法判断程序中是否使用了这个方法，但是依然不得不在文件顶部定义一下addEvent，这样其实浪费了资源，这里有一种更好的解决方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addEvent = function(el, sType, fn, capture)&#123;</span><br><span class=\"line\">    if (window.addEventListener) &#123;</span><br><span class=\"line\">        addEvent =  function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.addEventListener(sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, (capture));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; else if (window.attachEvent) &#123;</span><br><span class=\"line\">        addEvent = function(el, sType, fn, capture) &#123;</span><br><span class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 在addEvent函数里面对其重新赋值，这样既解决了每次运行都要判断的问题，又解决了必须在作用域顶部执行一次造成浪费的问题。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在回家的路上我一直在想函数柯里化是不是可以扩展到更多场景，我想把函数换成react组件试试？我想到了高阶组件和redux的connect，这两个确实是将柯里化思想用到react里面的体现。我们想一想，如果把上面例子里面的函数换成组件，参数换成高阶函数呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var curry = function(fn) &#123;</span><br><span class=\"line\">\tvar func = function() &#123;</span><br><span class=\"line\">\t\tvar _args = [].slice.call(arguments, 0);</span><br><span class=\"line\">\t\tvar func1 = function() &#123;</span><br><span class=\"line\">\t\t\t[].push.apply(_args, arguments)</span><br><span class=\"line\">\t\t\treturn func1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfunc1.toString = func1.valueOf = function() &#123;</span><br><span class=\"line\">\t\t\treturn fn.apply(fn, _args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn func1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hoc = function(WrappedComponent) &#123;</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t\tvar len = arguments.length;</span><br><span class=\"line\">\t\tvar NewComponent = WrappedComponent;</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\tNewComponent = arguments[i](NewComponent)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn NewComponent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var MyComponent = hoc(PageList);</span><br><span class=\"line\">curry(MyComponent)(addStyle)(addLoading)</span><br></pre></td></tr></table></figure></p>\n<p>这个例子是对原来的PageList组件进行了扩展，给PageList加了样式和loading的功能，如果想加其他功能，可以继续在上面扩展（注意addStyle和addLoading都是高阶组件），但是写法真的很糟糕，一点都不coooooool，我们可以使用compose方法，underscore和loadsh这些库中已经提供了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var enhance = compose(addLoading, addStyle);</span><br><span class=\"line\">enhance(MyComponent)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 其实关于柯里化的运用核心还是对函数闭包的灵活运用，深刻理解闭包和作用域后就可以写出很多灵活巧妙的方法。</p>"},{"title":"underscore查找索引函数分析","date":"2018-03-25T14:16:51.000Z","_content":"这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。\n## find ##\n```\n// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context\n_.find = _.detect = function (obj, predicate, context) {\n    var key;\n    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key\n    if (isArrayLike(obj)) {\n    \tkey = _.findIndex(obj, predicate, context);\n    } else {\n    \tkey = _.findKey(obj, predicate, context);\n    }\n    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）\n    // 所以这里对没有查找到的情况做了判断\n    if (key !== void 0 && key !== -1) return obj[key];\n};\n```\nfindKey和findIndex方法的实现也都比较简单。\n```\n_.findKey = function (obj, predicate, context) {\n\tpredicate = cb(predicate, context);\n\tvar keys = _.keys(obj), key;\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tkey = keys[i];\n\t\t// 直接return出key意味着只返回第一个通过predicate检测的值\n\t\tif (predicate(obj[key], key, obj)) return key;\n\t}\n};\n// 根据传入dir的正负来判断是findIndex还是findLastIndex\nfunction createPredicateIndexFinder(dir) {\n\treturn function (array, predicate, context) {\n\t    // cb中对predicate绑定作用域\n\t\tpredicate = cb(predicate, context);\n\t\tvar length = getLength(array);\n        // 根据dir判断是从头遍历还是从尾遍历\n\t\tvar index = dir > 0 ? 0 : length - 1;\n\t\t// 这里需要判断两个临界条件\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值\n\t\t\tif (predicate(array[index], index, array)) return index;\n\t\t}\n\t\t// 查找不到就返回-1\n\t\treturn -1;\n\t};\n}\n\n// Returns the first index on an array-like that passes a predicate test\n_.findIndex = createPredicateIndexFinder(1);\n_.findLastIndex = createPredicateIndexFinder(-1);\n```\n<!-- more -->\n## sortedIndex二分查找 ##\nsortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）\n```\nvar arr = [10, 20, 30, 40]\n_.sortedIndex(arr, 25) // 返回2\n```\n由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。\n这里是维基百科对二分查找的定义：\n> 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval\n> search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n```\n// 二分法，可以理解为以中间元素为基准，将数组分成两个\n// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小\n// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段\n// 反过来，就是在数组左半段\n_.sortedIndex = function (array, obj, iteratee, context) {\n    // 不理解cb函数的建议去看我之前的文章\n\titeratee = cb(iteratee, context, 1);\n\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值\n\t// 如果obj是{age: 20, name: \"ygy\"}，iteratee是age，那么这个就是根据age来获取到index的\n\tvar value = iteratee(obj);\n\tvar low = 0, high = getLength(array);\n\t// 通过while循环来不断重复上述过程，直到找到obj的位置\n\twhile (low < high) {\n\t\tvar mid = Math.floor((low + high) / 2);\n\t\tif (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n\t}\n\treturn low;\n};\n```\n## indexOf ##\nindexOf函数接收array、value和isSorted三个参数。\nindexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。\n使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。\nlastIndexOf接收array、value和fromIndex三个参数。\nlastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。\n给下面返回值编上号，以便后面可以直接拿来讲。\n```\nvar arr = [1, 2, 3, 2, 4, 5]\nvar index1 = _.indexOf(arr, 2) // 1\n// 如果传了索引值为2，那就是从索引为2的地方开始搜索\n// 如果不传第三个参数，可以理解为默认是从0开始搜索\nvar index2 = _.indexOf(arr, 2, 2) // 3\n// 从索引为-1的地方查找意思就是从length-2的索引开始查找\nvar index3 = _.indexOf(arr, 2, -1)\n\n// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值\nvar index4 = _.lastIndexOf(arr, 2) // 3\n\n// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分\n// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值\n// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4\n// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3\n//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）\nvar index5 = _.lastIndexOf(arr, 2, 4) // 3\n\n// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索\nvar index6 = _.lastIndexOf(arr, 2, -1)\n```\n![图示][1]\n可能上面有点绕，这里我们再看一下源码：\n```\n_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\nfunction createIndexFinder(dir, predicateFind, sortedIndex) {\n    // idx有可能是布尔类型（isSorted）和数字类型\n\treturn function (array, item, idx) {\n\t\tvar i = 0, length = getLength(array);\n\t\t// 如果idx是数字类型，那就是从某个索引开始搜索\n\t\tif (typeof idx == 'number') {\n\t\t    // dir大于0的时候是从左到右查询（indexOf）\n\t\t\tif (dir > 0) {\n\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算\n\t\t\t\t// idx为负数对应上面的index3的情况\n\t\t\t\ti = idx >= 0 ? idx : Math.max(idx + length, i);\n\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）\n\t\t\t} else {\n\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度\n\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）\n\t\t\t\tlength = idx >= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);\n\t\t\t}\n\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找\n\t\t} else if (sortedIndex && idx && length) {\n\t\t\t// 使用二分法来查找\n\t\t\tidx = sortedIndex(array, item);\n\t\t\treturn array[idx] === item ? idx : -1;\n\t\t}\n\t\t// 如果item是NaN\n\t\tif (item !== item) {\n\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测\n\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了\n\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);\n\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，\n\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数\n\t\t\treturn idx >= 0 ? idx + i : -1;\n\t\t}\n\t\t// 根据上面计算出来的i和length来进行循环\n\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的\n\t\tfor (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n\t\t\tif (array[idx] === item) return idx;\n\t\t}\n\t\treturn -1;\n\t};\n}\n```\n原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。\n这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。\n\n[1]: http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore查找索引函数分析.md","raw":"---\ntitle: underscore查找索引函数分析\ndate: 2018-03-25 22:16:51\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n\t- underscore\n---\n这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。\n## find ##\n```\n// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context\n_.find = _.detect = function (obj, predicate, context) {\n    var key;\n    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key\n    if (isArrayLike(obj)) {\n    \tkey = _.findIndex(obj, predicate, context);\n    } else {\n    \tkey = _.findKey(obj, predicate, context);\n    }\n    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）\n    // 所以这里对没有查找到的情况做了判断\n    if (key !== void 0 && key !== -1) return obj[key];\n};\n```\nfindKey和findIndex方法的实现也都比较简单。\n```\n_.findKey = function (obj, predicate, context) {\n\tpredicate = cb(predicate, context);\n\tvar keys = _.keys(obj), key;\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tkey = keys[i];\n\t\t// 直接return出key意味着只返回第一个通过predicate检测的值\n\t\tif (predicate(obj[key], key, obj)) return key;\n\t}\n};\n// 根据传入dir的正负来判断是findIndex还是findLastIndex\nfunction createPredicateIndexFinder(dir) {\n\treturn function (array, predicate, context) {\n\t    // cb中对predicate绑定作用域\n\t\tpredicate = cb(predicate, context);\n\t\tvar length = getLength(array);\n        // 根据dir判断是从头遍历还是从尾遍历\n\t\tvar index = dir > 0 ? 0 : length - 1;\n\t\t// 这里需要判断两个临界条件\n\t\tfor (; index >= 0 && index < length; index += dir) {\n\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值\n\t\t\tif (predicate(array[index], index, array)) return index;\n\t\t}\n\t\t// 查找不到就返回-1\n\t\treturn -1;\n\t};\n}\n\n// Returns the first index on an array-like that passes a predicate test\n_.findIndex = createPredicateIndexFinder(1);\n_.findLastIndex = createPredicateIndexFinder(-1);\n```\n<!-- more -->\n## sortedIndex二分查找 ##\nsortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）\n```\nvar arr = [10, 20, 30, 40]\n_.sortedIndex(arr, 25) // 返回2\n```\n由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。\n这里是维基百科对二分查找的定义：\n> 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval\n> search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n```\n// 二分法，可以理解为以中间元素为基准，将数组分成两个\n// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小\n// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段\n// 反过来，就是在数组左半段\n_.sortedIndex = function (array, obj, iteratee, context) {\n    // 不理解cb函数的建议去看我之前的文章\n\titeratee = cb(iteratee, context, 1);\n\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值\n\t// 如果obj是{age: 20, name: \"ygy\"}，iteratee是age，那么这个就是根据age来获取到index的\n\tvar value = iteratee(obj);\n\tvar low = 0, high = getLength(array);\n\t// 通过while循环来不断重复上述过程，直到找到obj的位置\n\twhile (low < high) {\n\t\tvar mid = Math.floor((low + high) / 2);\n\t\tif (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n\t}\n\treturn low;\n};\n```\n## indexOf ##\nindexOf函数接收array、value和isSorted三个参数。\nindexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。\n使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。\nlastIndexOf接收array、value和fromIndex三个参数。\nlastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。\n给下面返回值编上号，以便后面可以直接拿来讲。\n```\nvar arr = [1, 2, 3, 2, 4, 5]\nvar index1 = _.indexOf(arr, 2) // 1\n// 如果传了索引值为2，那就是从索引为2的地方开始搜索\n// 如果不传第三个参数，可以理解为默认是从0开始搜索\nvar index2 = _.indexOf(arr, 2, 2) // 3\n// 从索引为-1的地方查找意思就是从length-2的索引开始查找\nvar index3 = _.indexOf(arr, 2, -1)\n\n// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值\nvar index4 = _.lastIndexOf(arr, 2) // 3\n\n// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分\n// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值\n// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4\n// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3\n//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）\nvar index5 = _.lastIndexOf(arr, 2, 4) // 3\n\n// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索\nvar index6 = _.lastIndexOf(arr, 2, -1)\n```\n![图示][1]\n可能上面有点绕，这里我们再看一下源码：\n```\n_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\nfunction createIndexFinder(dir, predicateFind, sortedIndex) {\n    // idx有可能是布尔类型（isSorted）和数字类型\n\treturn function (array, item, idx) {\n\t\tvar i = 0, length = getLength(array);\n\t\t// 如果idx是数字类型，那就是从某个索引开始搜索\n\t\tif (typeof idx == 'number') {\n\t\t    // dir大于0的时候是从左到右查询（indexOf）\n\t\t\tif (dir > 0) {\n\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算\n\t\t\t\t// idx为负数对应上面的index3的情况\n\t\t\t\ti = idx >= 0 ? idx : Math.max(idx + length, i);\n\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）\n\t\t\t} else {\n\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度\n\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）\n\t\t\t\tlength = idx >= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);\n\t\t\t}\n\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找\n\t\t} else if (sortedIndex && idx && length) {\n\t\t\t// 使用二分法来查找\n\t\t\tidx = sortedIndex(array, item);\n\t\t\treturn array[idx] === item ? idx : -1;\n\t\t}\n\t\t// 如果item是NaN\n\t\tif (item !== item) {\n\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测\n\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了\n\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);\n\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，\n\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数\n\t\t\treturn idx >= 0 ? idx + i : -1;\n\t\t}\n\t\t// 根据上面计算出来的i和length来进行循环\n\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的\n\t\tfor (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n\t\t\tif (array[idx] === item) return idx;\n\t\t}\n\t\treturn -1;\n\t};\n}\n```\n原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。\n这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。\n\n[1]: http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\n\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore查找索引函数分析","published":1,"updated":"2018-11-22T11:48:28.094Z","_id":"cjosj7rz4003ffpzx2ammtsrw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context</span><br><span class=\"line\">_.find = _.detect = function (obj, predicate, context) &#123;</span><br><span class=\"line\">    var key;</span><br><span class=\"line\">    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">    \tkey = _.findIndex(obj, predicate, context);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">    \tkey = _.findKey(obj, predicate, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）</span><br><span class=\"line\">    // 所以这里对没有查找到的情况做了判断</span><br><span class=\"line\">    if (key !== void 0 &amp;&amp; key !== -1) return obj[key];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>findKey和findIndex方法的实现也都比较简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.findKey = function (obj, predicate, context) &#123;</span><br><span class=\"line\">\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\tvar keys = _.keys(obj), key;</span><br><span class=\"line\">\tfor (var i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tkey = keys[i];</span><br><span class=\"line\">\t\t// 直接return出key意味着只返回第一个通过predicate检测的值</span><br><span class=\"line\">\t\tif (predicate(obj[key], key, obj)) return key;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 根据传入dir的正负来判断是findIndex还是findLastIndex</span><br><span class=\"line\">function createPredicateIndexFinder(dir) &#123;</span><br><span class=\"line\">\treturn function (array, predicate, context) &#123;</span><br><span class=\"line\">\t    // cb中对predicate绑定作用域</span><br><span class=\"line\">\t\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\t\tvar length = getLength(array);</span><br><span class=\"line\">        // 根据dir判断是从头遍历还是从尾遍历</span><br><span class=\"line\">\t\tvar index = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 这里需要判断两个临界条件</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值</span><br><span class=\"line\">\t\t\tif (predicate(array[index], index, array)) return index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 查找不到就返回-1</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the first index on an array-like that passes a predicate test</span><br><span class=\"line\">_.findIndex = createPredicateIndexFinder(1);</span><br><span class=\"line\">_.findLastIndex = createPredicateIndexFinder(-1);</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"sortedIndex二分查找\"><a href=\"#sortedIndex二分查找\" class=\"headerlink\" title=\"sortedIndex二分查找\"></a>sortedIndex二分查找</h2><p>sortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 30, 40]</span><br><span class=\"line\">_.sortedIndex(arr, 25) // 返回2</span><br></pre></td></tr></table></figure></p>\n<p>由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。<br>这里是维基百科对二分查找的定义：</p>\n<blockquote>\n<p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval<br>search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 二分法，可以理解为以中间元素为基准，将数组分成两个</span><br><span class=\"line\">// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小</span><br><span class=\"line\">// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段</span><br><span class=\"line\">// 反过来，就是在数组左半段</span><br><span class=\"line\">_.sortedIndex = function (array, obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 不理解cb函数的建议去看我之前的文章</span><br><span class=\"line\">\titeratee = cb(iteratee, context, 1);</span><br><span class=\"line\">\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值</span><br><span class=\"line\">\t// 如果obj是&#123;age: 20, name: &quot;ygy&quot;&#125;，iteratee是age，那么这个就是根据age来获取到index的</span><br><span class=\"line\">\tvar value = iteratee(obj);</span><br><span class=\"line\">\tvar low = 0, high = getLength(array);</span><br><span class=\"line\">\t// 通过while循环来不断重复上述过程，直到找到obj的位置</span><br><span class=\"line\">\twhile (low &lt; high) &#123;</span><br><span class=\"line\">\t\tvar mid = Math.floor((low + high) / 2);</span><br><span class=\"line\">\t\tif (iteratee(array[mid]) &lt; value) low = mid + 1; else high = mid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn low;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><p>indexOf函数接收array、value和isSorted三个参数。<br>indexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。<br>使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。<br>lastIndexOf接收array、value和fromIndex三个参数。<br>lastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。<br>给下面返回值编上号，以便后面可以直接拿来讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 2, 4, 5]</span><br><span class=\"line\">var index1 = _.indexOf(arr, 2) // 1</span><br><span class=\"line\">// 如果传了索引值为2，那就是从索引为2的地方开始搜索</span><br><span class=\"line\">// 如果不传第三个参数，可以理解为默认是从0开始搜索</span><br><span class=\"line\">var index2 = _.indexOf(arr, 2, 2) // 3</span><br><span class=\"line\">// 从索引为-1的地方查找意思就是从length-2的索引开始查找</span><br><span class=\"line\">var index3 = _.indexOf(arr, 2, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">var index4 = _.lastIndexOf(arr, 2) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分</span><br><span class=\"line\">// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4</span><br><span class=\"line\">// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3</span><br><span class=\"line\">//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）</span><br><span class=\"line\">var index5 = _.lastIndexOf(arr, 2, 4) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索</span><br><span class=\"line\">var index6 = _.lastIndexOf(arr, 2, -1)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\" alt=\"图示\"><br>可能上面有点绕，这里我们再看一下源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);</span><br><span class=\"line\">_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);</span><br><span class=\"line\">function createIndexFinder(dir, predicateFind, sortedIndex) &#123;</span><br><span class=\"line\">    // idx有可能是布尔类型（isSorted）和数字类型</span><br><span class=\"line\">\treturn function (array, item, idx) &#123;</span><br><span class=\"line\">\t\tvar i = 0, length = getLength(array);</span><br><span class=\"line\">\t\t// 如果idx是数字类型，那就是从某个索引开始搜索</span><br><span class=\"line\">\t\tif (typeof idx == &apos;number&apos;) &#123;</span><br><span class=\"line\">\t\t    // dir大于0的时候是从左到右查询（indexOf）</span><br><span class=\"line\">\t\t\tif (dir &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算</span><br><span class=\"line\">\t\t\t\t// idx为负数对应上面的index3的情况</span><br><span class=\"line\">\t\t\t\ti = idx &gt;= 0 ? idx : Math.max(idx + length, i);</span><br><span class=\"line\">\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度</span><br><span class=\"line\">\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）</span><br><span class=\"line\">\t\t\t\tlength = idx &gt;= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找</span><br><span class=\"line\">\t\t&#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123;</span><br><span class=\"line\">\t\t\t// 使用二分法来查找</span><br><span class=\"line\">\t\t\tidx = sortedIndex(array, item);</span><br><span class=\"line\">\t\t\treturn array[idx] === item ? idx : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 如果item是NaN</span><br><span class=\"line\">\t\tif (item !== item) &#123;</span><br><span class=\"line\">\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测</span><br><span class=\"line\">\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了</span><br><span class=\"line\">\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);</span><br><span class=\"line\">\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，</span><br><span class=\"line\">\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数</span><br><span class=\"line\">\t\t\treturn idx &gt;= 0 ? idx + i : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 根据上面计算出来的i和length来进行循环</span><br><span class=\"line\">\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的</span><br><span class=\"line\">\t\tfor (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123;</span><br><span class=\"line\">\t\t\tif (array[idx] === item) return idx;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。<br>这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第七篇文章，这篇文章主要介绍underscore中查找数组中某一项索引或者对象中某个key的函数。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// find函数接受三个参数，分别是集合obj、检测函数predicate和上下文context</span><br><span class=\"line\">_.find = _.detect = function (obj, predicate, context) &#123;</span><br><span class=\"line\">    var key;</span><br><span class=\"line\">    // 判断是否是类数组，如果是类数组就查找索引，是对象就查找key</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">    \tkey = _.findIndex(obj, predicate, context);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">    \tkey = _.findKey(obj, predicate, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果查不到，findIndex会返回-1，而findKey会什么都不返回（默认undefined）</span><br><span class=\"line\">    // 所以这里对没有查找到的情况做了判断</span><br><span class=\"line\">    if (key !== void 0 &amp;&amp; key !== -1) return obj[key];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>findKey和findIndex方法的实现也都比较简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.findKey = function (obj, predicate, context) &#123;</span><br><span class=\"line\">\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\tvar keys = _.keys(obj), key;</span><br><span class=\"line\">\tfor (var i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tkey = keys[i];</span><br><span class=\"line\">\t\t// 直接return出key意味着只返回第一个通过predicate检测的值</span><br><span class=\"line\">\t\tif (predicate(obj[key], key, obj)) return key;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 根据传入dir的正负来判断是findIndex还是findLastIndex</span><br><span class=\"line\">function createPredicateIndexFinder(dir) &#123;</span><br><span class=\"line\">\treturn function (array, predicate, context) &#123;</span><br><span class=\"line\">\t    // cb中对predicate绑定作用域</span><br><span class=\"line\">\t\tpredicate = cb(predicate, context);</span><br><span class=\"line\">\t\tvar length = getLength(array);</span><br><span class=\"line\">        // 根据dir判断是从头遍历还是从尾遍历</span><br><span class=\"line\">\t\tvar index = dir &gt; 0 ? 0 : length - 1;</span><br><span class=\"line\">\t\t// 这里需要判断两个临界条件</span><br><span class=\"line\">\t\tfor (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class=\"line\">\t\t\t// 遍历数组，并将每一项和key都传到函数中进行运算，返回结果为true的index值</span><br><span class=\"line\">\t\t\tif (predicate(array[index], index, array)) return index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 查找不到就返回-1</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the first index on an array-like that passes a predicate test</span><br><span class=\"line\">_.findIndex = createPredicateIndexFinder(1);</span><br><span class=\"line\">_.findLastIndex = createPredicateIndexFinder(-1);</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"sortedIndex二分查找\"><a href=\"#sortedIndex二分查找\" class=\"headerlink\" title=\"sortedIndex二分查找\"></a>sortedIndex二分查找</h2><p>sortedIndex函数是返回一个值在数组中的位置（注意：这个值不一定在数组中）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 30, 40]</span><br><span class=\"line\">_.sortedIndex(arr, 25) // 返回2</span><br></pre></td></tr></table></figure></p>\n<p>由于sortedIndex是二分查找的实现，所以必须保证传入的数组是升序的（或者数组对象中按某属性升序排列）。<br>这里是维基百科对二分查找的定义：</p>\n<blockquote>\n<p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval<br>search）、对数搜索（英语：logarithmicsearch），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 二分法，可以理解为以中间元素为基准，将数组分成两个</span><br><span class=\"line\">// 首先获取到数组中间的元素，比较传入的obj和中间元素的大小</span><br><span class=\"line\">// 如果obj大于这个元素，那么就说明这个obj应该是在数组右半段</span><br><span class=\"line\">// 反过来，就是在数组左半段</span><br><span class=\"line\">_.sortedIndex = function (array, obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 不理解cb函数的建议去看我之前的文章</span><br><span class=\"line\">\titeratee = cb(iteratee, context, 1);</span><br><span class=\"line\">\t// obj有可能是一个对象，iteratee(obj)会返回当前obj中的某个值</span><br><span class=\"line\">\t// 如果obj是&#123;age: 20, name: &quot;ygy&quot;&#125;，iteratee是age，那么这个就是根据age来获取到index的</span><br><span class=\"line\">\tvar value = iteratee(obj);</span><br><span class=\"line\">\tvar low = 0, high = getLength(array);</span><br><span class=\"line\">\t// 通过while循环来不断重复上述过程，直到找到obj的位置</span><br><span class=\"line\">\twhile (low &lt; high) &#123;</span><br><span class=\"line\">\t\tvar mid = Math.floor((low + high) / 2);</span><br><span class=\"line\">\t\tif (iteratee(array[mid]) &lt; value) low = mid + 1; else high = mid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn low;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><p>indexOf函数接收array、value和isSorted三个参数。<br>indexOf返回value在该 array 中的索引值，如果value不存在 array中就返回-1。<br>使用原生的indexOf 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用sortedIndex二分查找..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。<br>lastIndexOf接收array、value和fromIndex三个参数。<br>lastIndexOf返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。 传递fromIndex将从你给定的索性值开始搜索。<br>给下面返回值编上号，以便后面可以直接拿来讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 2, 4, 5]</span><br><span class=\"line\">var index1 = _.indexOf(arr, 2) // 1</span><br><span class=\"line\">// 如果传了索引值为2，那就是从索引为2的地方开始搜索</span><br><span class=\"line\">// 如果不传第三个参数，可以理解为默认是从0开始搜索</span><br><span class=\"line\">var index2 = _.indexOf(arr, 2, 2) // 3</span><br><span class=\"line\">// 从索引为-1的地方查找意思就是从length-2的索引开始查找</span><br><span class=\"line\">var index3 = _.indexOf(arr, 2, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">// lastIndexOf是从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">var index4 = _.lastIndexOf(arr, 2) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果传了索引值（比如下面的4），意味着将截取数组里面0-4的部分</span><br><span class=\"line\">// 将这部分当作新数组，从数组末尾反向查询，返回第一个查询到的索引值</span><br><span class=\"line\">// 当然这个查询到的索引值还是按照原来数组来看的，以下面这个为例，传入了4</span><br><span class=\"line\">// 意味着从1,2,3,2,4中反向查询2，查询到的第一个2在原arr数组中索引为3</span><br><span class=\"line\">//其实个人理解类似于如果我不传第三个参数，那就默认的是6（arr的长度）</span><br><span class=\"line\">var index5 = _.lastIndexOf(arr, 2, 4) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种情况下传入-1类似于传入5，因为如果不传第三个参数，其实类似于从index为6开始反向查的，传入负值就是从fromIndex+arr.length开始搜索</span><br><span class=\"line\">var index6 = _.lastIndexOf(arr, 2, -1)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/gyyin/lu0ub8qs9mi8r80jphf9b3vc/indexof.jpg\" alt=\"图示\"><br>可能上面有点绕，这里我们再看一下源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);</span><br><span class=\"line\">_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);</span><br><span class=\"line\">function createIndexFinder(dir, predicateFind, sortedIndex) &#123;</span><br><span class=\"line\">    // idx有可能是布尔类型（isSorted）和数字类型</span><br><span class=\"line\">\treturn function (array, item, idx) &#123;</span><br><span class=\"line\">\t\tvar i = 0, length = getLength(array);</span><br><span class=\"line\">\t\t// 如果idx是数字类型，那就是从某个索引开始搜索</span><br><span class=\"line\">\t\tif (typeof idx == &apos;number&apos;) &#123;</span><br><span class=\"line\">\t\t    // dir大于0的时候是从左到右查询（indexOf）</span><br><span class=\"line\">\t\t\tif (dir &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// 这里对idx进行了处理，如果idx为负数，那就从加上length的索引开始算</span><br><span class=\"line\">\t\t\t\t// idx为负数对应上面的index3的情况</span><br><span class=\"line\">\t\t\t\ti = idx &gt;= 0 ? idx : Math.max(idx + length, i);</span><br><span class=\"line\">\t\t\t// dir小于0的时候是从右到左查询（lastIndexOf）</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 从index开始反向查找，如果idx为正，那么不能超过数组长度</span><br><span class=\"line\">\t\t\t\t// 如果idx为负，那就取idx+length+1（这里之所以+1是为了兼容后面for循环里面的-1，因为如果什么都不传的情况下，循环肯定是从0到length-1）</span><br><span class=\"line\">\t\t\t\tlength = idx &gt;= 0 ? Math.min(idx + 1, length) : Math.max(idx, idx + length + 1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t// 如果idx为布尔类型，那么就使用sortedIndex二分查找</span><br><span class=\"line\">\t\t&#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123;</span><br><span class=\"line\">\t\t\t// 使用二分法来查找</span><br><span class=\"line\">\t\t\tidx = sortedIndex(array, item);</span><br><span class=\"line\">\t\t\treturn array[idx] === item ? idx : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 如果item是NaN</span><br><span class=\"line\">\t\tif (item !== item) &#123;</span><br><span class=\"line\">\t\t    // 数组里面有可能有NaN，因为NaN不和自身相等，所以这里传入了isNaN的方法来检测</span><br><span class=\"line\">\t\t    // 其实这里面对array.slice(i, length)的每一项都用isNaN来检测了</span><br><span class=\"line\">\t\t\tidx = predicateFind(slice.call(array, i, length), _.isNaN);</span><br><span class=\"line\">\t\t\t// 这里之所以加上i，是因为predicateFind函数里面是根据array.slice(i, length)的长度来循环最终获取到index值，</span><br><span class=\"line\">\t\t\t// 这样其实少算了一段长度为i的数组，这个可以去看createPredicateIndexFinder函数</span><br><span class=\"line\">\t\t\treturn idx &gt;= 0 ? idx + i : -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 根据上面计算出来的i和length来进行循环</span><br><span class=\"line\">\t\t// 这里不用加上i是因为一开始就是从i或者length-1开始遍历的</span><br><span class=\"line\">\t\tfor (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123;</span><br><span class=\"line\">\t\t\tif (array[idx] === item) return idx;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本indexOf只是个简单的方法，只不过这里面考虑到lastIndexOf可以传入负值以及indexOf使用二分查找优化才让人那么难懂。<br>这篇文章如果有什么错误和不足之处，希望大家可以指出，有疑惑也可以直接在评论区提出来。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"layout":"underscore","title":"underscore throttle节流函数分析","date":"2018-03-22T14:14:47.000Z","_content":"这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。\n## throttle节流函数 ##\n\nJavascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。\n比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。\n这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。\n我们可以先尝试着自己实现一个节流函数：\n```\n  // 自己实现的简单节流函数\nfunction throttle (func, time) {\n\tvar timeout = null,\n\t\tcontext = null,\n\t\targs = null\n\treturn function() {\n\t    context = this\n\t\targs = arguments\n\t\t// 只要timeout函数存在，所有调用都无视\n\t\tif(timeout) return;\n\t\ttimeout = setTimeout(function() {\n\t\t\tfunc.apply(context, args)\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = null\n\t\t}, time||500)\n\t}\n}\n```\n我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。\n<!-- more -->\n```\n// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用\n// 如果options.trailing为false，则是禁用第一次执行\n_.throttle = function (func, wait, options) {\n\t\t// 一些初始化操作\n\t\tvar context, args, result;\n\t\tvar timeout = null;\n\t\tvar previous = 0;\n\t\tif (!options) options = {};\n\t\tvar later = function () {\n\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳\n\t\t\tprevious = options.leading === false ? 0 : _.now();\n\t\t\t// 解除引用\n\t\t\ttimeout = null;\n\t\t\tresult = func.apply(context, args);\n\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout\n\t\t\tif (!timeout) context = args = null;\n\t\t};\n\t\treturn function () {\n\t\t    // 获取当前调用时的时间（ms）\n\t\t\tvar now = _.now();\n\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间\n\t\t\t// 这里用全等来避免undefined的情况\n\t\t\tif (!previous && options.leading === false) previous = now;\n\t\t\t// 还要wait时间才会触发下一次func\n\t\t\tvar remaining = wait - (now - previous);\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间\n\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait\n\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况\n\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now\n\t\t\tif (remaining <= 0 || remaining > wait) {\n\t\t\t\tif (timeout) {\n\t\t\t\t    // 清除定时器\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\ttimeout = null;\n\t\t\t\t}\n\t\t\t\t// previous保存当前触发的时间戳\n\t\t\t\tprevious = now;\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tif (!timeout) context = args = null;\n\t\t\t// 如果timeout不存在（当前定时器还存在）\n\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数\n\t\t\t} else if (!timeout && options.trailing !== false) {\n\t\t\t\ttimeout = setTimeout(later, remaining);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t};\n\n```\n这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。\n\n### 没有传leading和trailing ###\n\n 1. 第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳\n 2. 第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func\n 3. 之后每次触发都会重复走2的流程\n\n### options.leading: false ###\n这种情况和上面情况类似，不过区别在于第一次触发的时候。\n由于满足!previous && options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程\n\n### options.trailing: false ###\n\n 1. 由于没有设置leading为false，所以第一次触发就会立即执行一次func\n 2. 第二次触发的时候，由于previous保存了上次时间戳，所以remaining <= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次\n 3. 之后重复步骤2\n\n### trailing和leading都为false ###\n最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。\n\n\n不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？\n这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。\n请直接看第一个回答以及下面的评论区：[关于underscore源码中throttle函数的疑惑？][1]\n## leading带来的不同表现 ##\nGDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    console.log(`函数${++i}在${new Date().getTime() - _now}调用`)\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    // 如果超过了wait时间，那么就立即执行\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\nvar i = 0\nvar test = throttle(() => {\n  console.log(`函数${i}在${new Date().getTime() - _now}执行`)\n}, 1000, {leading: false})\n\nsetInterval(test, 3000)\n```\n我将传入leading和没传入leading的情况作了以下比较。\nleading为false时：\n![leading为false][6]\n没有传入leading时：\n![leading为true][7]\n当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback => wait => callback\n\n一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。\n\n## 为什么是禁用最后一次调用 ##\ntrailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\nvar context, args, result;\nvar timeout = null;\nvar previous = 0;\nif (!options) options = {};\nvar later = function() {\nprevious = options.leading === false ? 0 : new Date().getTime();\ntimeout = null;\nresult = func.apply(context, args);\nif (!timeout) context = args = null;\n};\nreturn function() {\nconsole.log(`函数${++i}在${new Date().getTime() - _now}调用`)\nvar now = new Date().getTime();\nif (!previous && options.leading === false) previous = now;\nvar remaining = wait - (now - previous);\ncontext = this;\nargs = arguments;\n// 如果超过了wait时间，那么就立即执行\nif (remaining <= 0 || remaining > wait) {\n  if (timeout) {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  previous = now;\n  result = func.apply(context, args);\n  if (!timeout) context = args = null;\n} else if (!timeout && options.trailing !== false) {\n  timeout = setTimeout(later, remaining);\n}\nreturn result;\n};\n};\nvar i = 0\nvar test = throttle(() => {\nconsole.log(函数${i}在${new Date().getTime() - _now}执行)\n}, 1000, {trailing: false})\nwindow.addEventListener(\"scroll\", test)\n```\ntrailing为false时：\n![trailing为false][8]\n\n没有设置trailing时：\n![没有设置trailing][9]\n\n这两张图很明显的不同就是设置了trailing的时候，最后一次总是\"执行\"，而未设置trailing最后一次总是\"调用\"，少了一次执行。\n\n我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。\n如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。\n如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。\n\n## 总结 ##\n很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。\n我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。\n本文有错误和不足之处，也希望大家能够指出。\n\n## 参考链接：##\n\n 1. [关于underscore源码中throttle函数的疑惑？][2]\n 2. [ underscore 函数节流的实现][3]\n 3. [ Underscore之throttle函数源码分析以及使用注意事项\n][4]\n 4. [浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异][5]\n\n \n\n\n  [1]: https://segmentfault.com/q/1010000013899949\n  [2]: https://segmentfault.com/q/1010000013899949?_ea=3493310\n  [3]: https://github.com/hanzichi/underscore-analysis/issues/22\n  [4]: http://www.easyui.info/archives/1853.html\n  [5]: https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\n  [6]: http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\n  [7]: http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\n  [8]: http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\n  [9]: http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\n\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore throttle节流函数分析.md","raw":"---\nlayout: underscore\ntitle: underscore throttle节流函数分析\ndate: 2018-03-22 22:14:47\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n\t- underscore\n---\n这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。\n## throttle节流函数 ##\n\nJavascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。\n比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。\n这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。\n我们可以先尝试着自己实现一个节流函数：\n```\n  // 自己实现的简单节流函数\nfunction throttle (func, time) {\n\tvar timeout = null,\n\t\tcontext = null,\n\t\targs = null\n\treturn function() {\n\t    context = this\n\t\targs = arguments\n\t\t// 只要timeout函数存在，所有调用都无视\n\t\tif(timeout) return;\n\t\ttimeout = setTimeout(function() {\n\t\t\tfunc.apply(context, args)\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = null\n\t\t}, time||500)\n\t}\n}\n```\n我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。\n<!-- more -->\n```\n// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用\n// 如果options.trailing为false，则是禁用第一次执行\n_.throttle = function (func, wait, options) {\n\t\t// 一些初始化操作\n\t\tvar context, args, result;\n\t\tvar timeout = null;\n\t\tvar previous = 0;\n\t\tif (!options) options = {};\n\t\tvar later = function () {\n\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳\n\t\t\tprevious = options.leading === false ? 0 : _.now();\n\t\t\t// 解除引用\n\t\t\ttimeout = null;\n\t\t\tresult = func.apply(context, args);\n\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout\n\t\t\tif (!timeout) context = args = null;\n\t\t};\n\t\treturn function () {\n\t\t    // 获取当前调用时的时间（ms）\n\t\t\tvar now = _.now();\n\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间\n\t\t\t// 这里用全等来避免undefined的情况\n\t\t\tif (!previous && options.leading === false) previous = now;\n\t\t\t// 还要wait时间才会触发下一次func\n\t\t\tvar remaining = wait - (now - previous);\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间\n\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait\n\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况\n\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now\n\t\t\tif (remaining <= 0 || remaining > wait) {\n\t\t\t\tif (timeout) {\n\t\t\t\t    // 清除定时器\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\ttimeout = null;\n\t\t\t\t}\n\t\t\t\t// previous保存当前触发的时间戳\n\t\t\t\tprevious = now;\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tif (!timeout) context = args = null;\n\t\t\t// 如果timeout不存在（当前定时器还存在）\n\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数\n\t\t\t} else if (!timeout && options.trailing !== false) {\n\t\t\t\ttimeout = setTimeout(later, remaining);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t};\n\n```\n这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。\n\n### 没有传leading和trailing ###\n\n 1. 第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳\n 2. 第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func\n 3. 之后每次触发都会重复走2的流程\n\n### options.leading: false ###\n这种情况和上面情况类似，不过区别在于第一次触发的时候。\n由于满足!previous && options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程\n\n### options.trailing: false ###\n\n 1. 由于没有设置leading为false，所以第一次触发就会立即执行一次func\n 2. 第二次触发的时候，由于previous保存了上次时间戳，所以remaining <= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次\n 3. 之后重复步骤2\n\n### trailing和leading都为false ###\n最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。\n\n\n不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？\n这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。\n请直接看第一个回答以及下面的评论区：[关于underscore源码中throttle函数的疑惑？][1]\n## leading带来的不同表现 ##\nGDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    console.log(`函数${++i}在${new Date().getTime() - _now}调用`)\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    // 如果超过了wait时间，那么就立即执行\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\nvar i = 0\nvar test = throttle(() => {\n  console.log(`函数${i}在${new Date().getTime() - _now}执行`)\n}, 1000, {leading: false})\n\nsetInterval(test, 3000)\n```\n我将传入leading和没传入leading的情况作了以下比较。\nleading为false时：\n![leading为false][6]\n没有传入leading时：\n![leading为true][7]\n当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback => wait => callback\n\n一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。\n\n## 为什么是禁用最后一次调用 ##\ntrailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。\n```\nvar _now = new Date().getTime()\nvar throttle = function(func, wait, options) {\nvar context, args, result;\nvar timeout = null;\nvar previous = 0;\nif (!options) options = {};\nvar later = function() {\nprevious = options.leading === false ? 0 : new Date().getTime();\ntimeout = null;\nresult = func.apply(context, args);\nif (!timeout) context = args = null;\n};\nreturn function() {\nconsole.log(`函数${++i}在${new Date().getTime() - _now}调用`)\nvar now = new Date().getTime();\nif (!previous && options.leading === false) previous = now;\nvar remaining = wait - (now - previous);\ncontext = this;\nargs = arguments;\n// 如果超过了wait时间，那么就立即执行\nif (remaining <= 0 || remaining > wait) {\n  if (timeout) {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  previous = now;\n  result = func.apply(context, args);\n  if (!timeout) context = args = null;\n} else if (!timeout && options.trailing !== false) {\n  timeout = setTimeout(later, remaining);\n}\nreturn result;\n};\n};\nvar i = 0\nvar test = throttle(() => {\nconsole.log(函数${i}在${new Date().getTime() - _now}执行)\n}, 1000, {trailing: false})\nwindow.addEventListener(\"scroll\", test)\n```\ntrailing为false时：\n![trailing为false][8]\n\n没有设置trailing时：\n![没有设置trailing][9]\n\n这两张图很明显的不同就是设置了trailing的时候，最后一次总是\"执行\"，而未设置trailing最后一次总是\"调用\"，少了一次执行。\n\n我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。\n如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。\n如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。\n\n## 总结 ##\n很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。\n我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。\n本文有错误和不足之处，也希望大家能够指出。\n\n## 参考链接：##\n\n 1. [关于underscore源码中throttle函数的疑惑？][2]\n 2. [ underscore 函数节流的实现][3]\n 3. [ Underscore之throttle函数源码分析以及使用注意事项\n][4]\n 4. [浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异][5]\n\n \n\n\n  [1]: https://segmentfault.com/q/1010000013899949\n  [2]: https://segmentfault.com/q/1010000013899949?_ea=3493310\n  [3]: https://github.com/hanzichi/underscore-analysis/issues/22\n  [4]: http://www.easyui.info/archives/1853.html\n  [5]: https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\n  [6]: http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\n  [7]: http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\n  [8]: http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\n  [9]: http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\n\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore throttle节流函数分析","published":1,"updated":"2018-11-22T11:48:25.691Z","_id":"cjosj7rz5003ifpzxqb2pne14","comments":1,"photos":[],"link":"","content":"<p>这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。</p>\n<h2 id=\"throttle节流函数\"><a href=\"#throttle节流函数\" class=\"headerlink\" title=\"throttle节流函数\"></a>throttle节流函数</h2><p>Javascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。<br>比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。<br>这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。<br>我们可以先尝试着自己实现一个节流函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // 自己实现的简单节流函数</span><br><span class=\"line\">function throttle (func, time) &#123;</span><br><span class=\"line\">\tvar timeout = null,</span><br><span class=\"line\">\t\tcontext = null,</span><br><span class=\"line\">\t\targs = null</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t    context = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 只要timeout函数存在，所有调用都无视</span><br><span class=\"line\">\t\tif(timeout) return;</span><br><span class=\"line\">\t\ttimeout = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t\ttimeout = null</span><br><span class=\"line\">\t\t&#125;, time||500)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用</span><br><span class=\"line\">// 如果options.trailing为false，则是禁用第一次执行</span><br><span class=\"line\">_.throttle = function (func, wait, options) &#123;</span><br><span class=\"line\">\t\t// 一些初始化操作</span><br><span class=\"line\">\t\tvar context, args, result;</span><br><span class=\"line\">\t\tvar timeout = null;</span><br><span class=\"line\">\t\tvar previous = 0;</span><br><span class=\"line\">\t\tif (!options) options = &#123;&#125;;</span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳</span><br><span class=\"line\">\t\t\tprevious = options.leading === false ? 0 : _.now();</span><br><span class=\"line\">\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout</span><br><span class=\"line\">\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t    // 获取当前调用时的时间（ms）</span><br><span class=\"line\">\t\t\tvar now = _.now();</span><br><span class=\"line\">\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间</span><br><span class=\"line\">\t\t\t// 这里用全等来避免undefined的情况</span><br><span class=\"line\">\t\t\tif (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">\t\t\t// 还要wait时间才会触发下一次func</span><br><span class=\"line\">\t\t\tvar remaining = wait - (now - previous);</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间</span><br><span class=\"line\">\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait</span><br><span class=\"line\">\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况</span><br><span class=\"line\">\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now</span><br><span class=\"line\">\t\t\tif (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">\t\t\t\tif (timeout) &#123;</span><br><span class=\"line\">\t\t\t\t    // 清除定时器</span><br><span class=\"line\">\t\t\t\t\tclearTimeout(timeout);</span><br><span class=\"line\">\t\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t// previous保存当前触发的时间戳</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t// 如果timeout不存在（当前定时器还存在）</span><br><span class=\"line\">\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数</span><br><span class=\"line\">\t\t\t&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, remaining);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。</p>\n<h3 id=\"没有传leading和trailing\"><a href=\"#没有传leading和trailing\" class=\"headerlink\" title=\"没有传leading和trailing\"></a>没有传leading和trailing</h3><ol>\n<li>第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳</li>\n<li>第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func</li>\n<li>之后每次触发都会重复走2的流程</li>\n</ol>\n<h3 id=\"options-leading-false\"><a href=\"#options-leading-false\" class=\"headerlink\" title=\"options.leading: false\"></a>options.leading: false</h3><p>这种情况和上面情况类似，不过区别在于第一次触发的时候。<br>由于满足!previous &amp;&amp; options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程</p>\n<h3 id=\"options-trailing-false\"><a href=\"#options-trailing-false\" class=\"headerlink\" title=\"options.trailing: false\"></a>options.trailing: false</h3><ol>\n<li>由于没有设置leading为false，所以第一次触发就会立即执行一次func</li>\n<li>第二次触发的时候，由于previous保存了上次时间戳，所以remaining &lt;= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次</li>\n<li>之后重复步骤2</li>\n</ol>\n<h3 id=\"trailing和leading都为false\"><a href=\"#trailing和leading都为false\" class=\"headerlink\" title=\"trailing和leading都为false\"></a>trailing和leading都为false</h3><p>最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。</p>\n<p>不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？<br>这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。<br>请直接看第一个回答以及下面的评论区：<a href=\"https://segmentfault.com/q/1010000013899949\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></p>\n<h2 id=\"leading带来的不同表现\"><a href=\"#leading带来的不同表现\" class=\"headerlink\" title=\"leading带来的不同表现\"></a>leading带来的不同表现</h2><p>GDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">  var context, args, result;</span><br><span class=\"line\">  var timeout = null;</span><br><span class=\"line\">  var previous = 0;</span><br><span class=\"line\">  if (!options) options = &#123;&#125;;</span><br><span class=\"line\">  var later = function() &#123;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    if (!timeout) context = args = null;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">    var now = new Date().getTime();</span><br><span class=\"line\">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">    var remaining = wait - (now - previous);</span><br><span class=\"line\">    context = this;</span><br><span class=\"line\">    args = arguments;</span><br><span class=\"line\">    // 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">      if (timeout) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      if (!timeout) context = args = null;</span><br><span class=\"line\">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">      timeout = setTimeout(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">  console.log(`函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行`)</span><br><span class=\"line\">&#125;, 1000, &#123;leading: false&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(test, 3000)</span><br></pre></td></tr></table></figure></p>\n<p>我将传入leading和没传入leading的情况作了以下比较。<br>leading为false时：<br><img src=\"http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\" alt=\"leading为false\"><br>没有传入leading时：<br><img src=\"http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\" alt=\"leading为true\"><br>当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback =&gt; wait =&gt; callback</p>\n<p>一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。</p>\n<h2 id=\"为什么是禁用最后一次调用\"><a href=\"#为什么是禁用最后一次调用\" class=\"headerlink\" title=\"为什么是禁用最后一次调用\"></a>为什么是禁用最后一次调用</h2><p>trailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">var context, args, result;</span><br><span class=\"line\">var timeout = null;</span><br><span class=\"line\">var previous = 0;</span><br><span class=\"line\">if (!options) options = &#123;&#125;;</span><br><span class=\"line\">var later = function() &#123;</span><br><span class=\"line\">previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">timeout = null;</span><br><span class=\"line\">result = func.apply(context, args);</span><br><span class=\"line\">if (!timeout) context = args = null;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return function() &#123;</span><br><span class=\"line\">console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">var now = new Date().getTime();</span><br><span class=\"line\">if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">var remaining = wait - (now - previous);</span><br><span class=\"line\">context = this;</span><br><span class=\"line\">args = arguments;</span><br><span class=\"line\">// 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">  if (timeout) &#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  previous = now;</span><br><span class=\"line\">  result = func.apply(context, args);</span><br><span class=\"line\">  if (!timeout) context = args = null;</span><br><span class=\"line\">&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">  timeout = setTimeout(later, remaining);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">console.log(函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行)</span><br><span class=\"line\">&#125;, 1000, &#123;trailing: false&#125;)</span><br><span class=\"line\">window.addEventListener(&quot;scroll&quot;, test)</span><br></pre></td></tr></table></figure></p>\n<p>trailing为false时：<br><img src=\"http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\" alt=\"trailing为false\"></p>\n<p>没有设置trailing时：<br><img src=\"http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\" alt=\"没有设置trailing\"></p>\n<p>这两张图很明显的不同就是设置了trailing的时候，最后一次总是”执行”，而未设置trailing最后一次总是”调用”，少了一次执行。</p>\n<p>我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。<br>如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。<br>如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。<br>我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。<br>本文有错误和不足之处，也希望大家能够指出。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><ol>\n<li><a href=\"https://segmentfault.com/q/1010000013899949?_ea=3493310\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></li>\n<li><a href=\"https://github.com/hanzichi/underscore-analysis/issues/22\" target=\"_blank\" rel=\"noopener\"> underscore 函数节流的实现</a></li>\n<li><a href=\"http://www.easyui.info/archives/1853.html\" target=\"_blank\" rel=\"noopener\"> Underscore之throttle函数源码分析以及使用注意事项\n</a></li>\n<li><a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\" target=\"_blank\" rel=\"noopener\">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a></li>\n</ol>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第五篇，今天来聊一下throttle和debounce两个函数。</p>\n<h2 id=\"throttle节流函数\"><a href=\"#throttle节流函数\" class=\"headerlink\" title=\"throttle节流函数\"></a>throttle节流函数</h2><p>Javascript中的函数大多数情况下都是用户调用执行的，但是在某些场景下不是用户直接控制的，在这些场景下，函数会被频繁调用，容易造成性能问题。<br>比如在window.onresize事件和window.onScroll事件中，由于用户可以不断地触发，这会导致函数短时间内频繁调用，如果函数中有复杂的计算，很容易就造成性能的问题。<br>这些场景下最主要的问题是触发频率太高，1s内可以触发数次，但是大多数情况下我们并不需要那么高的触发频率，可能只要在500ms内触发一次，这样其实我们可以用setTimeout来解决，在这期间的触发都忽略掉。<br>我们可以先尝试着自己实现一个节流函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  // 自己实现的简单节流函数</span><br><span class=\"line\">function throttle (func, time) &#123;</span><br><span class=\"line\">\tvar timeout = null,</span><br><span class=\"line\">\t\tcontext = null,</span><br><span class=\"line\">\t\targs = null</span><br><span class=\"line\">\treturn function() &#123;</span><br><span class=\"line\">\t    context = this</span><br><span class=\"line\">\t\targs = arguments</span><br><span class=\"line\">\t\t// 只要timeout函数存在，所有调用都无视</span><br><span class=\"line\">\t\tif(timeout) return;</span><br><span class=\"line\">\t\ttimeout = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\tfunc.apply(context, args)</span><br><span class=\"line\">\t\t\tclearTimeout(timeout)</span><br><span class=\"line\">\t\t\ttimeout = null</span><br><span class=\"line\">\t\t&#125;, time||500)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的节流函数，但是还不够完整，如果我想在第一次触发的时候立即执行怎么办？如果我想禁用掉最后一次执行怎么办？underscore中实现了一个比较完整的节流函数。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// options是一个对象，如果options.leading为false，就是禁用第一次触发立即调用</span><br><span class=\"line\">// 如果options.trailing为false，则是禁用第一次执行</span><br><span class=\"line\">_.throttle = function (func, wait, options) &#123;</span><br><span class=\"line\">\t\t// 一些初始化操作</span><br><span class=\"line\">\t\tvar context, args, result;</span><br><span class=\"line\">\t\tvar timeout = null;</span><br><span class=\"line\">\t\tvar previous = 0;</span><br><span class=\"line\">\t\tif (!options) options = &#123;&#125;;</span><br><span class=\"line\">\t\tvar later = function () &#123;</span><br><span class=\"line\">\t\t\t// 如果禁用第一次首先执行，返回0否则就用previous保存当前时间戳</span><br><span class=\"line\">\t\t\tprevious = options.leading === false ? 0 : _.now();</span><br><span class=\"line\">\t\t\t// 解除引用</span><br><span class=\"line\">\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t// 看到一种说法是在func函数里面重新给timeout赋值，会导致timeout依然存在，所以这里会判断!timeout</span><br><span class=\"line\">\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\treturn function () &#123;</span><br><span class=\"line\">\t\t    // 获取当前调用时的时间（ms）</span><br><span class=\"line\">\t\t\tvar now = _.now();</span><br><span class=\"line\">\t\t\t// 如果previous为0并且禁用了第一次执行，那么将previous设置为当前时间</span><br><span class=\"line\">\t\t\t// 这里用全等来避免undefined的情况</span><br><span class=\"line\">\t\t\tif (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">\t\t\t// 还要wait时间才会触发下一次func</span><br><span class=\"line\">\t\t\tvar remaining = wait - (now - previous);</span><br><span class=\"line\">\t\t\tcontext = this;</span><br><span class=\"line\">\t\t\targs = arguments;</span><br><span class=\"line\">\t\t\t// remaining小于0有两种情况，一种是上次调用后到现在已经到了wait时间</span><br><span class=\"line\">\t\t\t// 一种情况是第一次触发的时候并且options.leading不为false，previous为0，因为now记录的是unix时间戳，所以会远远大于wait</span><br><span class=\"line\">\t\t\t// remaining大于wait的情况我自己不清楚，但看到一种说法是客户端系统时间被调整过，可能会出现now小于previous的情况</span><br><span class=\"line\">\t\t\t// 这两种情形下会立即执行func函数，并把previous设置为now</span><br><span class=\"line\">\t\t\tif (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">\t\t\t\tif (timeout) &#123;</span><br><span class=\"line\">\t\t\t\t    // 清除定时器</span><br><span class=\"line\">\t\t\t\t\tclearTimeout(timeout);</span><br><span class=\"line\">\t\t\t\t\ttimeout = null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t// previous保存当前触发的时间戳</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t\tif (!timeout) context = args = null;</span><br><span class=\"line\">\t\t\t// 如果timeout不存在（当前定时器还存在）</span><br><span class=\"line\">\t\t\t// 并且options.trailing不为false，这个时候会重新设置定时器，remaining时间后执行later函数</span><br><span class=\"line\">\t\t\t&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">\t\t\t\ttimeout = setTimeout(later, remaining);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn result;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码看着不多，但是让我纠结了很久，运行的时候主要会有以下几种情况。</p>\n<h3 id=\"没有传leading和trailing\"><a href=\"#没有传leading和trailing\" class=\"headerlink\" title=\"没有传leading和trailing\"></a>没有传leading和trailing</h3><ol>\n<li>第一次触发函数的时候，由于previous为0，而now又非常大，所以会导致remaining为负值，满足下面第一个if判断，所以会立即执行func函数（第一次触发时立即调用）并且用previous记录当前时间戳</li>\n<li>第二次触发的时候由于previous记录了前一次的时间戳，所以now - previous几乎为0，这个时候满足else if里面的判断，会设置一个定时器，这个定时器在remaining时间后执行，所以只要在remaining时间内不管我们再怎么频繁触发，由于不会满足两个if里面的条件，所以都不会执行func，一直到remaining后才会执行func</li>\n<li>之后每次触发都会重复走2的流程</li>\n</ol>\n<h3 id=\"options-leading-false\"><a href=\"#options-leading-false\" class=\"headerlink\" title=\"options.leading: false\"></a>options.leading: false</h3><p>这种情况和上面情况类似，不过区别在于第一次触发的时候。<br>由于满足!previous &amp;&amp; options.leading === false这个条件，所以previous会被设置为now，这个时候remaining等于wait，所以会走else if的分支，这样就会重复前一种情况下步骤2的流程</p>\n<h3 id=\"options-trailing-false\"><a href=\"#options-trailing-false\" class=\"headerlink\" title=\"options.trailing: false\"></a>options.trailing: false</h3><ol>\n<li>由于没有设置leading为false，所以第一次触发就会立即执行一次func</li>\n<li>第二次触发的时候，由于previous保存了上次时间戳，所以remaining &lt;= wait，但是又因为options.trailing为false，这样就不会走if的任何一个分支，一直到now-previous大于wait的时候（也就是过了wait时间后），这样会满足if第一个分支的条件，func会立即被执行一次</li>\n<li>之后重复步骤2</li>\n</ol>\n<h3 id=\"trailing和leading都为false\"><a href=\"#trailing和leading都为false\" class=\"headerlink\" title=\"trailing和leading都为false\"></a>trailing和leading都为false</h3><p>最好不要这么写，因为会导致一个bug的出现，如果我们在一段时间内频繁触发，这个是没什么问题，但如果我们最后一次触发后停止等待ait时间后再重新开始触发，这时候的第一次触发就会立即执行func，leading为false并没有生效。</p>\n<p>不知道有没有人和我一样有这两个疑问，leading为false的时候，真的只是在第一次调用的时候有区别吗？trailing是怎么做到禁用最后一次执行的？<br>这两个问题让我昨晚睡觉前都还在纠结，还好今天在segmentfault上面有热心的用户帮我解答了。<br>请直接看第一个回答以及下面的评论区：<a href=\"https://segmentfault.com/q/1010000013899949\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></p>\n<h2 id=\"leading带来的不同表现\"><a href=\"#leading带来的不同表现\" class=\"headerlink\" title=\"leading带来的不同表现\"></a>leading带来的不同表现</h2><p>GDUTxxZ大神给了一段代码，执行后不同的表现让我印象深刻。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">  var context, args, result;</span><br><span class=\"line\">  var timeout = null;</span><br><span class=\"line\">  var previous = 0;</span><br><span class=\"line\">  if (!options) options = &#123;&#125;;</span><br><span class=\"line\">  var later = function() &#123;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    if (!timeout) context = args = null;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">    var now = new Date().getTime();</span><br><span class=\"line\">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">    var remaining = wait - (now - previous);</span><br><span class=\"line\">    context = this;</span><br><span class=\"line\">    args = arguments;</span><br><span class=\"line\">    // 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">      if (timeout) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      if (!timeout) context = args = null;</span><br><span class=\"line\">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">      timeout = setTimeout(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">  console.log(`函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行`)</span><br><span class=\"line\">&#125;, 1000, &#123;leading: false&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(test, 3000)</span><br></pre></td></tr></table></figure></p>\n<p>我将传入leading和没传入leading的情况作了以下比较。<br>leading为false时：<br><img src=\"http://static.zybuluo.com/gyyin/4wcaqpfe6f2jjgi252gb1omq/leading.jpg\" alt=\"leading为false\"><br>没有传入leading时：<br><img src=\"http://static.zybuluo.com/gyyin/j8ansl1zj2ozs3bagf8vg1fz/no%20leading.jpg\" alt=\"leading为true\"><br>当两次触发间隔时间大于wait时间的时候，很明显leading为false的时候总会在调用后延迟wait后执行func，而不传leading的时候两者是同时的，调用test的时候就直接运行了func。原本应该是callback =&gt; wait =&gt; callback</p>\n<p>一般情况下当然不会有这种极端情况存在，但是可能出现这种情况。如果在scroll事件中，我们滚动一段距离后停止了，等wait ms后再开始滚动，这个时候如果leading为false，依然会延迟wait时间后执行，而不是立即执行，这也是为什么同时设置leading和trailing为false的时候会出现问题。</p>\n<h2 id=\"为什么是禁用最后一次调用\"><a href=\"#为什么是禁用最后一次调用\" class=\"headerlink\" title=\"为什么是禁用最后一次调用\"></a>为什么是禁用最后一次调用</h2><p>trailing为false时到底是怎么禁用了最后一次调用？这个也一直让我很纠结。同样的，我也写了一段代码，比较了一下两次运行后的不同结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _now = new Date().getTime()</span><br><span class=\"line\">var throttle = function(func, wait, options) &#123;</span><br><span class=\"line\">var context, args, result;</span><br><span class=\"line\">var timeout = null;</span><br><span class=\"line\">var previous = 0;</span><br><span class=\"line\">if (!options) options = &#123;&#125;;</span><br><span class=\"line\">var later = function() &#123;</span><br><span class=\"line\">previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class=\"line\">timeout = null;</span><br><span class=\"line\">result = func.apply(context, args);</span><br><span class=\"line\">if (!timeout) context = args = null;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return function() &#123;</span><br><span class=\"line\">console.log(`函数$&#123;++i&#125;在$&#123;new Date().getTime() - _now&#125;调用`)</span><br><span class=\"line\">var now = new Date().getTime();</span><br><span class=\"line\">if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class=\"line\">var remaining = wait - (now - previous);</span><br><span class=\"line\">context = this;</span><br><span class=\"line\">args = arguments;</span><br><span class=\"line\">// 如果超过了wait时间，那么就立即执行</span><br><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">  if (timeout) &#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  previous = now;</span><br><span class=\"line\">  result = func.apply(context, args);</span><br><span class=\"line\">  if (!timeout) context = args = null;</span><br><span class=\"line\">&#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class=\"line\">  timeout = setTimeout(later, remaining);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var i = 0</span><br><span class=\"line\">var test = throttle(() =&gt; &#123;</span><br><span class=\"line\">console.log(函数$&#123;i&#125;在$&#123;new Date().getTime() - _now&#125;执行)</span><br><span class=\"line\">&#125;, 1000, &#123;trailing: false&#125;)</span><br><span class=\"line\">window.addEventListener(&quot;scroll&quot;, test)</span><br></pre></td></tr></table></figure></p>\n<p>trailing为false时：<br><img src=\"http://static.zybuluo.com/gyyin/9htepogt26ygnykj2kd295b9/trailing.jpg\" alt=\"trailing为false\"></p>\n<p>没有设置trailing时：<br><img src=\"http://static.zybuluo.com/gyyin/rg9pwy7zj9so31f67ffswu7b/no%20trailing.jpg\" alt=\"没有设置trailing\"></p>\n<p>这两张图很明显的不同就是设置了trailing的时候，最后一次总是”执行”，而未设置trailing最后一次总是”调用”，少了一次执行。</p>\n<p>我们可以假设在一种临界的场景下，比如在倒数第二次执行func后的 (wait-1) 的时间内。<br>如果设置了trailing，因为无法走setTimeout，所以只能等待wait时间后才能立即调用func，所以在（wait-1）的时间内无论我们触发了多少次都不会执行func函数。<br>如果没有设置trailing，那么肯定会走setTimeout，在这个期间触发的第一次就会设置一个定时器，等到wait时间后自动执行func函数，到（wait-1）的这段时间内不管我们触发了多少次，反正第一次触发的时候就已经设置了定时器，所以到最后一定会执行一次func函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很久以前就使用过throttle函数，自己也实现过简单的，但是看到underscore源码后才发现原来还会有这么多令人充满想象的场景，自己所学的这点知识真的是皮毛。<br>我知道自己平时叙述比较罗嗦，语言又比较无聊，希望大家可以理解，如果看完还不懂，建议结合下面的参考链接。<br>本文有错误和不足之处，也希望大家能够指出。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><ol>\n<li><a href=\"https://segmentfault.com/q/1010000013899949?_ea=3493310\" target=\"_blank\" rel=\"noopener\">关于underscore源码中throttle函数的疑惑？</a></li>\n<li><a href=\"https://github.com/hanzichi/underscore-analysis/issues/22\" target=\"_blank\" rel=\"noopener\"> underscore 函数节流的实现</a></li>\n<li><a href=\"http://www.easyui.info/archives/1853.html\" target=\"_blank\" rel=\"noopener\"> Underscore之throttle函数源码分析以及使用注意事项\n</a></li>\n<li><a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\" target=\"_blank\" rel=\"noopener\">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a></li>\n</ol>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之数组遍历函数分析（一）","date":"2018-03-19T14:11:23.000Z","_content":"这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。\n\n\n## **each** ##\n\n在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。\n```\n// iteratee函数有三个参数，分别是item、index、array或者value、key、obj\n_.each = _.forEach = function(obj, iteratee, context) {\n    // 如果不传context，那么each方法里面的this就会指向window\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等\n    if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n            iteratee(obj[i], i, obj);\n        }\n    // 一般是指对象\n    } else {\n        var keys = _.keys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n            iteratee(obj[keys[i]], keys[i], obj);\n        }\n    }\n    return obj;\n};\n```\neach函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数\n<!-- more -->\n不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。\n### optimizeCb ###\n```\n    // 这个函数主要是给传进来的func函数绑定context作用域。\n\tvar optimizeCb = function (func, context, argCount) {\n\t    // 如果没有传context，那就直接返回func函数\n\t\tif (context === void 0) return func;\n\t\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数\n\t\tswitch (argCount == null ? 3 : argCount) {\n\t\t\tcase 1: return function (value) {\n\t\t\t\treturn func.call(context, value);\n\t\t\t};\n\t\t\tcase 2: return function (value, other) {\n\t\t\t\treturn func.call(context, value, other);\n\t\t\t};\n\t\t\t// 一般是each、map等\n\t\t\tcase 3: return function (value, index, collection) {\n\t\t\t\treturn func.call(context, value, index, collection);\n\t\t\t};\n\t\t\t// 一般是reduce等\n\t\t\tcase 4: return function (accumulator, value, index, collection) {\n\t\t\t\treturn func.call(context, accumulator, value, index, collection);\n\t\t\t};\n\t\t}\n\t\t// 如果参数数量大于4\n\t\treturn function () {\n\t\t\treturn func.apply(context, arguments);\n\t\t};\n\t};\n```\n其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。\n这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？\n原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：[call和apply][1]\n\n### isArrayLike ###\n关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）\n```\n// 一个高阶函数，返回对象上某个具体属性的值\nvar property = function (key) {\n\treturn function (obj) {\n\t\treturn obj == null ? void 0 : obj[key];\n\t};\n};\n\n// 这里有个ios8上面的bug，会导致类似var pbj = {1: \"a\", 2: \"b\", 3: \"c\"}这种对象的obj.length = 4; jQuery中也有这个bug。\n// https://github.com/jashkenas/underscore/issues/2081 \n// https://github.com/jquery/jquery/issues/2145\n// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).\n// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// 据说用obj[\"length\"]就可以解决？我没有ios8的环境，有兴趣的可以试试\nvar getLength = property('length');\n\n// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组\nvar isArrayLike = function (collection) {\n\tvar length = getLength(collection);\n\treturn typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n};\n```\n在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。\n我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。\n```\nfunction isArrayLike(obj) {\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType(obj);\n\t// 排除了obj为function和全局中有length变量的情况\n\tif (isFunction(obj) || isWindow(obj)) {\n\t\treturn false;\n\t}\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n```\njQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。\n\n最后的三个判断分别是：\n\n 1. 如果obj的类型是数组，那么返回true\n 2. 如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。\n 3. 最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length>0和length===\"number\"的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。\n## map ##\n说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。\n```\nvar arr = [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result1 = _.map(arr); // [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result2 = _.map(arr, {name: 'Daisy'}) // [false, true]\n```\n所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。\n```\n_.map = _.collect = function (obj, iteratee, context) {\n\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。\n\t\titeratee = cb(iteratee, context);\n\t\t// 如果不是类数组（是对象），则获取到keys\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn results;\n\t};\n```\n### cb ###\n我们来看看map函数中这个cb函数到底是什么来历？\n```\n_.identity = function (value) {\n\treturn value;\n};\nvar cb = function (value, context, argCount) {\n    // 如果value不存在\n\tif (value == null) return _.identity;\n\t// 如果传入的是个函数\n\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\t// 如果传入的是个对象\n\tif (_.isObject(value)) return _.matcher(value);\n\treturn _.property(value);\n};\n```\ncb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。\n 1. 如果value不存在，那就对应上面的_.map(obj)的情况，map中的iteratee就是_.identity函数，他会将后面接收到的obj[currentKey]直接返回。\n 2. 如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的\n 3. 如果value是个对象，对应_.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用_.matcher函数\n 4. 这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：[iteratee函数][2]\n### matcher ###\n那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。\n```\n_.matcher = _.matches = function (attrs) {\n    // 将attrs和{}合并为一个对象（避免attrs为undefined）\n\tattrs = _.extendOwn({}, attrs);\n\treturn function (obj) {\n\t\treturn _.isMatch(obj, attrs);\n\t};\n};\n// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项\n_.isMatch = function (object, attrs) {\n\tvar keys = _.keys(attrs), length = keys.length;\n\t// 如果object和attr都是空，那么返回true，否则object为空时返回false\n\tif (object == null) return !length;\n\t// 这一步没懂是为了做什么？\n\tvar obj = Object(object);\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;\n\t}\n\treturn true;\n};\n```\nmatcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。\n这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。\n所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。\n这也就是为什么_.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); 会返回 [false, true]。\n### 重写each ###\neach和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each\n```\n_.each = _.forEach = function (obj, iteratee, context) {\n\t\titeratee = optimizeCb(iteratee, context);\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\titeratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn obj;\n\t};\n```\n## filter、every、some、reject ##\n这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。\n\n  [1]: https://segmentfault.com/q/1010000007894513\n  [2]: http://www.bootcss.com/p/underscore/#iteratee\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之数组遍历函数分析（一）.md","raw":"---\ntitle: underscore源码剖析之数组遍历函数分析（一）\ndate: 2018-03-19 22:11:23\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n\t- underscore\n---\n这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。\n\n\n## **each** ##\n\n在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。\n```\n// iteratee函数有三个参数，分别是item、index、array或者value、key、obj\n_.each = _.forEach = function(obj, iteratee, context) {\n    // 如果不传context，那么each方法里面的this就会指向window\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等\n    if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n            iteratee(obj[i], i, obj);\n        }\n    // 一般是指对象\n    } else {\n        var keys = _.keys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n            iteratee(obj[keys[i]], keys[i], obj);\n        }\n    }\n    return obj;\n};\n```\neach函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数\n<!-- more -->\n不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。\n### optimizeCb ###\n```\n    // 这个函数主要是给传进来的func函数绑定context作用域。\n\tvar optimizeCb = function (func, context, argCount) {\n\t    // 如果没有传context，那就直接返回func函数\n\t\tif (context === void 0) return func;\n\t\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数\n\t\tswitch (argCount == null ? 3 : argCount) {\n\t\t\tcase 1: return function (value) {\n\t\t\t\treturn func.call(context, value);\n\t\t\t};\n\t\t\tcase 2: return function (value, other) {\n\t\t\t\treturn func.call(context, value, other);\n\t\t\t};\n\t\t\t// 一般是each、map等\n\t\t\tcase 3: return function (value, index, collection) {\n\t\t\t\treturn func.call(context, value, index, collection);\n\t\t\t};\n\t\t\t// 一般是reduce等\n\t\t\tcase 4: return function (accumulator, value, index, collection) {\n\t\t\t\treturn func.call(context, accumulator, value, index, collection);\n\t\t\t};\n\t\t}\n\t\t// 如果参数数量大于4\n\t\treturn function () {\n\t\t\treturn func.apply(context, arguments);\n\t\t};\n\t};\n```\n其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。\n这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？\n原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：[call和apply][1]\n\n### isArrayLike ###\n关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）\n```\n// 一个高阶函数，返回对象上某个具体属性的值\nvar property = function (key) {\n\treturn function (obj) {\n\t\treturn obj == null ? void 0 : obj[key];\n\t};\n};\n\n// 这里有个ios8上面的bug，会导致类似var pbj = {1: \"a\", 2: \"b\", 3: \"c\"}这种对象的obj.length = 4; jQuery中也有这个bug。\n// https://github.com/jashkenas/underscore/issues/2081 \n// https://github.com/jquery/jquery/issues/2145\n// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).\n// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// 据说用obj[\"length\"]就可以解决？我没有ios8的环境，有兴趣的可以试试\nvar getLength = property('length');\n\n// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组\nvar isArrayLike = function (collection) {\n\tvar length = getLength(collection);\n\treturn typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n};\n```\n在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。\n我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。\n```\nfunction isArrayLike(obj) {\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType(obj);\n\t// 排除了obj为function和全局中有length变量的情况\n\tif (isFunction(obj) || isWindow(obj)) {\n\t\treturn false;\n\t}\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n```\njQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。\n\n最后的三个判断分别是：\n\n 1. 如果obj的类型是数组，那么返回true\n 2. 如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。\n 3. 最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length>0和length===\"number\"的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。\n## map ##\n说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。\n```\nvar arr = [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result1 = _.map(arr); // [{name:'Kevin'}, {name: 'Daisy', age: 18}]\nvar result2 = _.map(arr, {name: 'Daisy'}) // [false, true]\n```\n所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。\n```\n_.map = _.collect = function (obj, iteratee, context) {\n\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。\n\t\titeratee = cb(iteratee, context);\n\t\t// 如果不是类数组（是对象），则获取到keys\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn results;\n\t};\n```\n### cb ###\n我们来看看map函数中这个cb函数到底是什么来历？\n```\n_.identity = function (value) {\n\treturn value;\n};\nvar cb = function (value, context, argCount) {\n    // 如果value不存在\n\tif (value == null) return _.identity;\n\t// 如果传入的是个函数\n\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\t// 如果传入的是个对象\n\tif (_.isObject(value)) return _.matcher(value);\n\treturn _.property(value);\n};\n```\ncb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。\n 1. 如果value不存在，那就对应上面的_.map(obj)的情况，map中的iteratee就是_.identity函数，他会将后面接收到的obj[currentKey]直接返回。\n 2. 如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的\n 3. 如果value是个对象，对应_.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用_.matcher函数\n 4. 这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：[iteratee函数][2]\n### matcher ###\n那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。\n```\n_.matcher = _.matches = function (attrs) {\n    // 将attrs和{}合并为一个对象（避免attrs为undefined）\n\tattrs = _.extendOwn({}, attrs);\n\treturn function (obj) {\n\t\treturn _.isMatch(obj, attrs);\n\t};\n};\n// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项\n_.isMatch = function (object, attrs) {\n\tvar keys = _.keys(attrs), length = keys.length;\n\t// 如果object和attr都是空，那么返回true，否则object为空时返回false\n\tif (object == null) return !length;\n\t// 这一步没懂是为了做什么？\n\tvar obj = Object(object);\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;\n\t}\n\treturn true;\n};\n```\nmatcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。\n这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。\n所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。\n这也就是为什么_.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); 会返回 [false, true]。\n### 重写each ###\neach和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each\n```\n_.each = _.forEach = function (obj, iteratee, context) {\n\t\titeratee = optimizeCb(iteratee, context);\n\t\tvar keys = !isArrayLike(obj) && _.keys(obj),\n\t\t\tlength = (keys || obj).length,\n\t\t\tresults = Array(length);\n\t\tfor (var index = 0; index < length; index++) {\n\t\t\tvar currentKey = keys ? keys[index] : index;\n\t\t\titeratee(obj[currentKey], currentKey, obj);\n\t\t}\n\t\treturn obj;\n\t};\n```\n## filter、every、some、reject ##\n这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。\n\n  [1]: https://segmentfault.com/q/1010000007894513\n  [2]: http://www.bootcss.com/p/underscore/#iteratee\n  <head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之数组遍历函数分析（一）","published":1,"updated":"2018-11-22T11:48:33.212Z","_id":"cjosj7rz6003kfpzx03zv05h7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。</p>\n<h2 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"each\"></a><strong>each</strong></h2><p>在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iteratee函数有三个参数，分别是item、index、array或者value、key、obj</span><br><span class=\"line\">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 如果不传context，那么each方法里面的this就会指向window</span><br><span class=\"line\">    iteratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">    var i, length;</span><br><span class=\"line\">    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">        for (i = 0, length = obj.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[i], i, obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    // 一般是指对象</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var keys = _.keys(obj);</span><br><span class=\"line\">        for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[keys[i]], keys[i], obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>each函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数<br><a id=\"more\"></a><br>不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。</p>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // 这个函数主要是给传进来的func函数绑定context作用域。</span><br><span class=\"line\">var optimizeCb = function (func, context, argCount) &#123;</span><br><span class=\"line\">    // 如果没有传context，那就直接返回func函数</span><br><span class=\"line\">\tif (context === void 0) return func;</span><br><span class=\"line\">\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数</span><br><span class=\"line\">\tswitch (argCount == null ? 3 : argCount) &#123;</span><br><span class=\"line\">\t\tcase 1: return function (value) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tcase 2: return function (value, other) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, other);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是each、map等</span><br><span class=\"line\">\t\tcase 3: return function (value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是reduce等</span><br><span class=\"line\">\t\tcase 4: return function (accumulator, value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 如果参数数量大于4</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\treturn func.apply(context, arguments);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。<br>这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？<br>原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：<a href=\"https://segmentfault.com/q/1010000007894513\" target=\"_blank\" rel=\"noopener\">call和apply</a></p>\n<h3 id=\"isArrayLike\"><a href=\"#isArrayLike\" class=\"headerlink\" title=\"isArrayLike\"></a>isArrayLike</h3><p>关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个高阶函数，返回对象上某个具体属性的值</span><br><span class=\"line\">var property = function (key) &#123;</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn obj == null ? void 0 : obj[key];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里有个ios8上面的bug，会导致类似var pbj = &#123;1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;&#125;这种对象的obj.length = 4; jQuery中也有这个bug。</span><br><span class=\"line\">// https://github.com/jashkenas/underscore/issues/2081 </span><br><span class=\"line\">// https://github.com/jquery/jquery/issues/2145</span><br><span class=\"line\">// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).</span><br><span class=\"line\">// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer</span><br><span class=\"line\">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 据说用obj[&quot;length&quot;]就可以解决？我没有ios8的环境，有兴趣的可以试试</span><br><span class=\"line\">var getLength = property(&apos;length&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组</span><br><span class=\"line\">var isArrayLike = function (collection) &#123;</span><br><span class=\"line\">\tvar length = getLength(collection);</span><br><span class=\"line\">\treturn typeof length == &apos;number&apos; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。<br>我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArrayLike(obj) &#123;</span><br><span class=\"line\">\t// Support: real iOS 8.2 only (not reproducible in simulator)</span><br><span class=\"line\">\t// `in` check used to prevent JIT error (gh-2145)</span><br><span class=\"line\">\t// hasOwn isn&apos;t used here due to false negatives</span><br><span class=\"line\">\t// regarding Nodelist length in IE</span><br><span class=\"line\">\tvar length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class=\"line\">\t\ttype = toType(obj);</span><br><span class=\"line\">\t// 排除了obj为function和全局中有length变量的情况</span><br><span class=\"line\">\tif (isFunction(obj) || isWindow(obj)) &#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn type === &quot;array&quot; || length === 0 ||</span><br><span class=\"line\">\t\ttypeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。</p>\n<p>最后的三个判断分别是：</p>\n<ol>\n<li>如果obj的类型是数组，那么返回true</li>\n<li>如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。</li>\n<li>最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length&gt;0和length===”number”的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2>说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result1 = _.map(arr); // [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result2 = _.map(arr, &#123;name: &apos;Daisy&apos;&#125;) // [false, true]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.map = _.collect = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。</span><br><span class=\"line\">\t\titeratee = cb(iteratee, context);</span><br><span class=\"line\">\t\t// 如果不是类数组（是对象），则获取到keys</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p>我们来看看map函数中这个cb函数到底是什么来历？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.identity = function (value) &#123;</span><br><span class=\"line\">\treturn value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var cb = function (value, context, argCount) &#123;</span><br><span class=\"line\">    // 如果value不存在</span><br><span class=\"line\">\tif (value == null) return _.identity;</span><br><span class=\"line\">\t// 如果传入的是个函数</span><br><span class=\"line\">\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);</span><br><span class=\"line\">\t// 如果传入的是个对象</span><br><span class=\"line\">\tif (_.isObject(value)) return _.matcher(value);</span><br><span class=\"line\">\treturn _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>cb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。</p>\n<ol>\n<li>如果value不存在，那就对应上面的<em>.map(obj)的情况，map中的iteratee就是</em>.identity函数，他会将后面接收到的obj[currentKey]直接返回。</li>\n<li>如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的</li>\n<li>如果value是个对象，对应<em>.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用</em>.matcher函数</li>\n<li>这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：<a href=\"http://www.bootcss.com/p/underscore/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee函数</a><h3 id=\"matcher\"><a href=\"#matcher\" class=\"headerlink\" title=\"matcher\"></a>matcher</h3>那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.matcher = _.matches = function (attrs) &#123;</span><br><span class=\"line\">    // 将attrs和&#123;&#125;合并为一个对象（避免attrs为undefined）</span><br><span class=\"line\">\tattrs = _.extendOwn(&#123;&#125;, attrs);</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn _.isMatch(obj, attrs);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项</span><br><span class=\"line\">_.isMatch = function (object, attrs) &#123;</span><br><span class=\"line\">\tvar keys = _.keys(attrs), length = keys.length;</span><br><span class=\"line\">\t// 如果object和attr都是空，那么返回true，否则object为空时返回false</span><br><span class=\"line\">\tif (object == null) return !length;</span><br><span class=\"line\">\t// 这一步没懂是为了做什么？</span><br><span class=\"line\">\tvar obj = Object(object);</span><br><span class=\"line\">\tfor (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tvar key = keys[i];</span><br><span class=\"line\">\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>matcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。<br>这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。<br>所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。<br>这也就是为什么_.map([{name:’Kevin’}, {name: ‘Daisy’, age: 18}], {name: ‘Daisy’}); 会返回 [false, true]。</p>\n<h3 id=\"重写each\"><a href=\"#重写each\" class=\"headerlink\" title=\"重写each\"></a>重写each</h3><p>each和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each = _.forEach = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\titeratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn obj;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter、every、some、reject\"><a href=\"#filter、every、some、reject\" class=\"headerlink\" title=\"filter、every、some、reject\"></a>filter、every、some、reject</h2><p>这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>这是underscore源码剖析系列第三篇文章，主要介绍underscore中each、map、filter、every、reduce等我们常用的一些遍历数组的方法。</p>\n<h2 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"each\"></a><strong>each</strong></h2><p>在underscore中我们最常用的就是each和map两个方法了，这两个方法一般接收三个参数，分别是数组/对象、函数、上下文。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iteratee函数有三个参数，分别是item、index、array或者value、key、obj</span><br><span class=\"line\">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class=\"line\">    // 如果不传context，那么each方法里面的this就会指向window</span><br><span class=\"line\">    iteratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">    var i, length;</span><br><span class=\"line\">    // 如果是类数组，一般来说包括数组、arguments、DOM集合等等</span><br><span class=\"line\">    if (isArrayLike(obj)) &#123;</span><br><span class=\"line\">        for (i = 0, length = obj.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[i], i, obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    // 一般是指对象</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        var keys = _.keys(obj);</span><br><span class=\"line\">        for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">            iteratee(obj[keys[i]], keys[i], obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>each函数的源码很简单，函数内部会使用isArrayLike方法来判断当前传入的第一个参数是类数组或者对象，如果是类数组，直接使用访问下标的方式来遍历，并将数组的项和index传给iteratee函数，如果是对象，则先获取到对象的keys，再进行遍历后将对象的value和key传给iteratee函数<br>","more":"<br>不过在这里，我们主要分析optimizeCb和isArrayLike两个函数。</p>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // 这个函数主要是给传进来的func函数绑定context作用域。</span><br><span class=\"line\">var optimizeCb = function (func, context, argCount) &#123;</span><br><span class=\"line\">    // 如果没有传context，那就直接返回func函数</span><br><span class=\"line\">\tif (context === void 0) return func;</span><br><span class=\"line\">\t// 如果没有传入argCount，那就默认是3。这里是根据第二次传入的参数个数来给call函数传入不同数量的参数</span><br><span class=\"line\">\tswitch (argCount == null ? 3 : argCount) &#123;</span><br><span class=\"line\">\t\tcase 1: return function (value) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tcase 2: return function (value, other) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, other);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是each、map等</span><br><span class=\"line\">\t\tcase 3: return function (value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t// 一般是reduce等</span><br><span class=\"line\">\t\tcase 4: return function (accumulator, value, index, collection) &#123;</span><br><span class=\"line\">\t\t\treturn func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 如果参数数量大于4</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\treturn func.apply(context, arguments);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实我们很容易就看出来optimizeCb函数只是帮func函数绑定context的，如果不存在context，那么直接返回func，否则则会根据第二次传给func函数的参数数量来判断给call函数传几个值。<br>这里有个重点，为什么要用这么麻烦的方式，而不直接用apply来将arguments全部传进去？<br>原因是call方法的速度要比apply方法更快，因为apply会对数组参数进行检验和拷贝，所以这里就对常用的几种形式使用了call，其他情况下使用了apply，详情可以看这里：<a href=\"https://segmentfault.com/q/1010000007894513\" target=\"_blank\" rel=\"noopener\">call和apply</a></p>\n<h3 id=\"isArrayLike\"><a href=\"#isArrayLike\" class=\"headerlink\" title=\"isArrayLike\"></a>isArrayLike</h3><p>关于isArrayLike方法，我们来看underscore的实现。（这个延伸比较多，如果没兴趣，可以跳过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个高阶函数，返回对象上某个具体属性的值</span><br><span class=\"line\">var property = function (key) &#123;</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn obj == null ? void 0 : obj[key];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里有个ios8上面的bug，会导致类似var pbj = &#123;1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;&#125;这种对象的obj.length = 4; jQuery中也有这个bug。</span><br><span class=\"line\">// https://github.com/jashkenas/underscore/issues/2081 </span><br><span class=\"line\">// https://github.com/jquery/jquery/issues/2145</span><br><span class=\"line\">// MAX_SAFE_INTEGER is 9007199254740991 (Math.pow(2, 53) - 1).</span><br><span class=\"line\">// http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer</span><br><span class=\"line\">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 据说用obj[&quot;length&quot;]就可以解决？我没有ios8的环境，有兴趣的可以试试</span><br><span class=\"line\">var getLength = property(&apos;length&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是类数组，如果有length属性并且值为number类型即可视作类数组</span><br><span class=\"line\">var isArrayLike = function (collection) &#123;</span><br><span class=\"line\">\tvar length = getLength(collection);</span><br><span class=\"line\">\treturn typeof length == &apos;number&apos; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在underscore中，只要带有length属性，都可以被认为是类数组，所以即使是{length: 10}这种情况也会被归为类数组。<br>我个人感觉这样写其实太过片面，我还是更喜欢jQuery里面isArrayLike方法的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArrayLike(obj) &#123;</span><br><span class=\"line\">\t// Support: real iOS 8.2 only (not reproducible in simulator)</span><br><span class=\"line\">\t// `in` check used to prevent JIT error (gh-2145)</span><br><span class=\"line\">\t// hasOwn isn&apos;t used here due to false negatives</span><br><span class=\"line\">\t// regarding Nodelist length in IE</span><br><span class=\"line\">\tvar length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,</span><br><span class=\"line\">\t\ttype = toType(obj);</span><br><span class=\"line\">\t// 排除了obj为function和全局中有length变量的情况</span><br><span class=\"line\">\tif (isFunction(obj) || isWindow(obj)) &#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn type === &quot;array&quot; || length === 0 ||</span><br><span class=\"line\">\t\ttypeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jQuery中使用in来解决ios8下面那个JIT的错误，同时还会排除obj是函数和window的情况，因为如果obj是函数，那么obj.length则是这个函数参数的个数，而如果obj是window，那么我在全局中定义一个var length = 10，这个同样也能获取到length。</p>\n<p>最后的三个判断分别是：</p>\n<ol>\n<li>如果obj的类型是数组，那么返回true</li>\n<li>如果obj的length是0，也返回true。即使是{length: 0}这种情况，因为在调用isArrayLike的each和map等方法中会在for循环里面判断length，所以也不会造成影响。</li>\n<li>最后这个(length - 1) in obj我个人理解就是为了排除{length: 10}这种情况，因为这个可以满足length&gt;0和length===”number”的情况，但是一般情况下是无法满足最后(length - 1) in obj的，但是NodeList和arguments这些却可以满足这个条件。<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2>说完了each，我们再来说说map，map函数其实和each的实现很类似，不过不一样的一个地方在于，map函数的第二个参数不一定是函数，我们可以什么都不传，甚至还可以传个对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result1 = _.map(arr); // [&#123;name:&apos;Kevin&apos;&#125;, &#123;name: &apos;Daisy&apos;, age: 18&#125;]</span><br><span class=\"line\">var result2 = _.map(arr, &#123;name: &apos;Daisy&apos;&#125;) // [false, true]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>所以这里就会对传入map的第二个参数进行判断，整体来说map函数的实现比each更加简洁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.map = _.collect = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\t// 因为在map中，第二个参数可能不是函数，所以用cb，这点和each的实现不一样。</span><br><span class=\"line\">\t\titeratee = cb(iteratee, context);</span><br><span class=\"line\">\t\t// 如果不是类数组（是对象），则获取到keys</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\t// 这里根据keys是否存在来判断传给iteratee是key还是index</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\tresults[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn results;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p>我们来看看map函数中这个cb函数到底是什么来历？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.identity = function (value) &#123;</span><br><span class=\"line\">\treturn value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var cb = function (value, context, argCount) &#123;</span><br><span class=\"line\">    // 如果value不存在</span><br><span class=\"line\">\tif (value == null) return _.identity;</span><br><span class=\"line\">\t// 如果传入的是个函数</span><br><span class=\"line\">\tif (_.isFunction(value)) return optimizeCb(value, context, argCount);</span><br><span class=\"line\">\t// 如果传入的是个对象</span><br><span class=\"line\">\tif (_.isObject(value)) return _.matcher(value);</span><br><span class=\"line\">\treturn _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>cb函数在underscore中一般是用在遍历方法中，大多数情况下value都是一个函数，我们结合上面map的源码和例子来看。</p>\n<ol>\n<li>如果value不存在，那就对应上面的<em>.map(obj)的情况，map中的iteratee就是</em>.identity函数，他会将后面接收到的obj[currentKey]直接返回。</li>\n<li>如果value是一个函数，就对应_.map(obj, func)这种情况，那么会再调用optimizeCb方法，这里就和each的实现是一样的</li>\n<li>如果value是个对象，对应<em>.map(obj, arrts)的情况，就会比较obj中的属性是否在arr里面，这个时候会调用</em>.matcher函数</li>\n<li>这种情况一般是用在_.iteratee函数中，用来访问对象的某个属性，具体看这里：<a href=\"http://www.bootcss.com/p/underscore/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee函数</a><h3 id=\"matcher\"><a href=\"#matcher\" class=\"headerlink\" title=\"matcher\"></a>matcher</h3>那么我们再来看matcher函数，matcher函数内部对两个对象做了浅比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.matcher = _.matches = function (attrs) &#123;</span><br><span class=\"line\">    // 将attrs和&#123;&#125;合并为一个对象（避免attrs为undefined）</span><br><span class=\"line\">\tattrs = _.extendOwn(&#123;&#125;, attrs);</span><br><span class=\"line\">\treturn function (obj) &#123;</span><br><span class=\"line\">\t\treturn _.isMatch(obj, attrs);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// isMatch方法会对接收到的attrs对象进行遍历，同时比较obj中是否有这一项</span><br><span class=\"line\">_.isMatch = function (object, attrs) &#123;</span><br><span class=\"line\">\tvar keys = _.keys(attrs), length = keys.length;</span><br><span class=\"line\">\t// 如果object和attr都是空，那么返回true，否则object为空时返回false</span><br><span class=\"line\">\tif (object == null) return !length;</span><br><span class=\"line\">\t// 这一步没懂是为了做什么？</span><br><span class=\"line\">\tvar obj = Object(object);</span><br><span class=\"line\">\tfor (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\tvar key = keys[i];</span><br><span class=\"line\">\t\tif (attrs[key] !== obj[key] || !(key in obj)) return false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>matcher是个高阶方法，他会将两次接收到的对象传给isMatch函数来进行判断。首先是以attrs为被遍历的对象，通过对比obj[key]和attrs[key]的值，只要obj中的值和attrs中的不想等，就会返回false。<br>这里还会排除一种情况，如果attrs中对应key的value正好是undefined，而且obj中并没有key这个属性，这样obj[key]和attrs[key]其实都是undefined，这里使用！==来比较必然会返回false，实际上两者应该是不想等的。<br>所以使用in来判断obj上到底有没有key这个属性，如果没有，也会返回false。如果attrs上面所有属性在obj中都能找到，并且两者的值正好相等，那么就会返回true。<br>这也就是为什么_.map([{name:’Kevin’}, {name: ‘Daisy’, age: 18}], {name: ‘Daisy’}); 会返回 [false, true]。</p>\n<h3 id=\"重写each\"><a href=\"#重写each\" class=\"headerlink\" title=\"重写each\"></a>重写each</h3><p>each和map实现原理基本上一样，不过map更加简洁，这里可以用map的形式重写一下each<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each = _.forEach = function (obj, iteratee, context) &#123;</span><br><span class=\"line\">\t\titeratee = optimizeCb(iteratee, context);</span><br><span class=\"line\">\t\tvar keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class=\"line\">\t\t\tlength = (keys || obj).length,</span><br><span class=\"line\">\t\t\tresults = Array(length);</span><br><span class=\"line\">\t\tfor (var index = 0; index &lt; length; index++) &#123;</span><br><span class=\"line\">\t\t\tvar currentKey = keys ? keys[index] : index;</span><br><span class=\"line\">\t\t\titeratee(obj[currentKey], currentKey, obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn obj;</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter、every、some、reject\"><a href=\"#filter、every、some、reject\" class=\"headerlink\" title=\"filter、every、some、reject\"></a>filter、every、some、reject</h2><p>这几种方法的实现和上面的each、map类似，这里就不多做解释了，有兴趣的可以自己去看一下。</p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"underscore源码剖析之整体架构","date":"2018-03-16T13:08:56.000Z","_content":"最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。\n本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。\n今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。\n## 基础模块 ##\n首先，我们先来简单的看一下整体的代码：\n```\n// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)\n(function() {\n\n  var root = this;\n  \n  // 保存当前环境中已经存在的_变量（在noConflict中用到）\n  var previousUnderscore = root._;\n  \n  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  var Ctor = function(){};\n  // 内部实现省略\n  var _ = function(obj) {};\n  \n    // 这里是各种方法的实现（省略）\n    \n  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n  \n  // 版本号\n  _.VERSION = '1.8.3';\n  \n  // 用amd的形式导出\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this))\n```\n<!-- more -->\n## 全局对象 ##\n这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：\n```\nvar root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this;\n```\n这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。\n\n## void(0) ? undefined ##\n扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？\n关于void的解释，我们可以看这里：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\nvoid 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。\n其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[\"ygy\"]、Object.\\__undefined\\__、Object.\\__ygy\\__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined\n\n## noConflict ##\n也许有时候我们会碰到这样一种情况，\\_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。\n```\n_.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n};\nvar underscore = _.noConflict();\n```\n显而易见，这里正常保留原来的\\_变量，并返回了underscore这个方法（this就是\\_方法）\n## \\_ ##\n接下来讲到了本文的重点，关于\\_方法的分析，在看源码之前，我们先熟悉一下\\_的用法。\n这里总结的是我日常的用法，如果有遗漏，希望大家补充。\n一种是直接调用\\_上的方法，比如\\_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如\\_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(\"body\").click()则是调用jQuery原型上的方法。\n\n既然\\_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。\n\n这里来看源码：\n```\n// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。\nvar _ = function(obj) {\n    // 如果obj是_的实例（这种情况我真的没碰到过）\n    if (obj instanceof _) return obj;\n    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）\n    if (!(this instanceof _)) return new _(obj);\n    // 对应_([1,2,3])这种情况\n    this._wrapped = obj;\n  };\n```\n我先从源码上来解释，这里可以看出来\\_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。\n```\nvar Person = function() {\n    this.name = \"ygy\";\n    this.age = 22;\n}\nPerson.say = function() {\n    console.log(\"hello\")\n}\nPerson.prototype.say = function() {\n    console.log(\"world\")\n}\nvar ygy = new Person();\nPerson.say(); // hello\nygy.say(); // world\n```\n所以我们平时用的\\_.map就是Person.say()这种用法，而\\_([1, 2, 3]).map则是ygy.say()这种用法。\n\n在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？\n\n首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针\\__proto\\__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：\n```\nvar ygy = {};\nygy.__proto__ = Person.prototype \n// 或者var ygy = Object.create(Person.prototype)\nPerson.call(ygy);\n```\n这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析\\_方法的源码：\n\\_接收一个对象作为参数，如果这个对象是\\_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）\n    \n如果this不是\\_的实例，那么就会返回一个新的实例new \\_(obj)，这个该怎么理解？\n我们需要结合例子来看这句话，在\\_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。\n    \n那么既然this指向window，那么this肯定不是\\_的实例，所以this instanceof \\_必然会返回false，这样的话就会return一个new \\_([1, 2, 3])，所以\\_([1, 2, 3])就是new \\_([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：\n```\nvar obj = {}\nobj.__proto__ = _.prototype\n// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用\n_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]\n```\n这样我们就理解了为什么\\_([1, 2, 3]).map中map是原型上的方法，因为\\_([1, 2, 3])是一个实例。\n\n我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：\n```\nvar _ = function(obj) {\n    return new _.prototype.init(obj)\n}\n_.prototype = {\n    init: function(obj) {\n    \tthis.__wrapped = obj\n    \treturn this\n    },\n    name: function(name) {\n        console.log(name)\n    }\n}\n_.prototype.init.prototype = _.prototype;\nvar a = _([1, 2, 3])\na.name(\"ygy\"); // ygy\n```\nunderscore中所有方法都是在\\_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。\n如果本文有错误和不足之处，希望大家指出。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之整体架构.md","raw":"---\ntitle: underscore源码剖析之整体架构\ndate: 2018-03-16 21:08:56\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n  - underscore\n---\n最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。\n本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。\n今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。\n## 基础模块 ##\n首先，我们先来简单的看一下整体的代码：\n```\n// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)\n(function() {\n\n  var root = this;\n  \n  // 保存当前环境中已经存在的_变量（在noConflict中用到）\n  var previousUnderscore = root._;\n  \n  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  var Ctor = function(){};\n  // 内部实现省略\n  var _ = function(obj) {};\n  \n    // 这里是各种方法的实现（省略）\n    \n  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n  \n  // 版本号\n  _.VERSION = '1.8.3';\n  \n  // 用amd的形式导出\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this))\n```\n<!-- more -->\n## 全局对象 ##\n这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：\n```\nvar root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this;\n```\n这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。\n\n## void(0) ? undefined ##\n扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？\n关于void的解释，我们可以看这里：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\nvoid 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。\n其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[\"ygy\"]、Object.\\__undefined\\__、Object.\\__ygy\\__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined\n\n## noConflict ##\n也许有时候我们会碰到这样一种情况，\\_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。\n```\n_.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n};\nvar underscore = _.noConflict();\n```\n显而易见，这里正常保留原来的\\_变量，并返回了underscore这个方法（this就是\\_方法）\n## \\_ ##\n接下来讲到了本文的重点，关于\\_方法的分析，在看源码之前，我们先熟悉一下\\_的用法。\n这里总结的是我日常的用法，如果有遗漏，希望大家补充。\n一种是直接调用\\_上的方法，比如\\_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如\\_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(\"body\").click()则是调用jQuery原型上的方法。\n\n既然\\_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。\n\n这里来看源码：\n```\n// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。\nvar _ = function(obj) {\n    // 如果obj是_的实例（这种情况我真的没碰到过）\n    if (obj instanceof _) return obj;\n    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）\n    if (!(this instanceof _)) return new _(obj);\n    // 对应_([1,2,3])这种情况\n    this._wrapped = obj;\n  };\n```\n我先从源码上来解释，这里可以看出来\\_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。\n```\nvar Person = function() {\n    this.name = \"ygy\";\n    this.age = 22;\n}\nPerson.say = function() {\n    console.log(\"hello\")\n}\nPerson.prototype.say = function() {\n    console.log(\"world\")\n}\nvar ygy = new Person();\nPerson.say(); // hello\nygy.say(); // world\n```\n所以我们平时用的\\_.map就是Person.say()这种用法，而\\_([1, 2, 3]).map则是ygy.say()这种用法。\n\n在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？\n\n首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针\\__proto\\__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：\n```\nvar ygy = {};\nygy.__proto__ = Person.prototype \n// 或者var ygy = Object.create(Person.prototype)\nPerson.call(ygy);\n```\n这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析\\_方法的源码：\n\\_接收一个对象作为参数，如果这个对象是\\_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）\n    \n如果this不是\\_的实例，那么就会返回一个新的实例new \\_(obj)，这个该怎么理解？\n我们需要结合例子来看这句话，在\\_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。\n    \n那么既然this指向window，那么this肯定不是\\_的实例，所以this instanceof \\_必然会返回false，这样的话就会return一个new \\_([1, 2, 3])，所以\\_([1, 2, 3])就是new \\_([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：\n```\nvar obj = {}\nobj.__proto__ = _.prototype\n// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用\n_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]\n```\n这样我们就理解了为什么\\_([1, 2, 3]).map中map是原型上的方法，因为\\_([1, 2, 3])是一个实例。\n\n我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：\n```\nvar _ = function(obj) {\n    return new _.prototype.init(obj)\n}\n_.prototype = {\n    init: function(obj) {\n    \tthis.__wrapped = obj\n    \treturn this\n    },\n    name: function(name) {\n        console.log(name)\n    }\n}\n_.prototype.init.prototype = _.prototype;\nvar a = _([1, 2, 3])\na.name(\"ygy\"); // ygy\n```\nunderscore中所有方法都是在\\_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。\n如果本文有错误和不足之处，希望大家指出。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之整体架构","published":1,"updated":"2018-11-22T11:48:40.429Z","_id":"cjosj7rz7003mfpzx7mdxxh5n","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。<br>本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。<br>今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。</p>\n<h2 id=\"基础模块\"><a href=\"#基础模块\" class=\"headerlink\" title=\"基础模块\"></a>基础模块</h2><p>首先，我们先来简单的看一下整体的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var root = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 保存当前环境中已经存在的_变量（在noConflict中用到）</span><br><span class=\"line\">  var previousUnderscore = root._;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩</span><br><span class=\"line\">  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    push             = ArrayProto.push,</span><br><span class=\"line\">    slice            = ArrayProto.slice,</span><br><span class=\"line\">    toString         = ObjProto.toString,</span><br><span class=\"line\">    hasOwnProperty   = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    nativeIsArray      = Array.isArray,</span><br><span class=\"line\">    nativeKeys         = Object.keys,</span><br><span class=\"line\">    nativeBind         = FuncProto.bind,</span><br><span class=\"line\">    nativeCreate       = Object.create;</span><br><span class=\"line\"></span><br><span class=\"line\">  var Ctor = function()&#123;&#125;;</span><br><span class=\"line\">  // 内部实现省略</span><br><span class=\"line\">  var _ = function(obj) &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 这里是各种方法的实现（省略）</span><br><span class=\"line\">    </span><br><span class=\"line\">  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量</span><br><span class=\"line\">  if (typeof exports !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class=\"line\">      exports = module.exports = _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    exports._ = _;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    root._ = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 版本号</span><br><span class=\"line\">  _.VERSION = &apos;1.8.3&apos;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用amd的形式导出</span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(&apos;underscore&apos;, [], function() &#123;</span><br><span class=\"line\">      return _;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"全局对象\"><a href=\"#全局对象\" class=\"headerlink\" title=\"全局对象\"></a>全局对象</h2><p>这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var root = typeof self == &apos;object&apos; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &apos;object&apos; &amp;&amp; global.global === global &amp;&amp; global || this;</span><br></pre></td></tr></table></figure></p>\n<p>这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。</p>\n<h2 id=\"void-0-undefined\"><a href=\"#void-0-undefined\" class=\"headerlink\" title=\"void(0) ? undefined\"></a>void(0) ? undefined</h2><p>扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？<br>关于void的解释，我们可以看这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void\" target=\"_blank\" rel=\"noopener\">MDN</a><br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。<br>其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[“ygy”]、Object.__undefined__、Object.__ygy__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined</p>\n<h2 id=\"noConflict\"><a href=\"#noConflict\" class=\"headerlink\" title=\"noConflict\"></a>noConflict</h2><p>也许有时候我们会碰到这样一种情况，_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = function() &#123;</span><br><span class=\"line\">    root._ = previousUnderscore;</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var underscore = _.noConflict();</span><br></pre></td></tr></table></figure></p>\n<p>显而易见，这里正常保留原来的_变量，并返回了underscore这个方法（this就是_方法）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"_\"></a>_</h2><p>接下来讲到了本文的重点，关于_方法的分析，在看源码之前，我们先熟悉一下_的用法。<br>这里总结的是我日常的用法，如果有遗漏，希望大家补充。<br>一种是直接调用_上的方法，比如_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(“body”).click()则是调用jQuery原型上的方法。</p>\n<p>既然_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。</p>\n<p>这里来看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</span><br><span class=\"line\">// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。</span><br><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    // 如果obj是_的实例（这种情况我真的没碰到过）</span><br><span class=\"line\">    if (obj instanceof _) return obj;</span><br><span class=\"line\">    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）</span><br><span class=\"line\">    if (!(this instanceof _)) return new _(obj);</span><br><span class=\"line\">    // 对应_([1,2,3])这种情况</span><br><span class=\"line\">    this._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我先从源码上来解释，这里可以看出来_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function() &#123;</span><br><span class=\"line\">    this.name = &quot;ygy&quot;;</span><br><span class=\"line\">    this.age = 22;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;world&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ygy = new Person();</span><br><span class=\"line\">Person.say(); // hello</span><br><span class=\"line\">ygy.say(); // world</span><br></pre></td></tr></table></figure></p>\n<p>所以我们平时用的_.map就是Person.say()这种用法，而_([1, 2, 3]).map则是ygy.say()这种用法。</p>\n<p>在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？</p>\n<p>首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针__proto__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ygy = &#123;&#125;;</span><br><span class=\"line\">ygy.__proto__ = Person.prototype </span><br><span class=\"line\">// 或者var ygy = Object.create(Person.prototype)</span><br><span class=\"line\">Person.call(ygy);</span><br></pre></td></tr></table></figure></p>\n<p>这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析_方法的源码：<br>_接收一个对象作为参数，如果这个对象是_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）</p>\n<p>如果this不是_的实例，那么就会返回一个新的实例new _(obj)，这个该怎么理解？<br>我们需要结合例子来看这句话，在_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。</p>\n<p>那么既然this指向window，那么this肯定不是_的实例，所以this instanceof _必然会返回false，这样的话就会return一个new _([1, 2, 3])，所以_([1, 2, 3])就是new _([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = _.prototype</span><br><span class=\"line\">// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用</span><br><span class=\"line\">_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就理解了为什么_([1, 2, 3]).map中map是原型上的方法，因为_([1, 2, 3])是一个实例。</p>\n<p>我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    return new _.prototype.init(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype = &#123;</span><br><span class=\"line\">    init: function(obj) &#123;</span><br><span class=\"line\">    \tthis.__wrapped = obj</span><br><span class=\"line\">    \treturn this</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: function(name) &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype.init.prototype = _.prototype;</span><br><span class=\"line\">var a = _([1, 2, 3])</span><br><span class=\"line\">a.name(&quot;ygy&quot;); // ygy</span><br></pre></td></tr></table></figure></p>\n<p>underscore中所有方法都是在_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。<br>如果本文有错误和不足之处，希望大家指出。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>最近打算好好看看underscore源码，一个是因为自己确实荒废了基础，另一个是underscore源码比较简单，比较易读。<br>本系列打算对underscore1.8.3中关键函数源码进行分析，希望做到最详细的源码分析。<br>今天是underscore源码剖析系列第一篇，主要对underscore整体架构和基础函数进行分析。</p>\n<h2 id=\"基础模块\"><a href=\"#基础模块\" class=\"headerlink\" title=\"基础模块\"></a>基础模块</h2><p>首先，我们先来简单的看一下整体的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是一个立即调用函数，使用call绑定了外层的this(全局对象)</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var root = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 保存当前环境中已经存在的_变量（在noConflict中用到）</span><br><span class=\"line\">  var previousUnderscore = root._;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用变量保存原生方法的引用，以防止这些方法被重写，也便于压缩</span><br><span class=\"line\">  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    push             = ArrayProto.push,</span><br><span class=\"line\">    slice            = ArrayProto.slice,</span><br><span class=\"line\">    toString         = ObjProto.toString,</span><br><span class=\"line\">    hasOwnProperty   = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  var</span><br><span class=\"line\">    nativeIsArray      = Array.isArray,</span><br><span class=\"line\">    nativeKeys         = Object.keys,</span><br><span class=\"line\">    nativeBind         = FuncProto.bind,</span><br><span class=\"line\">    nativeCreate       = Object.create;</span><br><span class=\"line\"></span><br><span class=\"line\">  var Ctor = function()&#123;&#125;;</span><br><span class=\"line\">  // 内部实现省略</span><br><span class=\"line\">  var _ = function(obj) &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 这里是各种方法的实现（省略）</span><br><span class=\"line\">    </span><br><span class=\"line\">  // 导出underscore方法，如果有exports则用exports导出，如果    没有，则将其设为全局变量</span><br><span class=\"line\">  if (typeof exports !== &apos;undefined&apos;) &#123;</span><br><span class=\"line\">    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class=\"line\">      exports = module.exports = _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    exports._ = _;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    root._ = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 版本号</span><br><span class=\"line\">  _.VERSION = &apos;1.8.3&apos;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 用amd的形式导出</span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(&apos;underscore&apos;, [], function() &#123;</span><br><span class=\"line\">      return _;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call(this))</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"全局对象\"><a href=\"#全局对象\" class=\"headerlink\" title=\"全局对象\"></a>全局对象</h2><p>这段代码整体比较简单，不过我看后来的underscore版本有一些小改动，主要是将var root = this;替换为下面这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var root = typeof self == &apos;object&apos; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &apos;object&apos; &amp;&amp; global.global === global &amp;&amp; global || this;</span><br></pre></td></tr></table></figure></p>\n<p>这里增加了对self和global的判断，self属性可以返回对窗口自身的引用，等价于window，这里主要是为了兼容web worker，因为web worker中是没有window的，global则是为了兼容node，而且在严格模式下，立即执行函数内部的this是undefined。</p>\n<h2 id=\"void-0-undefined\"><a href=\"#void-0-undefined\" class=\"headerlink\" title=\"void(0) ? undefined\"></a>void(0) ? undefined</h2><p>扫一眼源码，我们会发现在源码中并没有见到undefined的出现，反而是用void(0)或者void 0来代替的，那么这个void到底是什么？为什么不能直接用undefined呢？<br>关于void的解释，我们可以看这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void\" target=\"_blank\" rel=\"noopener\">MDN</a><br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)，因为undefined不是保留字，在低版本浏览器或者局部作用域中是可以被当做变量赋值的，这样就会导致我们拿不到正确的undefined值，在很多压缩工具中都是将undefined用void 0来代替掉了。<br>其实这里不仅是void 0可以拿到undefined，还有其他很多方法也可以拿到，比如0[“ygy”]、Object.__undefined__、Object.__ygy__，这些原理都是访问一个不存在的属性，所以最后一定会返回undefined</p>\n<h2 id=\"noConflict\"><a href=\"#noConflict\" class=\"headerlink\" title=\"noConflict\"></a>noConflict</h2><p>也许有时候我们会碰到这样一种情况，_已经被当做一个变量声明了，我们引入underscore后会覆盖这个变量，但是又不想这个变量被覆盖，还好underscore提供了noConflict这个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = function() &#123;</span><br><span class=\"line\">    root._ = previousUnderscore;</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var underscore = _.noConflict();</span><br></pre></td></tr></table></figure></p>\n<p>显而易见，这里正常保留原来的_变量，并返回了underscore这个方法（this就是_方法）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"_\"></a>_</h2><p>接下来讲到了本文的重点，关于_方法的分析，在看源码之前，我们先熟悉一下_的用法。<br>这里总结的是我日常的用法，如果有遗漏，希望大家补充。<br>一种是直接调用_上的方法，比如_.map([1, 2, 3])，另一种是通过实例访问原型上的方法，比如_([1, 2, 3]).map()，这里和jQuery的用法很像，\\$.extend调用jQuery对象上的方法，而\\$(“body”).click()则是调用jQuery原型上的方法。</p>\n<p>既然_可以使用原型上面的方法，那么说明执行_函数的时候肯定会返回一个实例。</p>\n<p>这里来看源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</span><br><span class=\"line\">// 我这里有个不够准确但容易理解的说法，就是检查一个对象是否为另一个构造函数的实例，为了更容易理解，下面将全部以XXX是XXX的实例的方式来说。</span><br><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    // 如果obj是_的实例（这种情况我真的没碰到过）</span><br><span class=\"line\">    if (obj instanceof _) return obj;</span><br><span class=\"line\">    // 如果this不是_构造函数的实例，那就以obj为参数 new一个实例（相等于修改了_函数）</span><br><span class=\"line\">    if (!(this instanceof _)) return new _(obj);</span><br><span class=\"line\">    // 对应_([1,2,3])这种情况</span><br><span class=\"line\">    this._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我先从源码上来解释，这里可以看出来_是一个构造函数，我们都知道，我既可以在构造函数上面增加方法，还可以在原型上面增加方法，前者只能通过构造函数本身访问到，后者由于原型链的存在，可以在构造函数的实例上面访问到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function() &#123;</span><br><span class=\"line\">    this.name = &quot;ygy&quot;;</span><br><span class=\"line\">    this.age = 22;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.say = function() &#123;</span><br><span class=\"line\">    console.log(&quot;world&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ygy = new Person();</span><br><span class=\"line\">Person.say(); // hello</span><br><span class=\"line\">ygy.say(); // world</span><br></pre></td></tr></table></figure></p>\n<p>所以我们平时用的_.map就是Person.say()这种用法，而_([1, 2, 3]).map则是ygy.say()这种用法。</p>\n<p>在继续讲这个之前，我们再来复习一下原型的知识，当我们new一个实例的时候到处发生了什么？</p>\n<p>首先，这里会先创建一个空对象，这个空对象继承了构造函数的原型（或者理解为空对象上增加一个指向构造函数原型的指针__proto__），之后会根据实例传入的参数执行一遍构造函数，将构造函数内部的this绑定到这个新对象中，最后返回这个对象，过程和如下类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ygy = &#123;&#125;;</span><br><span class=\"line\">ygy.__proto__ = Person.prototype </span><br><span class=\"line\">// 或者var ygy = Object.create(Person.prototype)</span><br><span class=\"line\">Person.call(ygy);</span><br></pre></td></tr></table></figure></p>\n<p>这样就很好理解了，要是想调用原型上面的方法，必须先new一个实例出来。我们再来分析_方法的源码：<br>_接收一个对象作为参数，如果这个对象是_的一个实例，那么直接返回这个对象。（这种情况我倒是没见过）</p>\n<p>如果this不是_的实例，那么就会返回一个新的实例new _(obj)，这个该怎么理解？<br>我们需要结合例子来看这句话，在_([1, 2, 3])中，obj肯定是指[1, 2, 3]这个数组，那么this是指什么呢？我觉得this是指window，不信你直接执行一下上面例子中的Person()？你会发现在全局作用域中是可以拿到name和age两个属性的。</p>\n<p>那么既然this指向window，那么this肯定不是_的实例，所以this instanceof _必然会返回false，这样的话就会return一个new _([1, 2, 3])，所以_([1, 2, 3])就是new _([1, 2, 3])，从我们前面对new的解释来看，这个过程表现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = _.prototype</span><br><span class=\"line\">// 此时_函数中this的是new _(obj)，this instanceof _是true，所以就不会重新return一个new _(obj)，这样避免了循环调用</span><br><span class=\"line\">_.call(obj) // 实际上做了这一步： obj._wrapped = [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就理解了为什么_([1, 2, 3]).map中map是原型上的方法，因为_([1, 2, 3])是一个实例。</p>\n<p>我这里再提供一个自己实现的_思路，和jQuery的实现类似，这里就不作解释了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var _ = function(obj) &#123;</span><br><span class=\"line\">    return new _.prototype.init(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype = &#123;</span><br><span class=\"line\">    init: function(obj) &#123;</span><br><span class=\"line\">    \tthis.__wrapped = obj</span><br><span class=\"line\">    \treturn this</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: function(name) &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_.prototype.init.prototype = _.prototype;</span><br><span class=\"line\">var a = _([1, 2, 3])</span><br><span class=\"line\">a.name(&quot;ygy&quot;); // ygy</span><br></pre></td></tr></table></figure></p>\n<p>underscore中所有方法都是在_方法上面直接挂载的，并且用mixin方法将这些方法再一次挂载到了原型上面。不过，由于篇幅有限，mixin方法的实现会在后文中给大家讲解。<br>如果本文有错误和不足之处，希望大家指出。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"毕业二三事","date":"2017-07-01T03:47:36.000Z","_content":"临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。\n21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。\n中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。\n\n下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。\n22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。\n<!-- more -->\n晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。\n23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。\n24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。\n25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。\n26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。\n\n27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。\n\n下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。\n\n28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我没有看着前面的路，而是看着上面的树枝，看着它们一个个的向我跑过来，那一瞬间我觉得好像时间就像树枝一样，正在远离我飞速逝去。\n\n晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。\n\n29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。\n\n30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/毕业二三事.md","raw":"---\ntitle: 毕业二三事\ndate: 2017-07-01 11:47:36\ntags:\n- 毕业\n- 生活\n- 随笔\ncategories: 生活\n---\n临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。\n21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。\n中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。\n\n下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。\n22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。\n<!-- more -->\n晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。\n23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。\n24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。\n25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。\n26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。\n\n27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。\n\n下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。\n\n28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我没有看着前面的路，而是看着上面的树枝，看着它们一个个的向我跑过来，那一瞬间我觉得好像时间就像树枝一样，正在远离我飞速逝去。\n\n晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。\n\n29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。\n\n30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。\n<head>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"毕业二三事","published":1,"updated":"2018-11-14T09:47:00.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7rz9003qfpzxb0txrnzz","content":"<p>临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。<br>21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。<br>中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。</p>\n<p>下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。<br>22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。<br><a id=\"more\"></a><br>晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。<br>23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。<br>24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。<br>25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。<br>26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。</p>\n<p>27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。</p>\n<p>下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。</p>\n<p>28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我没有看着前面的路，而是看着上面的树枝，看着它们一个个的向我跑过来，那一瞬间我觉得好像时间就像树枝一样，正在远离我飞速逝去。</p>\n<p>晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。</p>\n<p>29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。</p>\n<p>30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>临近离校的这几天发生了很多事情，不会煽情，就当作记流水账了吧。<br>21号早上9点学院的毕业典礼，大家排着队等上台，院长给我拨穗、合影，这也是我第一次和院长说话。<br>中午浩爷他们提议去吃金马门，于是大部队（晨阳、秦超、孙鹤岩、我们寝室四个、大兄弟、罗维、东哥、少颖、浩爷、伯董、廖锡浩、德旻、一拨猴、惠神等）浩浩荡荡的出发来到了金马门，这是大学四年来的第一次，也是最后一次，大家有说有笑，吃的很开心。</p>\n<p>下午我们去创意城玩桌游，玩的很开心，由于晚上译炜妈妈请吃饭，我5点就走了，一直在那里呆到6点多，译炜妈妈很热情，但是我不是很喜欢他们的氛围（可能因为我是学渣，就不是很喜欢别人在饭桌上讨论GPA和雅思托福等等），就借事离开去江南小观园参加班级聚会，很多人都喝了不少酒，军哥都喝吐了，聚会结束后，有人提议去ktv唱歌，我们就一边唱歌一边做游戏，最后他们点了《合照》，每人唱一句，大家真的都不想毕业不愿意离开啊。<br>22号上午学校毕业典礼，学校安排的很用心，大礼包很赞，在优秀毕业生里面看到了冉学霸和徐航，那瞬间突然觉得当个学霸也是挺好的吧，至少可以在全校人面前露面，院长又给我拨了一次穗，还问我昨天是不是也给你拨穗了，我说是啊哈哈哈哈，然后应小弟旻的要求帮他拍了一张和院长的合照，回来的路上我们在牌坊也拍了不少照片。<br>","more":"<br>晚上我们才反应过去今天是杰宝生日，我就和室友商量大家请他吃一顿饭吧，没想到美琪刚好从南京来了，我们三个和大兄弟就请他们两个吃饭，在肉蟹煲门口排队排了有1个小时，晚上10点才吃完饭，饭桌上我和翔总争辩真的很有趣，杰宝说你大一来的时候很羞涩，都不敢和人说话的，没想到现在嘴皮子这么厉害了，我说是啊。<br>23号我们办理离校手续，本来大兄弟23号就走，但是舍不得我们，就推迟到24号，为了送他，我和小松就强行召集人马去创意城玩了最后一次桌游，晚上我有老乡聚会不得不早点走，这也是最后一次老乡聚会了，因为是我组织的，我赶紧跑到了老熊家订好位置，等大家一个个到来，又见到了好久不见的艳楠姐，虽然她毕业一年了，但还和我们打成一片，差不多吃完饭的时候，我突然在空间看到美芝说最后一次梅操电影，我才意识到晚上梅操有电影，大家就陪我一起去梅操看了最后一次电影，电影是《速度与激情8》，晚上回寝室后我喊来了德旻和大兄弟，说我们合个照吧，于是冯玉乾帮我们拍了几张照片。<br>24号大兄弟走了，德旻也走了，我也不愿意在学校浪费自己的时间，我真的怕未来的自己埋怨现在的自己没有把握住最后几天，于是我喊上译炜拿上学士服在武大校园四处游荡，拍毕业照，我们在图书馆、校史馆、珞珈山都留下了身影，4点多的时候突然接到电话，小松明天就要走了，晚上给他送别，我5点多赶回寝室，和浩爷他们一起去聚贤阁送别小松，这次大概是我喝酒最多的一次了，也破例的喝了不少白酒，头很晕，小松走的时候和我们一一拥抱了一下，晚上回寝室的路上罗维和王者都在路边吐了半天，回到寝室就已经十一点多了。<br>25号大家基本都走了，寝室只有我和翔总了，我也不知道该做什么，也不想什么都不做让时间这么过去，中午我来到昙华林的猫的天空之城书店，给半年后的自己写了很长的一段话，表达了对未来的展望，猫空书店真的适合放松自己啊，在那里几乎看了一个下午书，因为空调实在太冷了233，我不得不离开了，回来后正好在信图发现了一个空座位，我赶紧预约了，吃完晚饭就赶了过去，我带着电脑在那里学习git用法，看着对面的妹纸，贪婪的听着闭馆音乐，我想，这种时光以后大概再也没有了。<br>26号大家走的更多了，这次我来到新图，这也是我看着我成长的地方，我还在新图门口买了两件文化衫，希望自己毕业后可以穿久一些，由于A5没有座位了（每次去图书馆我只坐新图A5和信图A4），我就在旁边站着继续学习git，站累了就坐下来，一直呆到了闭馆，对了，新图闭馆音乐是班得瑞的《月光海岸》，信图闭馆音乐是《one day in spring》，在新图门口正好看到毕业捐赠图书，我咨询了一下阿姨，阿姨表示连大英和高数都能捐，我很开心，我真的很爱图书馆，她看着我成长，每次都鼓励我，我一直想为她做点什么，晚上回来我从周围寝室和自己寝室收刮了一大堆书，打算明天捐给图书馆。</p>\n<p>27号早上我被闹钟吵醒，醒了后先在武大图书馆网站找一下信图的联系方式，但是却意外发现了小布的QQ号，我加了小布的QQ，向她表白，我们都挺感动的，之后我给信图打了电话，表达了我想捐书的意图，我把书都放到书包里面，将书给了信图，阿姨送了我一种纪念卡，回来的路上看着信操里面一个人都没有，早晨的校园很静谧，我走到星湖旁边坐了下来，看着周围来来往往的行人，一直坐到了中午，中午从食堂吃完饭回来的路上碰到了两个推广英语辅导班的妹纸，我说比较可惜我还有两天就彻底毕业了，妹纸说哇我感觉你看起来很萌就是大一的学生啊，居然已经大四了，祝你毕业快乐啊。</p>\n<p>下午我和郭崎一起去国软体育馆打羽毛球，正好看到国软健身房开门，里面有人在健身，郭崎说一天只要一块，我突然感觉好亏啊，在这里这么多年了，还没去过国软体育馆，然后和郭崎聊了很多关于上班和读研的问题，表达了自己想读研的想法，也得到了支持，打完球后我们去一食堂吃饭，回来后我在他寝室，正好廖龙飞也在，他就给我讲了大兄弟作为计算机协会社长，把自己协会弄没了的事情哈哈哈哈哈，原来大兄弟还有这种操作，晚上我们从大兄弟社团留下的东西里面找到了一堆台灯，台灯真的好可爱啊，好想送学妹，但是又没有喜欢的学妹，关系好的学妹只有思雨妹妹吧，我就送思雨妹妹了。</p>\n<p>28号还是和往常一样，早上睡到自然醒，打开笔记本看到自己还有很多目标没有实现，还没有吃遍武大食堂呢，就不顾炎热骑上小黄车跑到了工学部食堂吃了一顿午饭，中午真的很热，正好碰到放学的学弟学妹们，很羡慕他们还能继续在这么美丽的校园上课，吃完饭后我随便又从水生所那个门去了东湖，在东湖站了很久，后来想到四年还没有去过湖对岸的医学部呢，就开着地图去了医学部，去医学部的路很平坦，骑自行车真的是一种享受，在医学部随便走了走，医学部真的给我一种武大华科结合的感觉，华科的建筑，武大的校园布置，从医学部回来后我骑到凌波门，路上发现有人在湖边捉田螺，我下去看了看，发现居然好多河蚌啊，后悔没有早点发现，不然我可以在寝室煮着吃了，到了凌波门发现那里已经叫凌波门游泳池了，有人在那里拍毕业照，我也不记得自己的心情了，可能对毕业已经看的太淡了，之后就又从湖滨骑了回去，路过樱顶的时候，我没有看着前面的路，而是看着上面的树枝，看着它们一个个的向我跑过来，那一瞬间我觉得好像时间就像树枝一样，正在远离我飞速逝去。</p>\n<p>晚上和黎琳妹纸约了饭，她因为生病好久没有回来了，聚餐什么的也没参加，回来的时候大家基本都走了，第一次去酷多喜，除了贵点，其他方面还是挺好的，吃完饭后我赶紧跑到了图书馆，在图书馆随便看看代码，我对面正好是个很可爱漂亮的妹纸，很感慨自己就要这样走了，一直呆到了闭馆，最后用手机录下了闭馆音乐。</p>\n<p>29号早上也没有什么变化，起来后我开始收拾东西，因为明天就要走了，我把旧衣服整理了一下捐到了校门口，之后就很没出息的去打撸吃外卖了，晚上喊上东哥国臣他们一起去吃饭，遗憾的是冯玉乾和郭崎没有去，他们为了和廖龙飞一起（因为廖龙飞和我这边朋友不熟悉），吃完饭的时候杰宝和晨旸在楼上拥抱，哭的很厉害，我也不知道该怎么拉开他们，就喊来了大家，大家看着他们，店主给我们说当年我毕业的时候也是这样，大家把对方送到火车站，买站台票，你们这个时代很好啊，你们可以坐飞机高铁随时找对方，回来的时候我整理了所有东西，整理了很多很多，一直弄到12点多，等翔总打完dota，我们三个就在床上好好聊了聊，关于未来，聊着聊着我就睡着了。</p>\n<p>30号早上我第一个醒来，打开播放器听着《合照》，眼泪突然忍不住流了出来，我真的不想离开学校，怕被室友听到，我就跑到卫生间哭，哭完后装作什么都没发生回到位置上，翻翻以前的照片，这个时候杰宝醒了，他起来就去了405，过了一会儿晨旸也来我们寝室了，他要走了，杰宝把他送到了楼下，我也开始收拾收拾东西，因为马上就轮到我走了，这个时候我听到杰宝在床上哭，我去安慰他，我们以后还有机会见面，别哭了，他说我把你送走吧，我说好，他提着我的箱子把我送到了楼下，走的时候我们拥抱了一下，我拉着箱子离开寝室大楼，我回头看了看，他还在那里没走，我也挺难过的，走到二食堂的时候我拿手机拍了周围的环境和人，这大概是我最后一次看这里了，我的学生生活也就这样结束了。</p>\n<p><head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"},{"title":"管理自己","date":"2018-07-15T05:14:32.000Z","_content":"本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 \n\n我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 \n\n不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 \n\n历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。 \n<!-- more -->\n○ 我的长处是什么 \n\n多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 \n\n以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 \n\n要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 \n\n回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 \n\n我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 \n\n根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 \n\n其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 \n\n第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 \n\n另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 \n\n与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 \n\n把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 \n\n○ 我的工作方式是怎样的 \n\n令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 \n\n同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 \n\n我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 \n\n德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 \n\n艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 \n\n几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 \n\n没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 \n\n○ 我如何学习 \n\n要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 \n\n所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 \n\n像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 \n\n我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 \n\n在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 \n\n我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ \n\n有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” \n\n一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 \n\n另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 \n\n顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 \n\n其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 \n\n下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 \n\n○ 我的价值观是什么 \n\n要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 \n\n20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” \n\n这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 \n\n如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 \n\n让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 \n\n同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 \n\n至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 \n\n价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 \n\n这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” \n\n而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” \n\n组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 \n\n一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 \n\n如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 \n\n○ 我属于何处 \n\n少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 \n\n或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 \n\n同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” \n\n成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 \n\n○ 我该做出什么贡献 \n\n综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 \n\n随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 \n\n尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ \n\n请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 \n\n正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 \n\n○ 对人际关系负责 \n\n除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 \n\n首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 \n\n老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 \n\n这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 \n\n人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 \n\n这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 \n\n而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 \n\n如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 \n\n即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” \n\n如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” \n\n组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 \n\n○ 管理后半生 \n\n当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 \n\n我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 \n\n发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 \n\n还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 \n\n为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 \n\n最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 \n\n管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 \n\n管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 \n\n同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 \n\n发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 \n\n在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 \n\n自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 \n\n如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命","source":"_posts/管理自己.md","raw":"---\ntitle: 管理自己\ndate: 2018-07-15 13:14:32\ntags:\n    - 读书笔记\n    - 前端\ncategories:\n    - 转载\n---\n本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 \n\n我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 \n\n不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 \n\n历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。 \n<!-- more -->\n○ 我的长处是什么 \n\n多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 \n\n以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 \n\n要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 \n\n回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 \n\n我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 \n\n根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 \n\n其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 \n\n第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 \n\n另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 \n\n与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 \n\n把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 \n\n○ 我的工作方式是怎样的 \n\n令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 \n\n同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 \n\n我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 \n\n德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 \n\n艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 \n\n几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 \n\n没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 \n\n○ 我如何学习 \n\n要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 \n\n所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 \n\n像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 \n\n我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 \n\n在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 \n\n我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ \n\n有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” \n\n一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 \n\n另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 \n\n顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 \n\n其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 \n\n下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 \n\n○ 我的价值观是什么 \n\n要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 \n\n20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” \n\n这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 \n\n如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 \n\n让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 \n\n同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 \n\n至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 \n\n价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 \n\n这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” \n\n而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” \n\n组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 \n\n一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 \n\n如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 \n\n○ 我属于何处 \n\n少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 \n\n或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 \n\n同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” \n\n成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 \n\n○ 我该做出什么贡献 \n\n综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 \n\n随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 \n\n尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ \n\n请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 \n\n正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 \n\n○ 对人际关系负责 \n\n除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 \n\n首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 \n\n老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 \n\n这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 \n\n人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 \n\n这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 \n\n而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 \n\n如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 \n\n即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” \n\n如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” \n\n组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 \n\n○ 管理后半生 \n\n当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 \n\n我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 \n\n发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 \n\n还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 \n\n为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 \n\n最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 \n\n管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 \n\n管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 \n\n同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 \n\n发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 \n\n在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 \n\n自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 \n\n如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命","slug":"管理自己","published":1,"updated":"2018-11-22T11:29:31.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj7s2r004ifpzxid0x6hjq","content":"<p>本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 </p>\n<p>我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 </p>\n<p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 </p>\n<p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。<br><a id=\"more\"></a><br>○ 我的长处是什么 </p>\n<p>多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 </p>\n<p>以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 </p>\n<p>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 </p>\n<p>回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 </p>\n<p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 </p>\n<p>根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 </p>\n<p>其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 </p>\n<p>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 </p>\n<p>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 </p>\n<p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 </p>\n<p>把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 </p>\n<p>○ 我的工作方式是怎样的 </p>\n<p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 </p>\n<p>同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 </p>\n<p>我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 </p>\n<p>德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 </p>\n<p>艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 </p>\n<p>几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 </p>\n<p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 </p>\n<p>○ 我如何学习 </p>\n<p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 </p>\n<p>所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 </p>\n<p>像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 </p>\n<p>我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 </p>\n<p>在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 </p>\n<p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ </p>\n<p>有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” </p>\n<p>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 </p>\n<p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 </p>\n<p>顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 </p>\n<p>其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 </p>\n<p>下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 </p>\n<p>○ 我的价值观是什么 </p>\n<p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 </p>\n<p>20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” </p>\n<p>这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 </p>\n<p>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 </p>\n<p>让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 </p>\n<p>同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 </p>\n<p>至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 </p>\n<p>价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 </p>\n<p>这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” </p>\n<p>而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” </p>\n<p>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 </p>\n<p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 </p>\n<p>如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 </p>\n<p>○ 我属于何处 </p>\n<p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 </p>\n<p>或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 </p>\n<p>同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” </p>\n<p>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 </p>\n<p>○ 我该做出什么贡献 </p>\n<p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 </p>\n<p>随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 </p>\n<p>尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ </p>\n<p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 </p>\n<p>正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 </p>\n<p>○ 对人际关系负责 </p>\n<p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 </p>\n<p>首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 </p>\n<p>老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 </p>\n<p>这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 </p>\n<p>人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 </p>\n<p>这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 </p>\n<p>而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 </p>\n<p>如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 </p>\n<p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” </p>\n<p>如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” </p>\n<p>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 </p>\n<p>○ 管理后半生 </p>\n<p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 </p>\n<p>我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 </p>\n<p>发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 </p>\n<p>还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 </p>\n<p>为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 </p>\n<p>最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 </p>\n<p>管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 </p>\n<p>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 </p>\n<p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 </p>\n<p>发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 </p>\n<p>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 </p>\n<p>自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 </p>\n<p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命</p>\n","site":{"data":{}},"excerpt":"<p>本文是《哈佛商业评论》创刊以来重印次数最多的文章之一。作者彼得·德鲁克，自1971年后长期在美国加利福尼亚州克莱尔蒙特研究生大学任教。该文首次发表于1999年，节选自其著作《21世纪的管理挑战》（Management Challenges for the 21st Century，HarperCollins出版社，1999）。本文有删节。 </p>\n<p>我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 </p>\n<p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 </p>\n<p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。<br>","more":"<br>○ 我的长处是什么 </p>\n<p>多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。 </p>\n<p>以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 </p>\n<p>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 </p>\n<p>回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 </p>\n<p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 </p>\n<p>根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 </p>\n<p>其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 </p>\n<p>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 </p>\n<p>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 </p>\n<p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 </p>\n<p>把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 </p>\n<p>○ 我的工作方式是怎样的 </p>\n<p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 </p>\n<p>同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 </p>\n<p>我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 </p>\n<p>德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 </p>\n<p>艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 </p>\n<p>几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 </p>\n<p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 </p>\n<p>○ 我如何学习 </p>\n<p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 </p>\n<p>所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 </p>\n<p>像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 </p>\n<p>我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 </p>\n<p>在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 </p>\n<p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ </p>\n<p>有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” </p>\n<p>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。 </p>\n<p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 </p>\n<p>顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 </p>\n<p>其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。 </p>\n<p>下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 </p>\n<p>○ 我的价值观是什么 </p>\n<p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 </p>\n<p>20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。” </p>\n<p>这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 </p>\n<p>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 </p>\n<p>让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 </p>\n<p>同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 </p>\n<p>至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 </p>\n<p>价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 </p>\n<p>这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。” </p>\n<p>而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” </p>\n<p>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 </p>\n<p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 </p>\n<p>如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 </p>\n<p>○ 我属于何处 </p>\n<p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。 </p>\n<p>或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 </p>\n<p>同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” </p>\n<p>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 </p>\n<p>○ 我该做出什么贡献 </p>\n<p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。 </p>\n<p>随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 </p>\n<p>尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？ </p>\n<p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 </p>\n<p>正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力” （stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 </p>\n<p>○ 对人际关系负责 </p>\n<p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 </p>\n<p>首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 </p>\n<p>老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 </p>\n<p>这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 </p>\n<p>人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。 </p>\n<p>这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 </p>\n<p>而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 </p>\n<p>如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 </p>\n<p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” </p>\n<p>如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” </p>\n<p>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 </p>\n<p>○ 管理后半生 </p>\n<p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 </p>\n<p>我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 </p>\n<p>发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。 </p>\n<p>还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 </p>\n<p>为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 </p>\n<p>最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 </p>\n<p>管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 </p>\n<p>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 </p>\n<p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 </p>\n<p>发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 </p>\n<p>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 </p>\n<p>自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。 </p>\n<p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命</p>"},{"title":"TypeScript踩坑（持续更新）","date":"2018-11-22T11:26:05.000Z","_content":"\n## 配置\n### 为JS编写类型声明文件(d.ts)\n很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。\n\n我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。\n\n为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。\n类型声明文件：\n```\nimport BasePage from '../src/frame/BasePage'\ndeclare module \"../src/frame/BasePage\" {\n    export default class BasePage{}\n}\n```\n引入类型文件：\n```\n/// <reference path=\"../../../@types/BasePage.d.ts\" />\n```\n如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。\n<!-- more -->\n## 语法\n### 1. Element implicitly has an 'any' type because type 'Test' has no index signature\n```\nclass PageFlag {\n    updatePageFlag(name: string, value: boolean) {\n        this[name] = value;\n    }\n}\n```\n这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。\n\n#### (1) 修改tsconfig.json里的noImplicitAny为false。\n\n#### (2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\n\n```\n// 例2\ninterface IParams {\n    [propName: string]: any\n}\nclass PageFlag {\n    updatePageFlag = (name: string, value: boolean) => {\n        (<IParams>this)[name] = value\n    }\n}\n```\n\n#### (3) 手动列举所有属性\n虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。\n```\ntype pageFlag = \"showLoading\" | \"showMask\" | \"showCalendar\";\nclass PageFlag {\n    showLoading: boolean = false;\n    showMask: boolean = false;\n    showCalendar: boolean = false;\n    \n    updatePageFlag = (name: pageFlag, value: boolean) => {\n       this[name] = value\n    }\n}\n```\n## export from\n有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：\n```\n// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：\nexport Hotel from './Hotel'\nexport * as HotelList from './HotelList'\nexport Header from './Header'\n```\n但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！\n后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。\n![image.png-872kB][1]\n但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。\n```\nexport {default as Hotel} from './Hotel'\nexport {default as HotelList} from './HotelList'\nexport {default as Header} from './Header'\n```\n顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。\n```\nexport { Hotel } from './Hotel'\nexport * from './Hotel\n```\n\n  [1]: https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex","source":"_posts/TypeScript踩坑（持续更新）.md","raw":"---\ntitle: TypeScript踩坑（持续更新）\ndate: 2018-11-22 19:26:05\ncategories:\n    - TypeScript\ntags:\n    - TypeScript\n    - 前端\n---\n\n## 配置\n### 为JS编写类型声明文件(d.ts)\n很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。\n\n我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。\n\n为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。\n类型声明文件：\n```\nimport BasePage from '../src/frame/BasePage'\ndeclare module \"../src/frame/BasePage\" {\n    export default class BasePage{}\n}\n```\n引入类型文件：\n```\n/// <reference path=\"../../../@types/BasePage.d.ts\" />\n```\n如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。\n<!-- more -->\n## 语法\n### 1. Element implicitly has an 'any' type because type 'Test' has no index signature\n```\nclass PageFlag {\n    updatePageFlag(name: string, value: boolean) {\n        this[name] = value;\n    }\n}\n```\n这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。\n\n#### (1) 修改tsconfig.json里的noImplicitAny为false。\n\n#### (2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\n\n```\n// 例2\ninterface IParams {\n    [propName: string]: any\n}\nclass PageFlag {\n    updatePageFlag = (name: string, value: boolean) => {\n        (<IParams>this)[name] = value\n    }\n}\n```\n\n#### (3) 手动列举所有属性\n虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。\n```\ntype pageFlag = \"showLoading\" | \"showMask\" | \"showCalendar\";\nclass PageFlag {\n    showLoading: boolean = false;\n    showMask: boolean = false;\n    showCalendar: boolean = false;\n    \n    updatePageFlag = (name: pageFlag, value: boolean) => {\n       this[name] = value\n    }\n}\n```\n## export from\n有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：\n```\n// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：\nexport Hotel from './Hotel'\nexport * as HotelList from './HotelList'\nexport Header from './Header'\n```\n但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！\n后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。\n![image.png-872kB][1]\n但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。\n```\nexport {default as Hotel} from './Hotel'\nexport {default as HotelList} from './HotelList'\nexport {default as Header} from './Header'\n```\n顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。\n```\nexport { Hotel } from './Hotel'\nexport * from './Hotel\n```\n\n  [1]: https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex","slug":"TypeScript踩坑（持续更新）","published":1,"updated":"2018-11-22T11:52:09.336Z","_id":"cjosj8gqk0000fszx2mc5pze2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"为JS编写类型声明文件-d-ts\"><a href=\"#为JS编写类型声明文件-d-ts\" class=\"headerlink\" title=\"为JS编写类型声明文件(d.ts)\"></a>为JS编写类型声明文件(d.ts)</h3><p>很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。</p>\n<p>我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。</p>\n<p>为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。<br>类型声明文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import BasePage from &apos;../src/frame/BasePage&apos;</span><br><span class=\"line\">declare module &quot;../src/frame/BasePage&quot; &#123;</span><br><span class=\"line\">    export default class BasePage&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引入类型文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;../../../@types/BasePage.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。<br><a id=\"more\"></a></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\"><a href=\"#1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\" class=\"headerlink\" title=\"1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature\"></a>1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag(name: string, value: boolean) &#123;</span><br><span class=\"line\">        this[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。</p>\n<h4 id=\"1-修改tsconfig-json里的noImplicitAny为false。\"><a href=\"#1-修改tsconfig-json里的noImplicitAny为false。\" class=\"headerlink\" title=\"(1) 修改tsconfig.json里的noImplicitAny为false。\"></a>(1) 修改tsconfig.json里的noImplicitAny为false。</h4><h4 id=\"2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"><a href=\"#2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\" class=\"headerlink\" title=\"(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"></a>(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例2</span><br><span class=\"line\">interface IParams &#123;</span><br><span class=\"line\">    [propName: string]: any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag = (name: string, value: boolean) =&gt; &#123;</span><br><span class=\"line\">        (&lt;IParams&gt;this)[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-手动列举所有属性\"><a href=\"#3-手动列举所有属性\" class=\"headerlink\" title=\"(3) 手动列举所有属性\"></a>(3) 手动列举所有属性</h4><p>虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type pageFlag = &quot;showLoading&quot; | &quot;showMask&quot; | &quot;showCalendar&quot;;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    showLoading: boolean = false;</span><br><span class=\"line\">    showMask: boolean = false;</span><br><span class=\"line\">    showCalendar: boolean = false;</span><br><span class=\"line\">    </span><br><span class=\"line\">    updatePageFlag = (name: pageFlag, value: boolean) =&gt; &#123;</span><br><span class=\"line\">       this[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"export-from\"><a href=\"#export-from\" class=\"headerlink\" title=\"export from\"></a>export from</h2><p>有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：</span><br><span class=\"line\">export Hotel from &apos;./Hotel&apos;</span><br><span class=\"line\">export * as HotelList from &apos;./HotelList&apos;</span><br><span class=\"line\">export Header from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！<br>后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。<br><img src=\"https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex\" alt=\"image.png-872kB\"><br>但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;default as Hotel&#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export &#123;default as HotelList&#125; from &apos;./HotelList&apos;</span><br><span class=\"line\">export &#123;default as Header&#125; from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; Hotel &#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export * from &apos;./Hotel</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"为JS编写类型声明文件-d-ts\"><a href=\"#为JS编写类型声明文件-d-ts\" class=\"headerlink\" title=\"为JS编写类型声明文件(d.ts)\"></a>为JS编写类型声明文件(d.ts)</h3><p>很多第三方库已经有自己的类型声明文件，比如@types/react，@types/react-native，这些需要单独安装，而例如mobx-react和mobx这种会自带类型文件，不需要单独安装。</p>\n<p>我们最近有个新项目，需要照顾到不同同学，有的愿意用TS，有的不想用TS，为了照顾到双方，所有的公共模块都是JS写的，所以需要单独为TS写类型声明文件，具体语法请参考TS官网的文档，这里只是讲一些坑。</p>\n<p>为项目中的JS写类型文件的时候，需要先引入对应的文件，然后以导入的路径为名字声明一个模块，最后在需要用到这个类型文件的地方用///来引入相对路径。<br>类型声明文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import BasePage from &apos;../src/frame/BasePage&apos;</span><br><span class=\"line\">declare module &quot;../src/frame/BasePage&quot; &#123;</span><br><span class=\"line\">    export default class BasePage&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引入类型文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;../../../@types/BasePage.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果是想设置全局的类型文件，可以在tsconfig.json的paths字段里面指定对应的路径，这样就不需要单独用reference引入了。<br>","more":"</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\"><a href=\"#1-Element-implicitly-has-an-‘any’-type-because-type-‘Test’-has-no-index-signature\" class=\"headerlink\" title=\"1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature\"></a>1. Element implicitly has an ‘any’ type because type ‘Test’ has no index signature</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag(name: string, value: boolean) &#123;</span><br><span class=\"line\">        this[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够更新PageFlag中的数据，但是又不想对所有的属性一一列举出来，但是由于没有设置this[name]的类型，导致了报错，这里有几种解决办法。</p>\n<h4 id=\"1-修改tsconfig-json里的noImplicitAny为false。\"><a href=\"#1-修改tsconfig-json里的noImplicitAny为false。\" class=\"headerlink\" title=\"(1) 修改tsconfig.json里的noImplicitAny为false。\"></a>(1) 修改tsconfig.json里的noImplicitAny为false。</h4><h4 id=\"2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"><a href=\"#2-给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\" class=\"headerlink\" title=\"(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：\"></a>(2) 给this设置类型，但是不好的地方就是失去了类型判断的意义，如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例2</span><br><span class=\"line\">interface IParams &#123;</span><br><span class=\"line\">    [propName: string]: any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    updatePageFlag = (name: string, value: boolean) =&gt; &#123;</span><br><span class=\"line\">        (&lt;IParams&gt;this)[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-手动列举所有属性\"><a href=\"#3-手动列举所有属性\" class=\"headerlink\" title=\"(3) 手动列举所有属性\"></a>(3) 手动列举所有属性</h4><p>虽然这样比较麻烦，但是一眼就能看出来PageFlag有哪些属性，数据比较清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type pageFlag = &quot;showLoading&quot; | &quot;showMask&quot; | &quot;showCalendar&quot;;</span><br><span class=\"line\">class PageFlag &#123;</span><br><span class=\"line\">    showLoading: boolean = false;</span><br><span class=\"line\">    showMask: boolean = false;</span><br><span class=\"line\">    showCalendar: boolean = false;</span><br><span class=\"line\">    </span><br><span class=\"line\">    updatePageFlag = (name: pageFlag, value: boolean) =&gt; &#123;</span><br><span class=\"line\">       this[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"export-from\"><a href=\"#export-from\" class=\"headerlink\" title=\"export from\"></a>export from</h2><p>有些文件夹下面有很多文件，所以我喜欢增加一个index.ts文件来直接export from其他文件，这样在其他地方引入的时候可以直接import from目录，类似如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 我们有个components文件夹，下面有很多组件文件（都是export default导出的），我们可以components下创建index.ts文件，里面这么写（下）：</span><br><span class=\"line\">export Hotel from &apos;./Hotel&apos;</span><br><span class=\"line\">export * as HotelList from &apos;./HotelList&apos;</span><br><span class=\"line\">export Header from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种export from的方式在TS里面都会编译报错，可是我在ES6里面明明写的好好的啊！！！<br>后来在google上找到了一个链接，原来这两种export from的方式都只是提案，如果在ES6中则需要额外添加@babel/plugin-proposal-export-namespace-from 插件来支持，TS中不支持这些写法。<br><img src=\"https://image-static.segmentfault.com/387/530/3875307783-5bf6970920056_articlex\" alt=\"image.png-872kB\"><br>但是感觉这个更像野路子，也许未来会支持，遂放弃，最后发现了另外一种写法，可以完美解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;default as Hotel&#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export &#123;default as HotelList&#125; from &apos;./HotelList&apos;</span><br><span class=\"line\">export &#123;default as Header&#125; from &apos;./Header&apos;</span><br></pre></td></tr></table></figure></p>\n<p>顺便说一下，export from其实还有下面两种写法，但是这两种写法都是需要模块export导出，而不是export default导出的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; Hotel &#125; from &apos;./Hotel&apos;</span><br><span class=\"line\">export * from &apos;./Hotel</span><br></pre></td></tr></table></figure></p>"},{"title":"react状态管理","date":"2018-10-05T09:47:30.000Z","_content":"react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。\n\n## 全局state\n如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。\n\n## redux\nredux是我们公司老项目中最常用的状态库，redux遵守dispatch -> action -> reducer -> store -> view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。\n\n## relite\nrelite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。\n\n## mobx\nmobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。\nmobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。\n\n如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。\n\n","source":"_posts/react状态管理.md","raw":"---\ntitle: react状态管理\ndate: 2018-10-05 17:47:30\ncategories:\n    - react\ntags:\n    - redux\n    - react\n    - 前端\n---\nreact作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。\n\n## 全局state\n如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。\n\n## redux\nredux是我们公司老项目中最常用的状态库，redux遵守dispatch -> action -> reducer -> store -> view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。\n\n## relite\nrelite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。\n\n## mobx\nmobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。\nmobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。\n\n如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。\n\n","slug":"react状态管理","published":1,"updated":"2018-11-22T11:48:14.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj9bwz0006fszx8205cajg","content":"<p>react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。</p>\n<h2 id=\"全局state\"><a href=\"#全局state\" class=\"headerlink\" title=\"全局state\"></a>全局state</h2><p>如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。</p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><p>redux是我们公司老项目中最常用的状态库，redux遵守dispatch -&gt; action -&gt; reducer -&gt; store -&gt; view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。</p>\n<h2 id=\"relite\"><a href=\"#relite\" class=\"headerlink\" title=\"relite\"></a>relite</h2><p>relite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。</p>\n<h2 id=\"mobx\"><a href=\"#mobx\" class=\"headerlink\" title=\"mobx\"></a>mobx</h2><p>mobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。<br>mobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。</p>\n<p>如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>react作为现今最火热的界面库，很多项目都采用了react构建界面，但是react自身也有许多不足，比如状态管理和组件通信等等，随着项目越来越大，只靠react很难满足需求，所以很多状态管理库由此诞生。</p>\n<h2 id=\"全局state\"><a href=\"#全局state\" class=\"headerlink\" title=\"全局state\"></a>全局state</h2><p>如果是比较小的个人项目，完全可以不使用任何状态库，可以在容器（顶层）组件里面使用一个类似redux store的大state，将这个state通过props和context传给子组件，可以将setState方法从容器组件传下去，或者将子组件的修改state方法放到容器组件中，这样就可以轻松实现状态管理。</p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><p>redux是我们公司老项目中最常用的状态库，redux遵守dispatch -&gt; action -&gt; reducer -&gt; store -&gt; view的一套操作流程，好处是状态可预测，数据流动更加清晰，组件之间通信也更加方便，缺点就是需要在多个文件里面写很多action和reducer，在小项目中就会得不偿失，但是在大型项目中有利于以后维护。</p>\n<h2 id=\"relite\"><a href=\"#relite\" class=\"headerlink\" title=\"relite\"></a>relite</h2><p>relite是我们部门的工业聚大神写的一个类redux库，总体思想和redux一致，区别只是在于写法上的不同，relite中剔除了reducer的概念，将action和reducer合一，以原来的action.type来命名reducer函数，每个函数最终都会返回整个store，这样无需写一串长长的switch case语句，但也带来了一系列问题，比如由于返回整个store，这样很难和细粒度的PureComponent一起使用，底层性能优化也比不上react-redux。</p>\n<h2 id=\"mobx\"><a href=\"#mobx\" class=\"headerlink\" title=\"mobx\"></a>mobx</h2><p>mobx是我们打算在下期项目中使用的状态管理库，目前还没有使用经验，不过看过了文档，已经有了一些了解。<br>mobx和flux走了完全不同的一条路，mobx更偏向vue等响应式库，通过getter、setter来实现对数据的监听，而mobx-react会提供observer方法来给组件订阅数据的变化，这样带来的好处就是可以做到更细粒度的控制组件渲染，这样会带来更高效的性能，可以做到只渲染子组件而不渲染父组件，这在react和redux里面是无法做到的。</p>\n<p>如果是小型项目，也许你不需要使用状态管理库，如果操作不好，那么可以考虑一下relite，如果是中型项目，可以考虑使用mobx，如果是大型项目，那么建议使用redux。</p>\n"},{"title":"redux源码分析","date":"2018-07-25T15:46:14.000Z","_content":"前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。\n<!-- more -->\n## createStore\nredux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。\n\n![redux入口.png-41.8kB][1]\n\n从返回参数来看，createStore函数主要返回了这四个我们常用的函数。\n![createStore.png-251.1kB][2]\n\n进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。\n## combineReducers\n删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：\n![combineReducers.png-309.2kB][3]\n\n参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。\n这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。\n这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。\n并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。\n## applyMiddleware\nMiddleware这个概念是Redux从其他框架借鉴过来的，本意如下：\n\n> middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware\n> 可以完成添加 CORS headers、记录日志、内容压缩等工作。\n\n而在Redux中：\n\n> middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer\n> 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。\n\n看完了combineReducers函数，我们继续分析applyMiddleware函数：\n\n![applyMi.png-172kB][4]\n\napplyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。\nredux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。\n## compose\n![compose.png-80.9kB][5]\n\n这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。\n## dispatch\n再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：\n![dispatch.png-152.4kB][6]\n首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。\ndispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。\n## subscribe\n这里我们看一下subscribe函数：\n![subscribe.png-128kB][7]\n\nsubscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。\n这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。\n## 重写\n这里是自己重写的简练版redux：\n```\n/// 这里需要对参数为0或1的情况进行判断\nconst compose = (...funcs) => {\n    if (!funcs) {\n        return args => args\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((f1, f2) => (...args) => f1(f2(...args)))\n}\n\nconst bindActionCreator = (action, dispatch) => {\n    return (...args) => dispatch(action(...args))\n}\n\nconst createStore = (reducer, initState, enhancer) => {\n    if (!enhancer && typeof initState === \"function\") {\n        enhancer = initState\n        initState = null\n    }\n    if (enhancer && typeof enhancer === \"function\") {\n        return enhancer(createStore)(reducer, initState)\n    }\n    let store = initState, \n        listeners = [],\n        isDispatch = false;\n    const getState = () => store\n    const dispatch = (action) => {\n        if (isDispatch) return action\n        // dispatch必须一个个来\n        isDispatch = true\n        store = reducer(store, action)\n        isDispatch = false\n        listeners.forEach(listener => listener())\n        return action\n    }\n    const subscribe = (listener) => {\n        if (typeof listener === \"function\") {\n            listeners.push(listener)\n        }\n        return () => unsubscribe(listener)\n    }\n    const unsubscribe = (listener) => {\n        const index = listeners.indexOf(listener)\n        listeners.splice(index, 1)\n    }\n    return {\n        getState,\n        dispatch,\n        subscribe,\n        unsubscribe\n    }\n}\n\nconst applyMiddleware = (...middlewares) => {\n    return (createStore) => (reducer, initState, enhancer) => {\n        const store = createStore(reducer, initState, enhancer)\n        let chain = middlewares.map(middleware => middleware(store))\n        store.dispatch = compose(...chain)(store.dispatch)\n        return {\n          ...store\n        }\n      }\n}\n\nconst combineReducers = reducers => {\n    const finalReducers = {},\n        nativeKeys = Object.keys\n    nativeKeys(reducers).forEach(reducerKey => {\n        if(typeof reducers[reducerKey] === \"function\") {\n            finalReducers[reducerKey] = reducers[reducerKey]\n        }\n    })\n    return (state, action) => {\n        const store = {}\n        nativeKeys(finalReducers).forEach(key => {\n            const reducer = finalReducers[key]\n            const nextState = reducer(state[key], action)\n            store[key] = nextState\n        })\n        return store\n    }\n}\n```\n## 总结\nredux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。\n  [1]: http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\n  [2]: http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\n  [3]: http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\n  [4]: http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\n  [5]: http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\n  [6]: http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\n  [7]: http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png","source":"_posts/redux源码分析.md","raw":"---\ntitle: redux源码分析\ndate: 2018-07-25 23:46:14\ncategories:\n    - react\ntags:\n    - redux\n    - react\n    - 前端\n---\n前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。\n<!-- more -->\n## createStore\nredux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。\n\n![redux入口.png-41.8kB][1]\n\n从返回参数来看，createStore函数主要返回了这四个我们常用的函数。\n![createStore.png-251.1kB][2]\n\n进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。\n## combineReducers\n删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：\n![combineReducers.png-309.2kB][3]\n\n参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。\n这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。\n这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。\n并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。\n## applyMiddleware\nMiddleware这个概念是Redux从其他框架借鉴过来的，本意如下：\n\n> middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware\n> 可以完成添加 CORS headers、记录日志、内容压缩等工作。\n\n而在Redux中：\n\n> middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer\n> 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。\n\n看完了combineReducers函数，我们继续分析applyMiddleware函数：\n\n![applyMi.png-172kB][4]\n\napplyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。\nredux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。\n## compose\n![compose.png-80.9kB][5]\n\n这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。\n## dispatch\n再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：\n![dispatch.png-152.4kB][6]\n首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。\ndispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。\n## subscribe\n这里我们看一下subscribe函数：\n![subscribe.png-128kB][7]\n\nsubscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。\n这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。\n## 重写\n这里是自己重写的简练版redux：\n```\n/// 这里需要对参数为0或1的情况进行判断\nconst compose = (...funcs) => {\n    if (!funcs) {\n        return args => args\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((f1, f2) => (...args) => f1(f2(...args)))\n}\n\nconst bindActionCreator = (action, dispatch) => {\n    return (...args) => dispatch(action(...args))\n}\n\nconst createStore = (reducer, initState, enhancer) => {\n    if (!enhancer && typeof initState === \"function\") {\n        enhancer = initState\n        initState = null\n    }\n    if (enhancer && typeof enhancer === \"function\") {\n        return enhancer(createStore)(reducer, initState)\n    }\n    let store = initState, \n        listeners = [],\n        isDispatch = false;\n    const getState = () => store\n    const dispatch = (action) => {\n        if (isDispatch) return action\n        // dispatch必须一个个来\n        isDispatch = true\n        store = reducer(store, action)\n        isDispatch = false\n        listeners.forEach(listener => listener())\n        return action\n    }\n    const subscribe = (listener) => {\n        if (typeof listener === \"function\") {\n            listeners.push(listener)\n        }\n        return () => unsubscribe(listener)\n    }\n    const unsubscribe = (listener) => {\n        const index = listeners.indexOf(listener)\n        listeners.splice(index, 1)\n    }\n    return {\n        getState,\n        dispatch,\n        subscribe,\n        unsubscribe\n    }\n}\n\nconst applyMiddleware = (...middlewares) => {\n    return (createStore) => (reducer, initState, enhancer) => {\n        const store = createStore(reducer, initState, enhancer)\n        let chain = middlewares.map(middleware => middleware(store))\n        store.dispatch = compose(...chain)(store.dispatch)\n        return {\n          ...store\n        }\n      }\n}\n\nconst combineReducers = reducers => {\n    const finalReducers = {},\n        nativeKeys = Object.keys\n    nativeKeys(reducers).forEach(reducerKey => {\n        if(typeof reducers[reducerKey] === \"function\") {\n            finalReducers[reducerKey] = reducers[reducerKey]\n        }\n    })\n    return (state, action) => {\n        const store = {}\n        nativeKeys(finalReducers).forEach(key => {\n            const reducer = finalReducers[key]\n            const nextState = reducer(state[key], action)\n            store[key] = nextState\n        })\n        return store\n    }\n}\n```\n## 总结\nredux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。\n  [1]: http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\n  [2]: http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\n  [3]: http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\n  [4]: http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\n  [5]: http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\n  [6]: http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\n  [7]: http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png","slug":"redux源码分析","published":1,"updated":"2018-11-22T11:48:17.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj9edm000efszx8prwn66i","content":"<p>前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。<br><a id=\"more\"></a></p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>redux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。</p>\n<p>![redux入口.png-41.8kB][1]</p>\n<p>从返回参数来看，createStore函数主要返回了这四个我们常用的函数。<br>![createStore.png-251.1kB][2]</p>\n<p>进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：<br>![combineReducers.png-309.2kB][3]</p>\n<p>参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。<br>这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。<br>这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。<br>并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>Middleware这个概念是Redux从其他框架借鉴过来的，本意如下：</p>\n<blockquote>\n<p>middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware<br>可以完成添加 CORS headers、记录日志、内容压缩等工作。</p>\n</blockquote>\n<p>而在Redux中：</p>\n<blockquote>\n<p>middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer<br>之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>\n</blockquote>\n<p>看完了combineReducers函数，我们继续分析applyMiddleware函数：</p>\n<p>![applyMi.png-172kB][4]</p>\n<p>applyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。<br>redux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p>![compose.png-80.9kB][5]</p>\n<p>这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。</p>\n<h2 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h2><p>再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：<br>![dispatch.png-152.4kB][6]<br>首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。<br>dispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。</p>\n<h2 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h2><p>这里我们看一下subscribe函数：<br>![subscribe.png-128kB][7]</p>\n<p>subscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。<br>这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。</p>\n<h2 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h2><p>这里是自己重写的简练版redux：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 这里需要对参数为0或1的情况进行判断</span><br><span class=\"line\">const compose = (...funcs) =&gt; &#123;</span><br><span class=\"line\">    if (!funcs) &#123;</span><br><span class=\"line\">        return args =&gt; args</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (funcs.length === 1) &#123;</span><br><span class=\"line\">        return funcs[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return funcs.reduce((f1, f2) =&gt; (...args) =&gt; f1(f2(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bindActionCreator = (action, dispatch) =&gt; &#123;</span><br><span class=\"line\">    return (...args) =&gt; dispatch(action(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const createStore = (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    if (!enhancer &amp;&amp; typeof initState === &quot;function&quot;) &#123;</span><br><span class=\"line\">        enhancer = initState</span><br><span class=\"line\">        initState = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (enhancer &amp;&amp; typeof enhancer === &quot;function&quot;) &#123;</span><br><span class=\"line\">        return enhancer(createStore)(reducer, initState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let store = initState, </span><br><span class=\"line\">        listeners = [],</span><br><span class=\"line\">        isDispatch = false;</span><br><span class=\"line\">    const getState = () =&gt; store</span><br><span class=\"line\">    const dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">        if (isDispatch) return action</span><br><span class=\"line\">        // dispatch必须一个个来</span><br><span class=\"line\">        isDispatch = true</span><br><span class=\"line\">        store = reducer(store, action)</span><br><span class=\"line\">        isDispatch = false</span><br><span class=\"line\">        listeners.forEach(listener =&gt; listener())</span><br><span class=\"line\">        return action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        if (typeof listener === &quot;function&quot;) &#123;</span><br><span class=\"line\">            listeners.push(listener)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return () =&gt; unsubscribe(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const unsubscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        const index = listeners.indexOf(listener)</span><br><span class=\"line\">        listeners.splice(index, 1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        getState,</span><br><span class=\"line\">        dispatch,</span><br><span class=\"line\">        subscribe,</span><br><span class=\"line\">        unsubscribe</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const applyMiddleware = (...middlewares) =&gt; &#123;</span><br><span class=\"line\">    return (createStore) =&gt; (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">        const store = createStore(reducer, initState, enhancer)</span><br><span class=\"line\">        let chain = middlewares.map(middleware =&gt; middleware(store))</span><br><span class=\"line\">        store.dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">          ...store</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const combineReducers = reducers =&gt; &#123;</span><br><span class=\"line\">    const finalReducers = &#123;&#125;,</span><br><span class=\"line\">        nativeKeys = Object.keys</span><br><span class=\"line\">    nativeKeys(reducers).forEach(reducerKey =&gt; &#123;</span><br><span class=\"line\">        if(typeof reducers[reducerKey] === &quot;function&quot;) &#123;</span><br><span class=\"line\">            finalReducers[reducerKey] = reducers[reducerKey]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return (state, action) =&gt; &#123;</span><br><span class=\"line\">        const store = &#123;&#125;</span><br><span class=\"line\">        nativeKeys(finalReducers).forEach(key =&gt; &#123;</span><br><span class=\"line\">            const reducer = finalReducers[key]</span><br><span class=\"line\">            const nextState = reducer(state[key], action)</span><br><span class=\"line\">            store[key] = nextState</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。<br>  [1]: <a href=\"http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png</a><br>  [2]: <a href=\"http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png</a><br>  [3]: <a href=\"http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png</a><br>  [4]: <a href=\"http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png</a><br>  [5]: <a href=\"http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png</a><br>  [6]: <a href=\"http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png</a><br>  [7]: <a href=\"http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png</a></p>\n","site":{"data":{}},"excerpt":"<p>前几天和小伙伴讨论一个问题，就是在reducer方法里面拿到state后，如果直接对state对象做修改，但是还没有return出来，到这一步的时候会不会已经修改了store里的数据，我当时觉得应该不会，但是实在也想不明白，如果不做深拷贝，那还有其他办法能避免修改原始数据吗？但是redux中又不可能对数据进行深拷贝，这样做的代价太大了，于是带着一点好奇心，研究了一下redux源码。<br>","more":"</p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>redux源码还是比想象中的要精炼很多的，除去注释和打印错误信息，核心代码大概在两三百行左右，我们就先从createStore这个入口函数一探究竟。</p>\n<p>![redux入口.png-41.8kB][1]</p>\n<p>从返回参数来看，createStore函数主要返回了这四个我们常用的函数。<br>![createStore.png-251.1kB][2]</p>\n<p>进入到create函数里面看，第一个判断应该是当用户没有给初始化的数据，直接将enhancer函数（一般是applyMiddleware）当第二个参数传进来的时候做的一些默认处理，如果enhancer是一个函数，那么就会把reducer和preloadedState传给enhancer，我们知道enhancer一般是一些中间件函数，这里的reducer一般是combineReducers这个函数的返回值，我们再来看看combineReducers和applyMiddleware这两个函数。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>删除掉多余的注释和打印信息后，完整的combineReducers函数是这样的：<br>![combineReducers.png-309.2kB][3]</p>\n<p>参数reducers就是我们最后传给combineReducers的那个对象，一般是我们reducer函数的对象集合。<br>这里代码也很清晰了，将reducer函数以键值对的形式赋给finalReducers对象，并且返回一个combination函数，这个函数可以拿到当前的状态和要执行的action，这两个参数肯定是在createStore里面调用的时候传入的，我们先不用管。<br>这里使用for循环来遍历每一个reducer函数，这也就意味着，我们每次触发一个action，redux都会遍历并执行一遍所有的reducer函数，直到找到匹配的那个action.type（这里我不得不说react-imvc应该是做了一些优化的，它以action.type作为reducer函数名，这样就不需要去遍历查找了，可以减少很多不必要的工作量）。<br>并且将执行后的结果nextStateForKey和前一个状态做比较，最后根据判断是return新值还是老值，这也是为什么在reducer函数里面最后一定要return出来一个新的对象or数组才会刷新store，而不能简单的修改一下当前的state，并将其直接返回，因为这里比较的是引用。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>Middleware这个概念是Redux从其他框架借鉴过来的，本意如下：</p>\n<blockquote>\n<p>middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware<br>可以完成添加 CORS headers、记录日志、内容压缩等工作。</p>\n</blockquote>\n<p>而在Redux中：</p>\n<blockquote>\n<p>middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer<br>之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>\n</blockquote>\n<p>看完了combineReducers函数，我们继续分析applyMiddleware函数：</p>\n<p>![applyMi.png-172kB][4]</p>\n<p>applyMiddleware函数就更加简练了一些，我们一般会把redux-thunk、redux-logger这种中间件当做参数传给applyMiddleware。<br>redux的中间件是在action触发后执行的，所以中间件内部必须拿到完整的state、dispatch和action，这里使用compose包裹了中间件方法，最终返回了一个新的dispatch，可以理解为这个dispatch是经过中间件加强后的dispatch。</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p>![compose.png-80.9kB][5]</p>\n<p>这里是compose的源码，我们可以明显看出来这里是将dispatch再次作为参数放进去的，最后得到一个强化的dispatch，结合redux-logger来理解，大概是传入dispatch后对其加了打印的功能，之后再返回出来。</p>\n<h2 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h2><p>再回头来看我们的createStore函数，我们关键来看一下对应的几个函数：<br>![dispatch.png-152.4kB][6]<br>首先是我们的dispatch函数，dispatch函数主要做了两件事，一个是执行reducer函数拿到最新的state，另一个是执行subscribe的事件。<br>dispatch接收了一个action当参数，通过isDispatching来判断是否执行reducer，这也就不可能出现多个dispatch同时执行的情况了，因为这样会干扰store的值。这里看到会把currentState传到reducer里面，更新后得到了新的currentState，之后还执行了一下listener函数，这个函数是从nextListeners里面拿到的。</p>\n<h2 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h2><p>这里我们看一下subscribe函数：<br>![subscribe.png-128kB][7]</p>\n<p>subscribe会传入一个回调函数，这个函数一般是监听redux中状态变化后执行的，nextListeners里面保存着所有需要执行的回调，如果subscribe函数执行两次，那就是卸载当前加载上的listener。<br>这样的话，其实还是有一个问题，如果我们用subscribe监听了ReactDOM.render，这样我们每次发送dispatch，即使最后state没有变化，页面也是会重新render。</p>\n<h2 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h2><p>这里是自己重写的简练版redux：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 这里需要对参数为0或1的情况进行判断</span><br><span class=\"line\">const compose = (...funcs) =&gt; &#123;</span><br><span class=\"line\">    if (!funcs) &#123;</span><br><span class=\"line\">        return args =&gt; args</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (funcs.length === 1) &#123;</span><br><span class=\"line\">        return funcs[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return funcs.reduce((f1, f2) =&gt; (...args) =&gt; f1(f2(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const bindActionCreator = (action, dispatch) =&gt; &#123;</span><br><span class=\"line\">    return (...args) =&gt; dispatch(action(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const createStore = (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    if (!enhancer &amp;&amp; typeof initState === &quot;function&quot;) &#123;</span><br><span class=\"line\">        enhancer = initState</span><br><span class=\"line\">        initState = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (enhancer &amp;&amp; typeof enhancer === &quot;function&quot;) &#123;</span><br><span class=\"line\">        return enhancer(createStore)(reducer, initState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let store = initState, </span><br><span class=\"line\">        listeners = [],</span><br><span class=\"line\">        isDispatch = false;</span><br><span class=\"line\">    const getState = () =&gt; store</span><br><span class=\"line\">    const dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">        if (isDispatch) return action</span><br><span class=\"line\">        // dispatch必须一个个来</span><br><span class=\"line\">        isDispatch = true</span><br><span class=\"line\">        store = reducer(store, action)</span><br><span class=\"line\">        isDispatch = false</span><br><span class=\"line\">        listeners.forEach(listener =&gt; listener())</span><br><span class=\"line\">        return action</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        if (typeof listener === &quot;function&quot;) &#123;</span><br><span class=\"line\">            listeners.push(listener)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return () =&gt; unsubscribe(listener)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const unsubscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">        const index = listeners.indexOf(listener)</span><br><span class=\"line\">        listeners.splice(index, 1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        getState,</span><br><span class=\"line\">        dispatch,</span><br><span class=\"line\">        subscribe,</span><br><span class=\"line\">        unsubscribe</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const applyMiddleware = (...middlewares) =&gt; &#123;</span><br><span class=\"line\">    return (createStore) =&gt; (reducer, initState, enhancer) =&gt; &#123;</span><br><span class=\"line\">        const store = createStore(reducer, initState, enhancer)</span><br><span class=\"line\">        let chain = middlewares.map(middleware =&gt; middleware(store))</span><br><span class=\"line\">        store.dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">          ...store</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const combineReducers = reducers =&gt; &#123;</span><br><span class=\"line\">    const finalReducers = &#123;&#125;,</span><br><span class=\"line\">        nativeKeys = Object.keys</span><br><span class=\"line\">    nativeKeys(reducers).forEach(reducerKey =&gt; &#123;</span><br><span class=\"line\">        if(typeof reducers[reducerKey] === &quot;function&quot;) &#123;</span><br><span class=\"line\">            finalReducers[reducerKey] = reducers[reducerKey]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return (state, action) =&gt; &#123;</span><br><span class=\"line\">        const store = &#123;&#125;</span><br><span class=\"line\">        nativeKeys(finalReducers).forEach(key =&gt; &#123;</span><br><span class=\"line\">            const reducer = finalReducers[key]</span><br><span class=\"line\">            const nextState = reducer(state[key], action)</span><br><span class=\"line\">            store[key] = nextState</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redux源码实现很精简，比想象中的还要简单，react-redux在redux基础中多了Provider和connect两个方法，通过context将store传给Provider包裹的组件，之后会再开一篇文章分析react-redux的源码。<br>  [1]: <a href=\"http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/1jibi2tofs7mazu6jfsmxs7s/redux%E5%85%A5%E5%8F%A3.png</a><br>  [2]: <a href=\"http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/an7e9bhcfayz00zh4etg20w1/createStore.png</a><br>  [3]: <a href=\"http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/kum9agu106cscpkcp1wbsarb/combineReducers.png</a><br>  [4]: <a href=\"http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/0jwy1qmx1uqwsnzgjm1qas2f/applyMi.png</a><br>  [5]: <a href=\"http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/tw7co5q0p8dkn1kdyqyi72en/compose.png</a><br>  [6]: <a href=\"http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/y8s7f4h2s6dmzqxb2zpa5kte/dispatch.png</a><br>  [7]: <a href=\"http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png\" target=\"_blank\" rel=\"noopener\">http://static.zybuluo.com/gyyin/fmtq4qz206dnet1s2h4x4zz1/subscribe.png</a></p>"},{"title":"underscore源码剖析之基础方法","date":"2018-03-17T14:10:16.000Z","_content":"本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。\n## mixin ##\n在上篇文章[underscore整体架构分析][1]中，我们讲过**\\_**上面的方法有两种挂载方式，一个是挂载到**\\_**构造函数上以\\_.map(arr)的形式直接调用**（在后文上统称构造函数调用）**，另一种则是挂到\\_.prototype上以\\_(arr).map()的形式被实例调用**（在后文上统称原型调用）**。\n\n翻一遍underscore源码你会发现underscore中的方法都是直接挂到\\_构造函数上实现的，但是会通过mixin方法来将\\_上面的方法扩展到\\_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。\n```\n_.mixin = function(obj) {\n    // 遍历obj上所有的方法\n    _.each(_.functions(obj), function(name) {\n        // 保存方法的引用\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            // 将一开始传入的值放到数组中\n            var args = [this._wrapped];\n            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）\n            push.apply(args, arguments);\n            // 这里先用apply方法执行了func，并将结果传给了result\n            return result(this, func.apply(_, args));\n        };\n    });\n};\n\n_.mixin(_);\n```\n从这段代码中我们可以看出，mixin方法将\\_上的所有方法通过遍历的形式挂载到了\\_.prototype上面。\n<!-- more -->\n细心观察一下，构造函数调用和原型调用的区别在哪里？\n没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入\\_构造函数来创建一个实例。\n```\nvar arr = [1, 2, 3]\nvar func = function(item) {\n    console.log(item);\n}\n// 构造函数调用时arr被传入第一个参数\n_.each(arr, func)\n// 原型调用的时候，arr被当做参数传给_方法来创建一个实例\n_(arr).each(func)\n// 链式调用，和上面类似\n_.chain(arr).each(func)\n```\n从上一节中我们知道，在创建一个\\_的实例时，会用this.\\_wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this.\\_wrapped];是将我们传给\\_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接\\_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。\n## 链式调用 ##\n那么上面最后return result(this, func.apply(\\_, args))，result又是做什么的呢？\n\n首先来看result源码：\n```\nvar result = function(instance, obj) {\n    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果\n    return instance._chain ? _(obj).chain() : obj;\n};\n_.chain = function(obj) {\n    // 创建一个实例\n    var instance = _(obj);\n    // 给这个实例加个_chain属性来表明这是链式调用\n    instance._chain = true;\n    return instance;\n};\n```\n我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：\n```\nvar arr = [1, 2, 3]\nvar newArr = _.chain(a).map(function(item) {\n    return item + 1\n}).filter(function(item) {\n    return item > 2\n}).value()\n```\n链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。\nchain方法会用传入的obj创建一个\\_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。\n链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的\\_实例）\n## 数组函数 ##\nunderscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。\n```\n_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n    var obj = this._wrapped;\n    method.apply(obj, arguments);\n    // 这句是好像是为了解决ie上的bug？\n    if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n        return result(this, obj);\n    };\n});\n\n_.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n        return result(this, method.apply(this._wrapped, arguments));\n    };\n});\n```\n  [1]: https://segmentfault.com/a/1190000013789060?_ea=3463450\n  <head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","source":"_posts/underscore源码剖析之基础方法.md","raw":"---\ntitle: underscore源码剖析之基础方法\ndate: 2018-03-17 22:10:16\ntags:\n\t- underscore\n\t- 前端\n\t- 编程\ncategories: \n    - underscore\n---\n本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。\n## mixin ##\n在上篇文章[underscore整体架构分析][1]中，我们讲过**\\_**上面的方法有两种挂载方式，一个是挂载到**\\_**构造函数上以\\_.map(arr)的形式直接调用**（在后文上统称构造函数调用）**，另一种则是挂到\\_.prototype上以\\_(arr).map()的形式被实例调用**（在后文上统称原型调用）**。\n\n翻一遍underscore源码你会发现underscore中的方法都是直接挂到\\_构造函数上实现的，但是会通过mixin方法来将\\_上面的方法扩展到\\_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。\n```\n_.mixin = function(obj) {\n    // 遍历obj上所有的方法\n    _.each(_.functions(obj), function(name) {\n        // 保存方法的引用\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            // 将一开始传入的值放到数组中\n            var args = [this._wrapped];\n            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）\n            push.apply(args, arguments);\n            // 这里先用apply方法执行了func，并将结果传给了result\n            return result(this, func.apply(_, args));\n        };\n    });\n};\n\n_.mixin(_);\n```\n从这段代码中我们可以看出，mixin方法将\\_上的所有方法通过遍历的形式挂载到了\\_.prototype上面。\n<!-- more -->\n细心观察一下，构造函数调用和原型调用的区别在哪里？\n没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入\\_构造函数来创建一个实例。\n```\nvar arr = [1, 2, 3]\nvar func = function(item) {\n    console.log(item);\n}\n// 构造函数调用时arr被传入第一个参数\n_.each(arr, func)\n// 原型调用的时候，arr被当做参数传给_方法来创建一个实例\n_(arr).each(func)\n// 链式调用，和上面类似\n_.chain(arr).each(func)\n```\n从上一节中我们知道，在创建一个\\_的实例时，会用this.\\_wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this.\\_wrapped];是将我们传给\\_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接\\_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。\n## 链式调用 ##\n那么上面最后return result(this, func.apply(\\_, args))，result又是做什么的呢？\n\n首先来看result源码：\n```\nvar result = function(instance, obj) {\n    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果\n    return instance._chain ? _(obj).chain() : obj;\n};\n_.chain = function(obj) {\n    // 创建一个实例\n    var instance = _(obj);\n    // 给这个实例加个_chain属性来表明这是链式调用\n    instance._chain = true;\n    return instance;\n};\n```\n我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：\n```\nvar arr = [1, 2, 3]\nvar newArr = _.chain(a).map(function(item) {\n    return item + 1\n}).filter(function(item) {\n    return item > 2\n}).value()\n```\n链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。\nchain方法会用传入的obj创建一个\\_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。\n链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的\\_实例）\n## 数组函数 ##\nunderscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。\n```\n_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n    var obj = this._wrapped;\n    method.apply(obj, arguments);\n    // 这句是好像是为了解决ie上的bug？\n    if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n        return result(this, obj);\n    };\n});\n\n_.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n        return result(this, method.apply(this._wrapped, arguments));\n    };\n});\n```\n  [1]: https://segmentfault.com/a/1190000013789060?_ea=3463450\n  <head> \n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n</head>\n<body>\n    <div id=\"comment\"></div>\n</body>","slug":"underscore源码剖析之基础方法","published":1,"updated":"2018-11-22T11:48:30.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosj9o3o000jfszxc60eeel6","content":"<p>本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。</p>\n<h2 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h2><p>在上篇文章<a href=\"https://segmentfault.com/a/1190000013789060?_ea=3463450\" target=\"_blank\" rel=\"noopener\">underscore整体架构分析</a>中，我们讲过<strong>_</strong>上面的方法有两种挂载方式，一个是挂载到<strong>_</strong>构造函数上以_.map(arr)的形式直接调用<strong>（在后文上统称构造函数调用）</strong>，另一种则是挂到_.prototype上以_(arr).map()的形式被实例调用<strong>（在后文上统称原型调用）</strong>。</p>\n<p>翻一遍underscore源码你会发现underscore中的方法都是直接挂到_构造函数上实现的，但是会通过mixin方法来将_上面的方法扩展到_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.mixin = function(obj) &#123;</span><br><span class=\"line\">    // 遍历obj上所有的方法</span><br><span class=\"line\">    _.each(_.functions(obj), function(name) &#123;</span><br><span class=\"line\">        // 保存方法的引用</span><br><span class=\"line\">        var func = _[name] = obj[name];</span><br><span class=\"line\">        _.prototype[name] = function() &#123;</span><br><span class=\"line\">            // 将一开始传入的值放到数组中</span><br><span class=\"line\">            var args = [this._wrapped];</span><br><span class=\"line\">            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）</span><br><span class=\"line\">            push.apply(args, arguments);</span><br><span class=\"line\">            // 这里先用apply方法执行了func，并将结果传给了result</span><br><span class=\"line\">            return result(this, func.apply(_, args));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_.mixin(_);</span><br></pre></td></tr></table></figure></p>\n<p>从这段代码中我们可以看出，mixin方法将_上的所有方法通过遍历的形式挂载到了_.prototype上面。<br><a id=\"more\"></a><br>细心观察一下，构造函数调用和原型调用的区别在哪里？<br>没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入_构造函数来创建一个实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var func = function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造函数调用时arr被传入第一个参数</span><br><span class=\"line\">_.each(arr, func)</span><br><span class=\"line\">// 原型调用的时候，arr被当做参数传给_方法来创建一个实例</span><br><span class=\"line\">_(arr).each(func)</span><br><span class=\"line\">// 链式调用，和上面类似</span><br><span class=\"line\">_.chain(arr).each(func)</span><br></pre></td></tr></table></figure></p>\n<p>从上一节中我们知道，在创建一个_的实例时，会用this._wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this._wrapped];是将我们传给_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>那么上面最后return result(this, func.apply(_, args))，result又是做什么的呢？</p>\n<p>首先来看result源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = function(instance, obj) &#123;</span><br><span class=\"line\">    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果</span><br><span class=\"line\">    return instance._chain ? _(obj).chain() : obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.chain = function(obj) &#123;</span><br><span class=\"line\">    // 创建一个实例</span><br><span class=\"line\">    var instance = _(obj);</span><br><span class=\"line\">    // 给这个实例加个_chain属性来表明这是链式调用</span><br><span class=\"line\">    instance._chain = true;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = _.chain(a).map(function(item) &#123;</span><br><span class=\"line\">    return item + 1</span><br><span class=\"line\">&#125;).filter(function(item) &#123;</span><br><span class=\"line\">    return item &gt; 2</span><br><span class=\"line\">&#125;).value()</span><br></pre></td></tr></table></figure></p>\n<p>链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。<br>chain方法会用传入的obj创建一个_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。<br>链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的_实例）</p>\n<h2 id=\"数组函数\"><a href=\"#数组函数\" class=\"headerlink\" title=\"数组函数\"></a>数组函数</h2><p>underscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">    var obj = this._wrapped;</span><br><span class=\"line\">    method.apply(obj, arguments);</span><br><span class=\"line\">    // 这句是好像是为了解决ie上的bug？</span><br><span class=\"line\">    if ((name === &apos;shift&apos; || name === &apos;splice&apos;) &amp;&amp; obj.length === 0) delete obj[0];</span><br><span class=\"line\">        return result(this, obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_.each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">        return result(this, method.apply(this._wrapped, arguments));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>","site":{"data":{}},"excerpt":"<p>本文是underscore源码剖析系列的第二篇，主要介绍underscore中一些基础方法的实现。</p>\n<h2 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h2><p>在上篇文章<a href=\"https://segmentfault.com/a/1190000013789060?_ea=3463450\" target=\"_blank\" rel=\"noopener\">underscore整体架构分析</a>中，我们讲过<strong>_</strong>上面的方法有两种挂载方式，一个是挂载到<strong>_</strong>构造函数上以_.map(arr)的形式直接调用<strong>（在后文上统称构造函数调用）</strong>，另一种则是挂到_.prototype上以_(arr).map()的形式被实例调用<strong>（在后文上统称原型调用）</strong>。</p>\n<p>翻一遍underscore源码你会发现underscore中的方法都是直接挂到_构造函数上实现的，但是会通过mixin方法来将_上面的方法扩展到_.prototype上面，这样这些方法既可以直接调用，又可以通过实例来调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.mixin = function(obj) &#123;</span><br><span class=\"line\">    // 遍历obj上所有的方法</span><br><span class=\"line\">    _.each(_.functions(obj), function(name) &#123;</span><br><span class=\"line\">        // 保存方法的引用</span><br><span class=\"line\">        var func = _[name] = obj[name];</span><br><span class=\"line\">        _.prototype[name] = function() &#123;</span><br><span class=\"line\">            // 将一开始传入的值放到数组中</span><br><span class=\"line\">            var args = [this._wrapped];</span><br><span class=\"line\">            // 将方法的参数一起push到数组中（这里处理的很好，保证了func方法参数的顺序）</span><br><span class=\"line\">            push.apply(args, arguments);</span><br><span class=\"line\">            // 这里先用apply方法执行了func，并将结果传给了result</span><br><span class=\"line\">            return result(this, func.apply(_, args));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_.mixin(_);</span><br></pre></td></tr></table></figure></p>\n<p>从这段代码中我们可以看出，mixin方法将_上的所有方法通过遍历的形式挂载到了_.prototype上面。<br>","more":"<br>细心观察一下，构造函数调用和原型调用的区别在哪里？<br>没错，区别就在于调用方式和传参，构造函数调用时一般会把要处理的值当做第一个参数传入，而原型调用的时候会把要处理的值传入_构造函数来创建一个实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var func = function(item) &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造函数调用时arr被传入第一个参数</span><br><span class=\"line\">_.each(arr, func)</span><br><span class=\"line\">// 原型调用的时候，arr被当做参数传给_方法来创建一个实例</span><br><span class=\"line\">_(arr).each(func)</span><br><span class=\"line\">// 链式调用，和上面类似</span><br><span class=\"line\">_.chain(arr).each(func)</span><br></pre></td></tr></table></figure></p>\n<p>从上一节中我们知道，在创建一个_的实例时，会用this._wrapped将传入的值保存起来，所以在mixin里面这一句：var args = [this._wrapped];是将我们传给_的值放到args数组第一项中，之后再将arguments也放入args数组中，借助apply方法执行当前遍历的方法（在这个例子中是each），这个时候传给each方法的是arr和func，正好和原来直接_.each调用each传入参数的顺序是一样的（underscore中的方法第一项基本上都是要处理的数据）。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>那么上面最后return result(this, func.apply(_, args))，result又是做什么的呢？</p>\n<p>首先来看result源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = function(instance, obj) &#123;</span><br><span class=\"line\">    // 首先判断是否使用链式调用，如果是，那就继续将刚刚执行后返回的结果链式调用一下，如果不是，则直接返回执行后的结果</span><br><span class=\"line\">    return instance._chain ? _(obj).chain() : obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.chain = function(obj) &#123;</span><br><span class=\"line\">    // 创建一个实例</span><br><span class=\"line\">    var instance = _(obj);</span><br><span class=\"line\">    // 给这个实例加个_chain属性来表明这是链式调用</span><br><span class=\"line\">    instance._chain = true;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道underscore中也是有和jQuery类似的链式调用，来看一下链式调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = _.chain(a).map(function(item) &#123;</span><br><span class=\"line\">    return item + 1</span><br><span class=\"line\">&#125;).filter(function(item) &#123;</span><br><span class=\"line\">    return item &gt; 2</span><br><span class=\"line\">&#125;).value()</span><br></pre></td></tr></table></figure></p>\n<p>链式调用的关键在于每次执行方法后都需要返回一个实例，以确保能够继续调用其他方法。<br>chain方法会用传入的obj创建一个_的实例，这个实例可以调用原型上的方法。从上面mixin的实现来看，每次调用原型方法后会将执行后的结果传给result方法，在result内部会判断你是否使用了链式调用（chain），如果是链式的，那么就会将返回结果链式化（传入chain中创建新的实例）。<br>链式调用一定要在结尾执行value方法，不然最后返回的是一个对象（最后一次创建的_实例）</p>\n<h2 id=\"数组函数\"><a href=\"#数组函数\" class=\"headerlink\" title=\"数组函数\"></a>数组函数</h2><p>underscore构造方法上面并没有直接对push、pop、shift等数组方法进行实现，但是链式调用的时候往往需要用到这些方法，所以在原型上对这些方法做了一些封装，实现方法和mixin类似，这里不再多做解释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">    var obj = this._wrapped;</span><br><span class=\"line\">    method.apply(obj, arguments);</span><br><span class=\"line\">    // 这句是好像是为了解决ie上的bug？</span><br><span class=\"line\">    if ((name === &apos;shift&apos; || name === &apos;splice&apos;) &amp;&amp; obj.length === 0) delete obj[0];</span><br><span class=\"line\">        return result(this, obj);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_.each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123;</span><br><span class=\"line\">    var method = ArrayProto[name];</span><br><span class=\"line\">    _.prototype[name] = function() &#123;</span><br><span class=\"line\">        return result(this, method.apply(this._wrapped, arguments));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  <head><br>    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script><br>    <script src=\"//unpkg.com/valine/dist/Valine.min.js\"></script><br></head></p>\n<body><br>    <div id=\"comment\"></div><br></body>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjosj7rx60006fpzxtyiw7lgj","category_id":"cjosj7rxj000efpzx2r07esee","_id":"cjosj7rxs000nfpzxogjvcy8v"},{"post_id":"cjosj7rxb0008fpzxros8ffly","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rxx000vfpzx8lo8brl4"},{"post_id":"cjosj7rwu0000fpzxmahufq7e","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rxy000zfpzx70jjq1hp"},{"post_id":"cjosj7rxc0009fpzxhw6dyncr","category_id":"cjosj7rxx000ufpzxoy5cza35","_id":"cjosj7rxz0015fpzxn2kftzu3"},{"post_id":"cjosj7rxe000cfpzxxomas6be","category_id":"cjosj7rxz0010fpzxgal4tg9k","_id":"cjosj7ry0001afpzxt5jmkpcg"},{"post_id":"cjosj7rx10002fpzxr18uar93","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7ry1001cfpzxckynbq6o"},{"post_id":"cjosj7rxh000dfpzxx45qgwyh","category_id":"cjosj7ry00019fpzxn3ji9x0z","_id":"cjosj7ry3001ifpzx6q4x8sy3"},{"post_id":"cjosj7rxk000gfpzxo3kep36u","category_id":"cjosj7rxx000ufpzxoy5cza35","_id":"cjosj7ry3001mfpzx6vda1v6b"},{"post_id":"cjosj7rxn000hfpzxr40nhcpc","category_id":"cjosj7ry2001hfpzxvn0m03by","_id":"cjosj7ry5001sfpzxkbzakz90"},{"post_id":"cjosj7rxp000kfpzx3cl0npoz","category_id":"cjosj7rxz0010fpzxgal4tg9k","_id":"cjosj7ry5001vfpzx3p484z0q"},{"post_id":"cjosj7rxr000mfpzxk38fwyhr","category_id":"cjosj7ry4001rfpzx8gcw69sh","_id":"cjosj7ry70021fpzxhhzrl1c5"},{"post_id":"cjosj7rxu000rfpzxkxxff5zz","category_id":"cjosj7ry00019fpzxn3ji9x0z","_id":"cjosj7ry80024fpzx11fcl7rs"},{"post_id":"cjosj7rxw000tfpzxiz46gops","category_id":"cjosj7ry4001rfpzx8gcw69sh","_id":"cjosj7ry90026fpzx5usqh7fb"},{"post_id":"cjosj7rxx000xfpzx1me2xvdv","category_id":"cjosj7ry80023fpzxhdgpfp68","_id":"cjosj7rya0029fpzx81mpe3x8"},{"post_id":"cjosj7rz4003ffpzx2ammtsrw","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rz8003ofpzx978djjj4"},{"post_id":"cjosj7rz5003ifpzxqb2pne14","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rzc003ufpzxcw1gjbed"},{"post_id":"cjosj7rz6003kfpzx03zv05h7","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rzd003zfpzx3wqlyue6"},{"post_id":"cjosj7rz7003mfpzx7mdxxh5n","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj7rze0043fpzxcieypapk"},{"post_id":"cjosj7rz9003qfpzxb0txrnzz","category_id":"cjosj7ry00019fpzxn3ji9x0z","_id":"cjosj7rzf0047fpzx7spkpqpk"},{"post_id":"cjosj7rz3003efpzx825cw978","category_id":"cjosj7rz5003gfpzxvtj0rio9","_id":"cjosj7rzi0049fpzxsndxsu4l"},{"post_id":"cjosj7s2r004ifpzxid0x6hjq","category_id":"cjosj7s2t004jfpzxs7d8d94t","_id":"cjosj7s2v004mfpzxl5gp0uz4"},{"post_id":"cjosj8gqk0000fszx2mc5pze2","category_id":"cjosj8gqq0001fszxx2w3v47f","_id":"cjosj8gqr0005fszxyyqgq4a4"},{"post_id":"cjosj9bwz0006fszx8205cajg","category_id":"cjosj9bx10007fszxlgxvhu3q","_id":"cjosj9bx2000afszxlzr3pigi"},{"post_id":"cjosj9edm000efszx8prwn66i","category_id":"cjosj9bx10007fszxlgxvhu3q","_id":"cjosj9edn000hfszxzd6np59c"},{"post_id":"cjosj9o3o000jfszxc60eeel6","category_id":"cjosj7rx40004fpzxg86oflu5","_id":"cjosj9o3r000mfszxr3tovvrs"}],"PostTag":[{"post_id":"cjosj7rwu0000fpzxmahufq7e","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rxq000lfpzxnd3v5tkn"},{"post_id":"cjosj7rwu0000fpzxmahufq7e","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rxt000ofpzxps10ncdd"},{"post_id":"cjosj7rwu0000fpzxmahufq7e","tag_id":"cjosj7rxj000ffpzx8yc9wt8j","_id":"cjosj7rxv000sfpzxmz4akio4"},{"post_id":"cjosj7rx10002fpzxr18uar93","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rxz0013fpzxga1ov4gw"},{"post_id":"cjosj7rx10002fpzxr18uar93","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rxz0014fpzxflcyz4m1"},{"post_id":"cjosj7rx10002fpzxr18uar93","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7ry00018fpzxlncd5pws"},{"post_id":"cjosj7rx60006fpzxtyiw7lgj","tag_id":"cjosj7rxz0011fpzxy5nr4fx3","_id":"cjosj7ry2001gfpzx4rzp33cc"},{"post_id":"cjosj7rx60006fpzxtyiw7lgj","tag_id":"cjosj7ry00017fpzxsv8hy75r","_id":"cjosj7ry3001jfpzxe2pb7vlj"},{"post_id":"cjosj7rx60006fpzxtyiw7lgj","tag_id":"cjosj7ry1001bfpzxphnuwlbz","_id":"cjosj7ry3001lfpzxfrvl5kdk"},{"post_id":"cjosj7rxb0008fpzxros8ffly","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7ry4001pfpzxsjjbksah"},{"post_id":"cjosj7rxb0008fpzxros8ffly","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7ry4001qfpzxlcf4m5vt"},{"post_id":"cjosj7rxb0008fpzxros8ffly","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7ry5001ufpzxpy31sllc"},{"post_id":"cjosj7rxc0009fpzxhw6dyncr","tag_id":"cjosj7ry4001ofpzxqkl5543f","_id":"cjosj7ry6001yfpzxofpl1yg3"},{"post_id":"cjosj7rxc0009fpzxhw6dyncr","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7ry7001zfpzx7t13ket3"},{"post_id":"cjosj7rxe000cfpzxxomas6be","tag_id":"cjosj7ry6001xfpzxzt5l6c30","_id":"cjosj7ry90028fpzxsina3q57"},{"post_id":"cjosj7rxe000cfpzxxomas6be","tag_id":"cjosj7ry70022fpzx3zon3gnq","_id":"cjosj7rya002afpzxt1gx6dtj"},{"post_id":"cjosj7rxe000cfpzxxomas6be","tag_id":"cjosj7ry80025fpzxlrouz2s3","_id":"cjosj7rya002cfpzxdotdxqob"},{"post_id":"cjosj7rxh000dfpzxx45qgwyh","tag_id":"cjosj7ry6001xfpzxzt5l6c30","_id":"cjosj7ryb002ffpzxgq1bie5p"},{"post_id":"cjosj7rxh000dfpzxx45qgwyh","tag_id":"cjosj7ry70022fpzx3zon3gnq","_id":"cjosj7ryb002gfpzxph88d8st"},{"post_id":"cjosj7rxh000dfpzxx45qgwyh","tag_id":"cjosj7ry80025fpzxlrouz2s3","_id":"cjosj7ryc002ifpzx2otrstbr"},{"post_id":"cjosj7rxk000gfpzxo3kep36u","tag_id":"cjosj7ryb002efpzxgxj9mvne","_id":"cjosj7ryc002kfpzxfz05a2r5"},{"post_id":"cjosj7rxk000gfpzxo3kep36u","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7ryd002lfpzxbyatx82o"},{"post_id":"cjosj7rxk000gfpzxo3kep36u","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7ryd002nfpzxrtgftbza"},{"post_id":"cjosj7rxn000hfpzxr40nhcpc","tag_id":"cjosj7ryc002jfpzx1nwy8frs","_id":"cjosj7rye002pfpzxf7s16gab"},{"post_id":"cjosj7rxn000hfpzxr40nhcpc","tag_id":"cjosj7ry6001xfpzxzt5l6c30","_id":"cjosj7rye002qfpzxbstfe98n"},{"post_id":"cjosj7rxp000kfpzx3cl0npoz","tag_id":"cjosj7ry6001xfpzxzt5l6c30","_id":"cjosj7ryg002ufpzx7rlpc3qb"},{"post_id":"cjosj7rxp000kfpzx3cl0npoz","tag_id":"cjosj7ry70022fpzx3zon3gnq","_id":"cjosj7ryg002vfpzxvwqp19q6"},{"post_id":"cjosj7rxp000kfpzx3cl0npoz","tag_id":"cjosj7ry80025fpzxlrouz2s3","_id":"cjosj7ryg002xfpzxol5o0hhv"},{"post_id":"cjosj7rxr000mfpzxk38fwyhr","tag_id":"cjosj7ryg002tfpzxg1ps83u8","_id":"cjosj7ryh002zfpzx1rc4zggo"},{"post_id":"cjosj7rxr000mfpzxk38fwyhr","tag_id":"cjosj7rxz0011fpzxy5nr4fx3","_id":"cjosj7ryh0030fpzx355rqjlw"},{"post_id":"cjosj7rxu000rfpzxkxxff5zz","tag_id":"cjosj7ry6001xfpzxzt5l6c30","_id":"cjosj7ryj0034fpzxxo7j9lbq"},{"post_id":"cjosj7rxu000rfpzxkxxff5zz","tag_id":"cjosj7ry70022fpzx3zon3gnq","_id":"cjosj7ryj0035fpzx2benl9lt"},{"post_id":"cjosj7rxu000rfpzxkxxff5zz","tag_id":"cjosj7ry80025fpzxlrouz2s3","_id":"cjosj7ryj0037fpzxo376l6sp"},{"post_id":"cjosj7rxw000tfpzxiz46gops","tag_id":"cjosj7ryg002tfpzxg1ps83u8","_id":"cjosj7ryk0039fpzxqojxud9q"},{"post_id":"cjosj7rxw000tfpzxiz46gops","tag_id":"cjosj7ryj0036fpzx19whz59q","_id":"cjosj7ryk003afpzx9tmn5gam"},{"post_id":"cjosj7rxx000xfpzx1me2xvdv","tag_id":"cjosj7ry4001ofpzxqkl5543f","_id":"cjosj7ryl003cfpzxw3ijj3ub"},{"post_id":"cjosj7rxx000xfpzx1me2xvdv","tag_id":"cjosj7ryk003bfpzxjs179qy0","_id":"cjosj7ryl003dfpzxu3g6ixbz"},{"post_id":"cjosj7rz4003ffpzx2ammtsrw","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rz6003jfpzx0def927n"},{"post_id":"cjosj7rz4003ffpzx2ammtsrw","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rz7003lfpzx0up315pg"},{"post_id":"cjosj7rz4003ffpzx2ammtsrw","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7rz9003pfpzxryd8zs9f"},{"post_id":"cjosj7rz5003ifpzxqb2pne14","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rzb003tfpzxcpwh5tti"},{"post_id":"cjosj7rz5003ifpzxqb2pne14","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rzc003wfpzxqtamy3ik"},{"post_id":"cjosj7rz5003ifpzxqb2pne14","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7rzd003yfpzxdo49cqb3"},{"post_id":"cjosj7rz6003kfpzx03zv05h7","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rzd0040fpzxf3qetqxl"},{"post_id":"cjosj7rz6003kfpzx03zv05h7","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rzd0042fpzx4csmaiyb"},{"post_id":"cjosj7rz6003kfpzx03zv05h7","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7rze0044fpzxdmrrnhrr"},{"post_id":"cjosj7rz7003mfpzx7mdxxh5n","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj7rzf0046fpzxmyrzrhfy"},{"post_id":"cjosj7rz7003mfpzx7mdxxh5n","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rzh0048fpzxhemlclrz"},{"post_id":"cjosj7rz7003mfpzx7mdxxh5n","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj7rzi004afpzxiu0c1nrn"},{"post_id":"cjosj7rz3003efpzx825cw978","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7rzi004cfpzxqhn58yv4"},{"post_id":"cjosj7rz3003efpzx825cw978","tag_id":"cjosj7rz5003hfpzx696wes63","_id":"cjosj7rzi004dfpzxvtt70us4"},{"post_id":"cjosj7rz3003efpzx825cw978","tag_id":"cjosj7rz8003nfpzxv1y0yhwv","_id":"cjosj7rzj004efpzx41mhgbyv"},{"post_id":"cjosj7rz9003qfpzxb0txrnzz","tag_id":"cjosj7rzc003vfpzx9pk6uo1t","_id":"cjosj7rzj004ffpzxzsp2kf83"},{"post_id":"cjosj7rz9003qfpzxb0txrnzz","tag_id":"cjosj7ry70022fpzx3zon3gnq","_id":"cjosj7rzk004gfpzxtd372onl"},{"post_id":"cjosj7rz9003qfpzxb0txrnzz","tag_id":"cjosj7ry80025fpzxlrouz2s3","_id":"cjosj7rzk004hfpzxvverctb6"},{"post_id":"cjosj7s2r004ifpzxid0x6hjq","tag_id":"cjosj7ry4001ofpzxqkl5543f","_id":"cjosj7s2t004kfpzx3fic2wu7"},{"post_id":"cjosj7s2r004ifpzxid0x6hjq","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj7s2t004lfpzxzlgu1c39"},{"post_id":"cjosj8gqk0000fszx2mc5pze2","tag_id":"cjosj8gqq0002fszxd60hlerb","_id":"cjosj8gqr0003fszxh0d4hv03"},{"post_id":"cjosj8gqk0000fszx2mc5pze2","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj8gqr0004fszxde8rm677"},{"post_id":"cjosj9bwz0006fszx8205cajg","tag_id":"cjosj9bx20008fszxt4m1o1kz","_id":"cjosj9bx2000bfszxivwg9i6i"},{"post_id":"cjosj9bwz0006fszx8205cajg","tag_id":"cjosj9bx20009fszxu51td28g","_id":"cjosj9bx3000cfszxxrwgjpiz"},{"post_id":"cjosj9bwz0006fszx8205cajg","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj9bx3000dfszxo6bemq66"},{"post_id":"cjosj9edm000efszx8prwn66i","tag_id":"cjosj9bx20008fszxt4m1o1kz","_id":"cjosj9edn000ffszxwlw7tng3"},{"post_id":"cjosj9edm000efszx8prwn66i","tag_id":"cjosj9bx20009fszxu51td28g","_id":"cjosj9edn000gfszxsdjn1rzq"},{"post_id":"cjosj9edm000efszx8prwn66i","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj9edn000ifszxnbt3q7q2"},{"post_id":"cjosj9o3o000jfszxc60eeel6","tag_id":"cjosj7rx60005fpzxg7caor50","_id":"cjosj9o3r000kfszxx35fsd6n"},{"post_id":"cjosj9o3o000jfszxc60eeel6","tag_id":"cjosj7rxd000bfpzxv1i472im","_id":"cjosj9o3r000lfszxrsotktk7"},{"post_id":"cjosj9o3o000jfszxc60eeel6","tag_id":"cjosj7rxx000wfpzxr389hf3a","_id":"cjosj9o3r000nfszx2ftvnnk4"}],"Tag":[{"name":"underscore","_id":"cjosj7rx60005fpzxg7caor50"},{"name":"前端","_id":"cjosj7rxd000bfpzxv1i472im"},{"name":"模板引擎","_id":"cjosj7rxj000ffpzx8yc9wt8j"},{"name":"编程","_id":"cjosj7rxx000wfpzxr389hf3a"},{"name":"电影","_id":"cjosj7rxz0011fpzxy5nr4fx3"},{"name":"观后感","_id":"cjosj7ry00017fpzxsv8hy75r"},{"name":"个人笔记","_id":"cjosj7ry1001bfpzxphnuwlbz"},{"name":"读书笔记","_id":"cjosj7ry4001ofpzxqkl5543f"},{"name":"思考","_id":"cjosj7ry6001xfpzxzt5l6c30"},{"name":"生活","_id":"cjosj7ry70022fpzx3zon3gnq"},{"name":"随笔","_id":"cjosj7ry80025fpzxlrouz2s3"},{"name":"polyfill","_id":"cjosj7ryb002efpzxgxj9mvne"},{"name":"理财","_id":"cjosj7ryc002jfpzx1nwy8frs"},{"name":"歌曲","_id":"cjosj7ryg002tfpzxg1ps83u8"},{"name":"陈升","_id":"cjosj7ryj0036fpzx19whz59q"},{"name":"说话技巧","_id":"cjosj7ryk003bfpzxjs179qy0"},{"name":"函数式编程","_id":"cjosj7rz5003hfpzx696wes63"},{"name":"javascript","_id":"cjosj7rz8003nfpzxv1y0yhwv"},{"name":"毕业","_id":"cjosj7rzc003vfpzx9pk6uo1t"},{"name":"TypeScript","_id":"cjosj8gqq0002fszxd60hlerb"},{"name":"redux","_id":"cjosj9bx20008fszxt4m1o1kz"},{"name":"react","_id":"cjosj9bx20009fszxu51td28g"}]}}